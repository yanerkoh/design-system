{
  "mappings": "KAEK,mBAAmB;CACtB;;AAKF,OAAO,iBAAS,SAAS,UAAU,UACjC,MAAM,GACN,eACA,oBACC,IAAI;CACL;;AA8BF,OAAO,iBAAS;CACd,WAAW,GAAG;CACd,oBAAoB,IAAI;EACtB;;EAGF,IAAI,GACJ,cACA,UAAS,kBACT,oBACC;;;;;AAmBH,OAAO,iBAAS,iBAAiB,GAAG,KAAK,GAAG,eAAU",
  "names": [],
  "sources": [
    "src/index.ts"
  ],
  "sourcesContent": [
    "import * as React from 'react'\n\ntype DebounceSettings = {\n  leading?: boolean\n}\n\n// TODO doesn't return value of the function called :/\n\nexport function debounce<A extends Function>(\n  func: A,\n  wait?: number,\n  leading?: boolean\n): A & {\n  cancel: () => void\n} {\n  let timeout: any\n  let isCancelled = false\n\n  function debounced(this: any) {\n    isCancelled = false\n    const args = arguments\n    if (leading && !timeout) {\n      func.apply(this, args)\n    }\n    clearTimeout(timeout)\n    timeout = setTimeout(() => {\n      timeout = null\n      if (!(leading || isCancelled)) {\n        func.apply(this, args)\n      }\n      isCancelled = false\n    }, wait)\n  }\n\n  debounced.cancel = () => {\n    isCancelled = true\n  }\n\n  return debounced as any\n}\n\nconst defaultOpts = { leading: false }\n\nexport function useDebounce<\n  A extends (...args: any) => any | undefined | null,\n  DebouncedFn extends A & {\n    cancel: () => void\n  },\n>(\n  fn: A,\n  wait: number,\n  options: DebounceSettings = defaultOpts,\n  mountArgs: any[] = [fn]\n): DebouncedFn {\n  const dbEffect = React.useRef<DebouncedFn | null>(null)\n\n  React.useEffect(() => {\n    return () => {\n      dbEffect.current?.cancel()\n    }\n  }, [])\n\n  return React.useMemo(() => {\n    dbEffect.current = debounce(fn, wait, options.leading) as unknown as DebouncedFn\n    return dbEffect.current\n  }, [options.leading, ...mountArgs])\n}\n\n/**\n * Returns a value once it stops changing after \"amt\" time.\n * Note: you may need to memo or this will keep re-rendering\n */\nexport function useDebounceValue<A>(val: A, amt = 0): A {\n  const [state, setState] = React.useState(val)\n\n  React.useEffect(() => {\n    const tm = setTimeout(() => {\n      setState((prev) => {\n        if (prev === val) return prev\n        return val\n      })\n    }, amt)\n\n    return () => {\n      clearTimeout(tm)\n    }\n  }, [val])\n\n  return state\n}\n"
  ],
  "version": 3
}
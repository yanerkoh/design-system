{
  "mappings": "AAcA,OAAO,iBAAS,WAAW,oBAAoB,QAAQ;AA0EvD,OAAO,iBAAS,WAAW,sBAAsB;CAC/C;CACA;CACA,aAAa;EACX;EACA;EACA",
  "names": [],
  "sources": [
    "src/matchQuery.ts"
  ],
  "sourcesContent": [
    "/*\nCopyright (c) 2014, Yahoo! Inc. All rights reserved.\nCopyrights licensed under the New BSD License.\nSee the accompanying LICENSE file for terms.\n*/\n\n// -----------------------------------------------------------------------------\n\nconst RE_MEDIA_QUERY = /(?:(only|not)?\\s*([^\\s\\(\\)]+)(?:\\s*and)?\\s*)?(.+)?/i\nconst RE_MQ_EXPRESSION = /\\(\\s*([^\\s\\:\\)]+)\\s*(?:\\:\\s*([^\\s\\)]+))?\\s*\\)/\nconst RE_MQ_FEATURE = /^(?:(min|max)-)?(.+)/\nconst RE_LENGTH_UNIT = /(em|rem|px|cm|mm|in|pt|pc)?$/\nconst RE_RESOLUTION_UNIT = /(dpi|dpcm|dppx)?$/\n\nexport function matchQuery(mediaQuery: string, values: Record<string, any>): boolean {\n  return parseQuery(mediaQuery).some((query) => {\n    if (!query) return\n\n    const inverse = query.inverse\n\n    // Either the parsed or specified `type` is \"all\", or the types must be\n    // equal for a match.\n    const typeMatch = query.type === 'all' || values.type === query.type\n\n    // Quit early when `type` doesn't match, but take \"not\" into account.\n    if ((typeMatch && inverse) || !(typeMatch || inverse)) {\n      return false\n    }\n\n    const expressionsMatch = query.expressions.every((expression) => {\n      const feature = expression.feature\n      const modifier = expression.modifier\n      let expValue = expression.value\n      let value = values[feature]\n\n      // Missing or falsy values don't match.\n      if (!value) {\n        return false\n      }\n\n      switch (feature) {\n        case 'orientation':\n        case 'scan':\n          return value.toLowerCase() === expValue.toLowerCase()\n\n        case 'width':\n        case 'height':\n        case 'device-width':\n        case 'device-height':\n          expValue = toPx(expValue)\n          value = toPx(value)\n          break\n\n        case 'resolution':\n          expValue = toDpi(expValue)\n          value = toDpi(value)\n          break\n\n        case 'aspect-ratio':\n        case 'device-aspect-ratio':\n        case /* Deprecated */ 'device-pixel-ratio':\n          expValue = toDecimal(expValue)\n          value = toDecimal(value)\n          break\n\n        case 'grid':\n        case 'color':\n        case 'color-index':\n        case 'monochrome':\n          expValue = Number.parseInt(expValue, 10) || 1\n          value = Number.parseInt(value, 10) || 0\n          break\n      }\n\n      switch (modifier) {\n        case 'min':\n          return value >= expValue\n        case 'max':\n          return value <= expValue\n        default:\n          return value === expValue\n      }\n    })\n\n    return (expressionsMatch && !inverse) || (!expressionsMatch && inverse)\n  })\n}\n\nexport function parseQuery(mediaQuery: string): ({\n  inverse: boolean\n  type: string\n  expressions: {\n    modifier: any\n    feature: any\n    value: any\n  }[]\n} | null)[] {\n  return mediaQuery.split(',').map((query) => {\n    query = query.trim()\n\n    const captures = query.match(RE_MEDIA_QUERY)\n\n    if (!captures) return null\n\n    const modifier = captures[1]\n    const type = captures[2]\n    const expressionsCapture = captures[3] || ''\n    // Split expressions into a list.\n    const expressions = expressionsCapture.match(/\\([^\\)]+\\)/g) || []\n\n    return {\n      inverse: !!modifier && modifier.toLowerCase() === 'not',\n      type: type ? type.toLowerCase() : 'all',\n      expressions: expressions.map((expression) => {\n        const captures = expression.match(RE_MQ_EXPRESSION)\n        const feature = captures[1].toLowerCase().match(RE_MQ_FEATURE)\n        return {\n          modifier: feature[1],\n          feature: feature[2],\n          value: captures[2],\n        }\n      }),\n    }\n  })\n}\n\n// -- Utilities ----------------------------------------------------------------\n\nfunction toDecimal(ratio) {\n  let decimal = Number(ratio)\n  let numbers\n\n  if (!decimal) {\n    numbers = ratio.match(/^(\\d+)\\s*\\/\\s*(\\d+)$/)\n    decimal = numbers[1] / numbers[2]\n  }\n\n  return decimal\n}\n\nfunction toDpi(resolution: string) {\n  const value = Number.parseFloat(resolution)\n  const units = String(resolution).match(RE_RESOLUTION_UNIT)?.[1]\n\n  switch (units) {\n    case 'dpcm':\n      return value / 2.54\n    case 'dppx':\n      return value * 96\n    default:\n      return value\n  }\n}\n\nfunction toPx(length: string) {\n  const value = Number.parseFloat(length)\n  const units = String(length).match(RE_LENGTH_UNIT)?.[1]\n  switch (units) {\n    case 'em':\n      return value * 16\n    case 'rem':\n      return value * 16\n    case 'cm':\n      return (value * 96) / 2.54\n    case 'mm':\n      return (value * 96) / 2.54 / 10\n    case 'in':\n      return value * 96\n    case 'pt':\n      return value * 72\n    case 'pc':\n      return (value * 72) / 12\n    default:\n      return value\n  }\n}\n"
  ],
  "version": 3
}
"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a, prop, b2[prop]);
    }
  return a;
};
var __spreadProps = (a, b2) => __defProps(a, __getOwnPropDescs(b2));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const React = require("react");
function _interopNamespaceDefault(e2) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e2) {
    for (const k in e2) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e2, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e2[k]
        });
      }
    }
  }
  n.default = e2;
  return Object.freeze(n);
}
function _mergeNamespaces(n, m) {
  for (var i = 0; i < m.length; i++) {
    const e2 = m[i];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k in e2) {
        if (k !== "default" && !(k in n)) {
          const d = Object.getOwnPropertyDescriptor(e2, k);
          if (d) {
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: () => e2[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
const React__namespace = /* @__PURE__ */ _interopNamespaceDefault(React);
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production;
function requireReactJsxRuntime_production() {
  if (hasRequiredReactJsxRuntime_production) return reactJsxRuntime_production;
  hasRequiredReactJsxRuntime_production = 1;
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
  function jsxProd(type, config, maybeKey) {
    var key = null;
    void 0 !== maybeKey && (key = "" + maybeKey);
    void 0 !== config.key && (key = "" + config.key);
    if ("key" in config) {
      maybeKey = {};
      for (var propName in config)
        "key" !== propName && (maybeKey[propName] = config[propName]);
    } else maybeKey = config;
    config = maybeKey.ref;
    return {
      $$typeof: REACT_ELEMENT_TYPE,
      type,
      key,
      ref: void 0 !== config ? config : null,
      props: maybeKey
    };
  }
  reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE;
  reactJsxRuntime_production.jsx = jsxProd;
  reactJsxRuntime_production.jsxs = jsxProd;
  return reactJsxRuntime_production;
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  if (hasRequiredJsxRuntime) return jsxRuntime.exports;
  hasRequiredJsxRuntime = 1;
  {
    jsxRuntime.exports = requireReactJsxRuntime_production();
  }
  return jsxRuntime.exports;
}
var jsxRuntimeExports = requireJsxRuntime();
var pseudoDescriptorsBase = {
  // order of keys here important! in priority order
  hoverStyle: {
    name: "hover",
    priority: 2
  },
  pressStyle: {
    name: "active",
    stateKey: "press",
    priority: 3
  },
  focusVisibleStyle: {
    name: "focus-visible",
    priority: 4,
    stateKey: "focusVisible"
  },
  focusStyle: {
    name: "focus",
    priority: 4
  },
  focusWithinStyle: {
    name: "focus-within",
    priority: 4,
    stateKey: "focusWithin"
  },
  disabledStyle: {
    name: "disabled",
    priority: 5,
    stateKey: "disabled"
  }
}, pseudoPriorities = {
  hover: pseudoDescriptorsBase.hoverStyle.priority,
  press: pseudoDescriptorsBase.pressStyle.priority,
  focus: pseudoDescriptorsBase.focusStyle.priority,
  focusVisible: pseudoDescriptorsBase.focusVisibleStyle.priority,
  focusWithin: pseudoDescriptorsBase.focusWithinStyle.priority,
  disabled: pseudoDescriptorsBase.disabledStyle.priority
}, pseudoDescriptors = __spreadProps(__spreadValues({}, pseudoDescriptorsBase), {
  enterStyle: {
    name: "enter",
    selector: ".t_unmounted",
    priority: 4
  },
  exitStyle: {
    name: "exit",
    priority: 5
  }
}), defaultMediaImportance = Object.keys(pseudoDescriptors).length;
function _type_of$9(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var mergeProps = function(defaultProps, props) {
  var out = {};
  for (var key in defaultProps) key in props || (out[key] = defaultProps[key]);
  for (var key1 in props) mergeProp(out, defaultProps, props, key1);
  return out;
}, mergeComponentProps = function(defaultProps, contextProps, props) {
  var overriddenContext = null;
  if (!defaultProps && !contextProps) return [props, overriddenContext];
  if (defaultProps && !contextProps) return [mergeProps(defaultProps, props), overriddenContext];
  var out = {};
  for (var key in defaultProps) key in props || (out[key] = defaultProps[key]);
  for (var key1 in contextProps) if (!(key1 in props)) {
    var contextValue = contextProps[key1];
    contextValue !== void 0 && (out[key1] = contextValue);
  }
  for (var key2 in props) mergeProp(out, defaultProps, props, key2), contextProps && key2 in contextProps && (overriddenContext || (overriddenContext = {}), overriddenContext[key2] = props[key2]);
  return [out, overriddenContext];
};
function mergeProp(out, defaultProps, props, key) {
  var val = props[key];
  if (defaultProps && key in defaultProps && (key in pseudoDescriptors || key[0] === "$") && val && (typeof val > "u" ? "undefined" : _type_of$9(val)) === "object") {
    var defaultVal = defaultProps[key];
    defaultVal && (typeof defaultVal > "u" ? "undefined" : _type_of$9(defaultVal)) === "object" && (val = mergeProps(defaultVal, val));
  }
  out[key] = val;
}
function _type_of$8(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function objectIdentityKey(obj) {
  var k = "";
  for (var key in obj) {
    k += key;
    var arg = obj[key], type = typeof arg > "u" ? "undefined" : _type_of$8(arg);
    if (!arg || type !== "object" && type !== "function") k += type + arg;
    else if (cache$5.has(arg)) k += cache$5.get(arg);
    else {
      var v = Math.random();
      cache$5.set(arg, v), k += v;
    }
  }
  return k;
}
var cache$5 = /* @__PURE__ */ new WeakMap();
var createReactContext = React["createContext"];
function createStyledContext(defaultValues) {
  var namespace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", OGContext = createReactContext(defaultValues), OGProvider = OGContext.Provider, Context = OGContext, scopedContexts = /* @__PURE__ */ new Map(), LastScopeInNamespace = createReactContext(namespace);
  function getOrCreateScopedContext(scope) {
    var ScopedContext = scopedContexts.get(scope);
    return ScopedContext || (ScopedContext = createReactContext(defaultValues), scopedContexts.set(scope, ScopedContext)), ScopedContext;
  }
  var getNamespacedScope = function(scope) {
    return namespace ? `${namespace}--${scope}` : scope;
  }, Provider = function(param) {
    var _a = param, {
      children,
      scope: scopeIn,
      __disableMergeDefaultValues: __disableMergeDefaultValues
    } = _a, values = __objRest(_a, [
      "children",
      "scope",
      // performance: avoid creating objects
      "__disableMergeDefaultValues"
    ]), scope = getNamespacedScope(scopeIn), next = React.useMemo(function() {
      return __disableMergeDefaultValues ? values : mergeProps(defaultValues, values);
    }, [objectIdentityKey(values)]), ScopedProvider = OGProvider;
    return scope && (ScopedProvider = getOrCreateScopedContext(scope).Provider), /* @__PURE__ */ jsxRuntimeExports.jsx(LastScopeInNamespace.Provider, {
      value: scope,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScopedProvider, {
        value: next,
        children
      })
    });
  }, useStyledContext = function() {
    var scopeIn = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", lastScopeInNamespace = React.useContext(LastScopeInNamespace), scope = namespace ? scopeIn ? getNamespacedScope(scopeIn) : lastScopeInNamespace : scopeIn, context = scope ? getOrCreateScopedContext(scope) : OGContext, value = React.useContext(context);
    return value;
  };
  return Context.Provider = Provider, Context.props = defaultValues, Context.context = OGContext, Context.useStyledContext = useStyledContext, Context;
}
var ComponentContext = createStyledContext({
  disableSSR: void 0,
  inText: false,
  language: null,
  animationDriver: null,
  setParentFocusState: null
}), useConfiguration = function() {
  return React.useContext(ComponentContext);
};
var GroupContext = /* @__PURE__ */ React.createContext(null);
function useCreateShallowSetState(setter, debug) {
  return React.useCallback(function(stateOrGetState) {
    setter(function(prev) {
      var next = typeof stateOrGetState == "function" ? stateOrGetState(prev) : stateOrGetState, update2 = mergeIfNotShallowEqual(prev, next);
      return update2;
    });
  }, [setter, debug]);
}
function mergeIfNotShallowEqual(prev, next) {
  return !prev || !next || isEqualShallow(prev, next) ? prev || next : __spreadValues(__spreadValues({}, prev), next);
}
function isEqualShallow(prev, next) {
  for (var key in next) if (prev[key] !== next[key]) return false;
  return true;
}
const canUseDOM = !!(typeof window < "u" && window.document && window.document.createElement);
var DisableLayoutContextKey = /* @__PURE__ */ React.createContext(""), LayoutMeasurementController = function(param) {
  var {
    disable,
    children
  } = param, id = React.useId();
  return useIsomorphicLayoutEffect(function() {
  }, [disable, id]), /* @__PURE__ */ jsxRuntimeExports.jsx(DisableLayoutContextKey.Provider, {
    value: id,
    children
  });
};
function setOnLayoutStrategy(state) {
}
var avoidUpdates = true, queuedUpdates = /* @__PURE__ */ new Map();
function enable() {
  avoidUpdates && (avoidUpdates = false, queuedUpdates && (queuedUpdates.forEach(function(cb) {
    return cb();
  }), queuedUpdates.clear()));
}
var MOUSE_DOWN = "mousedown", MOUSE_MOVE = "mousemove", MOUSE_UP = "mouseup", MOUSE_CANCEL = "dragstart", TOUCH_START = "touchstart", TOUCH_MOVE = "touchmove", TOUCH_END = "touchend", TOUCH_CANCEL = "touchcancel";
function isStartish(eventType) {
  return eventType === TOUCH_START || eventType === MOUSE_DOWN;
}
function isMoveish(eventType) {
  return eventType === TOUCH_MOVE || eventType === MOUSE_MOVE;
}
function isEndish(eventType) {
  return eventType === TOUCH_END || eventType === MOUSE_UP || isCancelish(eventType);
}
function isCancelish(eventType) {
  return eventType === TOUCH_CANCEL || eventType === MOUSE_CANCEL;
}
function _class_call_check$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor && (descriptor.writable = true), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class$1(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties$1(Constructor.prototype, protoProps), Constructor;
}
function _define_property$1(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: true,
    configurable: true,
    writable: true
  }) : obj[key] = value, obj;
}
var ResponderTouchHistoryStore = /* @__PURE__ */ (function() {
  function ResponderTouchHistoryStore2() {
    _class_call_check$1(this, ResponderTouchHistoryStore2), _define_property$1(this, "_touchHistory", {
      touchBank: [],
      //Array<TouchRecord>
      numberActiveTouches: 0,
      // If there is only one active touch, we remember its location. This prevents
      // us having to loop through all of the touches all the time in the most
      // common case.
      indexOfSingleActiveTouch: -1,
      mostRecentTimeStamp: 0
    });
  }
  return _create_class$1(ResponderTouchHistoryStore2, [{
    key: "recordTouchTrack",
    value: function(topLevelType, nativeEvent) {
      var touchHistory = this._touchHistory;
      if (isMoveish(topLevelType)) nativeEvent.changedTouches.forEach(function(touch) {
        return recordTouchMove(touch, touchHistory);
      });
      else if (isStartish(topLevelType)) nativeEvent.changedTouches.forEach(function(touch) {
        return recordTouchStart(touch, touchHistory);
      }), touchHistory.numberActiveTouches = nativeEvent.touches.length, touchHistory.numberActiveTouches === 1 && (touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier);
      else if (isEndish(topLevelType) && (nativeEvent.changedTouches.forEach(function(touch) {
        return recordTouchEnd(touch, touchHistory);
      }), touchHistory.numberActiveTouches = nativeEvent.touches.length, touchHistory.numberActiveTouches === 1)) {
        for (var {
          touchBank
        } = touchHistory, i = 0; i < touchBank.length; i++) {
          var touchTrackToCheck = touchBank[i];
          if (touchTrackToCheck == null ? void 0 : touchTrackToCheck.touchActive) {
            touchHistory.indexOfSingleActiveTouch = i;
            break;
          }
        }
      }
    }
  }, {
    key: "touchHistory",
    get: function() {
      return this._touchHistory;
    }
  }]), ResponderTouchHistoryStore2;
})(), MAX_TOUCH_BANK = 20;
function timestampForTouch(touch) {
  return touch.timeStamp || touch.timestamp;
}
function createTouchRecord(touch) {
  return {
    touchActive: true,
    startPageX: touch.pageX,
    startPageY: touch.pageY,
    startTimeStamp: timestampForTouch(touch),
    currentPageX: touch.pageX,
    currentPageY: touch.pageY,
    currentTimeStamp: timestampForTouch(touch),
    previousPageX: touch.pageX,
    previousPageY: touch.pageY,
    previousTimeStamp: timestampForTouch(touch)
  };
}
function resetTouchRecord(touchRecord, touch) {
  touchRecord.touchActive = true, touchRecord.startPageX = touch.pageX, touchRecord.startPageY = touch.pageY, touchRecord.startTimeStamp = timestampForTouch(touch), touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchRecord.previousPageX = touch.pageX, touchRecord.previousPageY = touch.pageY, touchRecord.previousTimeStamp = timestampForTouch(touch);
}
function getTouchIdentifier(param) {
  var {
    identifier
  } = param;
  return identifier == null && console.error("Touch object is missing identifier."), identifier;
}
function recordTouchStart(touch, touchHistory) {
  var identifier = getTouchIdentifier(touch), touchRecord = touchHistory.touchBank[identifier];
  touchRecord ? resetTouchRecord(touchRecord, touch) : touchHistory.touchBank[identifier] = createTouchRecord(touch), touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
}
function recordTouchMove(touch, touchHistory) {
  var touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];
  touchRecord ? (touchRecord.touchActive = true, touchRecord.previousPageX = touchRecord.currentPageX, touchRecord.previousPageY = touchRecord.currentPageY, touchRecord.previousTimeStamp = touchRecord.currentTimeStamp, touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchHistory.mostRecentTimeStamp = timestampForTouch(touch)) : console.warn(`Cannot record touch move without a touch start.
`, `Touch Move: ${printTouch(touch)}
`, `Touch Bank: ${printTouchBank(touchHistory)}`);
}
function recordTouchEnd(touch, touchHistory) {
  var touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];
  touchRecord ? (touchRecord.touchActive = false, touchRecord.previousPageX = touchRecord.currentPageX, touchRecord.previousPageY = touchRecord.currentPageY, touchRecord.previousTimeStamp = touchRecord.currentTimeStamp, touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchHistory.mostRecentTimeStamp = timestampForTouch(touch)) : console.warn(`Cannot record touch end without a touch start.
`, `Touch End: ${printTouch(touch)}
`, `Touch Bank: ${printTouchBank(touchHistory)}`);
}
function printTouch(touch) {
  return JSON.stringify({
    identifier: touch.identifier,
    pageX: touch.pageX,
    pageY: touch.pageY,
    timestamp: timestampForTouch(touch)
  });
}
function printTouchBank(touchHistory) {
  var {
    touchBank
  } = touchHistory, printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));
  return touchBank.length > MAX_TOUCH_BANK && (printed += ` (original size: ${touchBank.length})`), printed;
}
new ResponderTouchHistoryStore();
var normalizeColor_1;
var hasRequiredNormalizeColor;
function requireNormalizeColor() {
  if (hasRequiredNormalizeColor) return normalizeColor_1;
  hasRequiredNormalizeColor = 1;
  function normalizeColor2(color) {
    if (typeof color === "number") {
      if (color >>> 0 === color && color >= 0 && color <= 4294967295) {
        return color;
      }
      return null;
    }
    if (typeof color !== "string") {
      return null;
    }
    const matchers = getMatchers();
    let match;
    if (match = matchers.hex6.exec(color)) {
      return parseInt(match[1] + "ff", 16) >>> 0;
    }
    const colorFromKeyword = normalizeKeyword(color);
    if (colorFromKeyword != null) {
      return colorFromKeyword;
    }
    if (match = matchers.rgb.exec(color)) {
      return (parse255(match[1]) << 24 | // r
      parse255(match[2]) << 16 | // g
      parse255(match[3]) << 8 | // b
      255) >>> // a
      0;
    }
    if (match = matchers.rgba.exec(color)) {
      if (match[6] !== void 0) {
        return (parse255(match[6]) << 24 | // r
        parse255(match[7]) << 16 | // g
        parse255(match[8]) << 8 | // b
        parse1(match[9])) >>> // a
        0;
      }
      return (parse255(match[2]) << 24 | // r
      parse255(match[3]) << 16 | // g
      parse255(match[4]) << 8 | // b
      parse1(match[5])) >>> // a
      0;
    }
    if (match = matchers.hex3.exec(color)) {
      return parseInt(
        match[1] + match[1] + // r
        match[2] + match[2] + // g
        match[3] + match[3] + // b
        "ff",
        // a
        16
      ) >>> 0;
    }
    if (match = matchers.hex8.exec(color)) {
      return parseInt(match[1], 16) >>> 0;
    }
    if (match = matchers.hex4.exec(color)) {
      return parseInt(
        match[1] + match[1] + // r
        match[2] + match[2] + // g
        match[3] + match[3] + // b
        match[4] + match[4],
        // a
        16
      ) >>> 0;
    }
    if (match = matchers.hsl.exec(color)) {
      return (hslToRgb(
        parse360(match[1]),
        // h
        parsePercentage(match[2]),
        // s
        parsePercentage(match[3])
        // l
      ) | 255) >>> // a
      0;
    }
    if (match = matchers.hsla.exec(color)) {
      if (match[6] !== void 0) {
        return (hslToRgb(
          parse360(match[6]),
          // h
          parsePercentage(match[7]),
          // s
          parsePercentage(match[8])
          // l
        ) | parse1(match[9])) >>> // a
        0;
      }
      return (hslToRgb(
        parse360(match[2]),
        // h
        parsePercentage(match[3]),
        // s
        parsePercentage(match[4])
        // l
      ) | parse1(match[5])) >>> // a
      0;
    }
    if (match = matchers.hwb.exec(color)) {
      return (hwbToRgb(
        parse360(match[1]),
        // h
        parsePercentage(match[2]),
        // w
        parsePercentage(match[3])
        // b
      ) | 255) >>> // a
      0;
    }
    return null;
  }
  function hue2rgb(p, q, t2) {
    if (t2 < 0) {
      t2 += 1;
    }
    if (t2 > 1) {
      t2 -= 1;
    }
    if (t2 < 1 / 6) {
      return p + (q - p) * 6 * t2;
    }
    if (t2 < 1 / 2) {
      return q;
    }
    if (t2 < 2 / 3) {
      return p + (q - p) * (2 / 3 - t2) * 6;
    }
    return p;
  }
  function hslToRgb(h2, s2, l) {
    const q = l < 0.5 ? l * (1 + s2) : l + s2 - l * s2;
    const p = 2 * l - q;
    const r = hue2rgb(p, q, h2 + 1 / 3);
    const g = hue2rgb(p, q, h2);
    const b2 = hue2rgb(p, q, h2 - 1 / 3);
    return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b2 * 255) << 8;
  }
  function hwbToRgb(h2, w2, b2) {
    if (w2 + b2 >= 1) {
      const gray = Math.round(w2 * 255 / (w2 + b2));
      return gray << 24 | gray << 16 | gray << 8;
    }
    const red = hue2rgb(0, 1, h2 + 1 / 3) * (1 - w2 - b2) + w2;
    const green = hue2rgb(0, 1, h2) * (1 - w2 - b2) + w2;
    const blue = hue2rgb(0, 1, h2 - 1 / 3) * (1 - w2 - b2) + w2;
    return Math.round(red * 255) << 24 | Math.round(green * 255) << 16 | Math.round(blue * 255) << 8;
  }
  const NUMBER = "[-+]?\\d*\\.?\\d+";
  const PERCENTAGE = NUMBER + "%";
  function call(...args) {
    return "\\(\\s*(" + args.join(")\\s*,?\\s*(") + ")\\s*\\)";
  }
  function callWithSlashSeparator(...args) {
    return "\\(\\s*(" + args.slice(0, args.length - 1).join(")\\s*,?\\s*(") + ")\\s*/\\s*(" + args[args.length - 1] + ")\\s*\\)";
  }
  function commaSeparatedCall(...args) {
    return "\\(\\s*(" + args.join(")\\s*,\\s*(") + ")\\s*\\)";
  }
  let cachedMatchers;
  function getMatchers() {
    if (cachedMatchers === void 0) {
      cachedMatchers = {
        rgb: new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER)),
        rgba: new RegExp(
          "rgba(" + commaSeparatedCall(NUMBER, NUMBER, NUMBER, NUMBER) + "|" + callWithSlashSeparator(NUMBER, NUMBER, NUMBER, NUMBER) + ")"
        ),
        hsl: new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE)),
        hsla: new RegExp(
          "hsla(" + commaSeparatedCall(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER) + "|" + callWithSlashSeparator(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER) + ")"
        ),
        hwb: new RegExp("hwb" + call(NUMBER, PERCENTAGE, PERCENTAGE)),
        hex3: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex4: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#([0-9a-fA-F]{6})$/,
        hex8: /^#([0-9a-fA-F]{8})$/
      };
    }
    return cachedMatchers;
  }
  function parse255(str) {
    const int = parseInt(str, 10);
    if (int < 0) {
      return 0;
    }
    if (int > 255) {
      return 255;
    }
    return int;
  }
  function parse360(str) {
    const int = parseFloat(str);
    return (int % 360 + 360) % 360 / 360;
  }
  function parse1(str) {
    const num = parseFloat(str);
    if (num < 0) {
      return 0;
    }
    if (num > 1) {
      return 255;
    }
    return Math.round(num * 255);
  }
  function parsePercentage(str) {
    const int = parseFloat(str);
    if (int < 0) {
      return 0;
    }
    if (int > 100) {
      return 1;
    }
    return int / 100;
  }
  function normalizeKeyword(name) {
    switch (name) {
      case "transparent":
        return 0;
      // http://www.w3.org/TR/css3-color/#svg-color
      case "aliceblue":
        return 4042850303;
      case "antiquewhite":
        return 4209760255;
      case "aqua":
        return 16777215;
      case "aquamarine":
        return 2147472639;
      case "azure":
        return 4043309055;
      case "beige":
        return 4126530815;
      case "bisque":
        return 4293182719;
      case "black":
        return 255;
      case "blanchedalmond":
        return 4293643775;
      case "blue":
        return 65535;
      case "blueviolet":
        return 2318131967;
      case "brown":
        return 2771004159;
      case "burlywood":
        return 3736635391;
      case "burntsienna":
        return 3934150143;
      case "cadetblue":
        return 1604231423;
      case "chartreuse":
        return 2147418367;
      case "chocolate":
        return 3530104575;
      case "coral":
        return 4286533887;
      case "cornflowerblue":
        return 1687547391;
      case "cornsilk":
        return 4294499583;
      case "crimson":
        return 3692313855;
      case "cyan":
        return 16777215;
      case "darkblue":
        return 35839;
      case "darkcyan":
        return 9145343;
      case "darkgoldenrod":
        return 3095792639;
      case "darkgray":
        return 2846468607;
      case "darkgreen":
        return 6553855;
      case "darkgrey":
        return 2846468607;
      case "darkkhaki":
        return 3182914559;
      case "darkmagenta":
        return 2332068863;
      case "darkolivegreen":
        return 1433087999;
      case "darkorange":
        return 4287365375;
      case "darkorchid":
        return 2570243327;
      case "darkred":
        return 2332033279;
      case "darksalmon":
        return 3918953215;
      case "darkseagreen":
        return 2411499519;
      case "darkslateblue":
        return 1211993087;
      case "darkslategray":
        return 793726975;
      case "darkslategrey":
        return 793726975;
      case "darkturquoise":
        return 13554175;
      case "darkviolet":
        return 2483082239;
      case "deeppink":
        return 4279538687;
      case "deepskyblue":
        return 12582911;
      case "dimgray":
        return 1768516095;
      case "dimgrey":
        return 1768516095;
      case "dodgerblue":
        return 512819199;
      case "firebrick":
        return 2988581631;
      case "floralwhite":
        return 4294635775;
      case "forestgreen":
        return 579543807;
      case "fuchsia":
        return 4278255615;
      case "gainsboro":
        return 3705462015;
      case "ghostwhite":
        return 4177068031;
      case "gold":
        return 4292280575;
      case "goldenrod":
        return 3668254975;
      case "gray":
        return 2155905279;
      case "green":
        return 8388863;
      case "greenyellow":
        return 2919182335;
      case "grey":
        return 2155905279;
      case "honeydew":
        return 4043305215;
      case "hotpink":
        return 4285117695;
      case "indianred":
        return 3445382399;
      case "indigo":
        return 1258324735;
      case "ivory":
        return 4294963455;
      case "khaki":
        return 4041641215;
      case "lavender":
        return 3873897215;
      case "lavenderblush":
        return 4293981695;
      case "lawngreen":
        return 2096890111;
      case "lemonchiffon":
        return 4294626815;
      case "lightblue":
        return 2916673279;
      case "lightcoral":
        return 4034953471;
      case "lightcyan":
        return 3774873599;
      case "lightgoldenrodyellow":
        return 4210742015;
      case "lightgray":
        return 3553874943;
      case "lightgreen":
        return 2431553791;
      case "lightgrey":
        return 3553874943;
      case "lightpink":
        return 4290167295;
      case "lightsalmon":
        return 4288707327;
      case "lightseagreen":
        return 548580095;
      case "lightskyblue":
        return 2278488831;
      case "lightslategray":
        return 2005441023;
      case "lightslategrey":
        return 2005441023;
      case "lightsteelblue":
        return 2965692159;
      case "lightyellow":
        return 4294959359;
      case "lime":
        return 16711935;
      case "limegreen":
        return 852308735;
      case "linen":
        return 4210091775;
      case "magenta":
        return 4278255615;
      case "maroon":
        return 2147483903;
      case "mediumaquamarine":
        return 1724754687;
      case "mediumblue":
        return 52735;
      case "mediumorchid":
        return 3126187007;
      case "mediumpurple":
        return 2473647103;
      case "mediumseagreen":
        return 1018393087;
      case "mediumslateblue":
        return 2070474495;
      case "mediumspringgreen":
        return 16423679;
      case "mediumturquoise":
        return 1221709055;
      case "mediumvioletred":
        return 3340076543;
      case "midnightblue":
        return 421097727;
      case "mintcream":
        return 4127193855;
      case "mistyrose":
        return 4293190143;
      case "moccasin":
        return 4293178879;
      case "navajowhite":
        return 4292783615;
      case "navy":
        return 33023;
      case "oldlace":
        return 4260751103;
      case "olive":
        return 2155872511;
      case "olivedrab":
        return 1804477439;
      case "orange":
        return 4289003775;
      case "orangered":
        return 4282712319;
      case "orchid":
        return 3664828159;
      case "palegoldenrod":
        return 4008225535;
      case "palegreen":
        return 2566625535;
      case "paleturquoise":
        return 2951671551;
      case "palevioletred":
        return 3681588223;
      case "papayawhip":
        return 4293907967;
      case "peachpuff":
        return 4292524543;
      case "peru":
        return 3448061951;
      case "pink":
        return 4290825215;
      case "plum":
        return 3718307327;
      case "powderblue":
        return 2967529215;
      case "purple":
        return 2147516671;
      case "rebeccapurple":
        return 1714657791;
      case "red":
        return 4278190335;
      case "rosybrown":
        return 3163525119;
      case "royalblue":
        return 1097458175;
      case "saddlebrown":
        return 2336560127;
      case "salmon":
        return 4202722047;
      case "sandybrown":
        return 4104413439;
      case "seagreen":
        return 780883967;
      case "seashell":
        return 4294307583;
      case "sienna":
        return 2689740287;
      case "silver":
        return 3233857791;
      case "skyblue":
        return 2278484991;
      case "slateblue":
        return 1784335871;
      case "slategray":
        return 1887473919;
      case "slategrey":
        return 1887473919;
      case "snow":
        return 4294638335;
      case "springgreen":
        return 16744447;
      case "steelblue":
        return 1182971135;
      case "tan":
        return 3535047935;
      case "teal":
        return 8421631;
      case "thistle":
        return 3636451583;
      case "tomato":
        return 4284696575;
      case "turquoise":
        return 1088475391;
      case "violet":
        return 4001558271;
      case "wheat":
        return 4125012991;
      case "white":
        return 4294967295;
      case "whitesmoke":
        return 4126537215;
      case "yellow":
        return 4294902015;
      case "yellowgreen":
        return 2597139199;
    }
    return null;
  }
  normalizeColor_1 = normalizeColor2;
  return normalizeColor_1;
}
var normalizeColorExports = requireNormalizeColor();
const index = /* @__PURE__ */ getDefaultExportFromCjs(normalizeColorExports);
const normalizeColor$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index
}, [normalizeColorExports]);
var norm = index || normalizeColor$1, normalizeCSSColor = norm;
function rgba(colorInt) {
  var r = Math.round((colorInt & 4278190080) >>> 24), g = Math.round((colorInt & 16711680) >>> 16), b2 = Math.round((colorInt & 65280) >>> 8), a = ((colorInt & 255) >>> 0) / 255;
  return {
    r,
    g,
    b: b2,
    a
  };
}
const Platform = {
  OS: "web"
};
function invariant(condition, log, ...logVars) {
  if (!condition) throw new Error(log);
}
function getQuery() {
  return canUseDOM && window.matchMedia != null ? window.matchMedia("(prefers-color-scheme: dark)") : null;
}
const query = getQuery(), listenerMapping = /* @__PURE__ */ new WeakMap(), Appearance = {
  getColorScheme() {
    return query && query.matches ? "dark" : "light";
  },
  addChangeListener(listener) {
    let mappedListener = listenerMapping.get(listener);
    mappedListener || (mappedListener = ({
      matches
    }) => {
      listener({
        colorScheme: matches ? "dark" : "light"
      });
    }, listenerMapping.set(listener, mappedListener)), query && query.addListener(mappedListener);
    function remove() {
      const mappedListener2 = listenerMapping.get(listener);
      query && mappedListener2 && query.removeListener(mappedListener2), listenerMapping.delete(listener);
    }
    return {
      remove
    };
  }
};
var reactDom = { exports: {} };
var reactDom_production = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDom_production;
function requireReactDom_production() {
  if (hasRequiredReactDom_production) return reactDom_production;
  hasRequiredReactDom_production = 1;
  var React$1 = React;
  function formatProdErrorMessage(code) {
    var url = "https://react.dev/errors/" + code;
    if (1 < arguments.length) {
      url += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var i = 2; i < arguments.length; i++)
        url += "&args[]=" + encodeURIComponent(arguments[i]);
    }
    return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function noop() {
  }
  var Internals = {
    d: {
      f: noop,
      r: function() {
        throw Error(formatProdErrorMessage(522));
      },
      D: noop,
      C: noop,
      L: noop,
      m: noop,
      X: noop,
      S: noop,
      M: noop
    },
    p: 0,
    findDOMNode: null
  }, REACT_PORTAL_TYPE = Symbol.for("react.portal");
  function createPortal$1(children, containerInfo, implementation) {
    var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return {
      $$typeof: REACT_PORTAL_TYPE,
      key: null == key ? null : "" + key,
      children,
      containerInfo,
      implementation
    };
  }
  var ReactSharedInternals = React$1.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function getCrossOriginStringAs(as, input) {
    if ("font" === as) return "";
    if ("string" === typeof input)
      return "use-credentials" === input ? input : "";
  }
  reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
  reactDom_production.createPortal = function(children, container) {
    var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
      throw Error(formatProdErrorMessage(299));
    return createPortal$1(children, container, null, key);
  };
  reactDom_production.flushSync = function(fn) {
    var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
    try {
      if (ReactSharedInternals.T = null, Internals.p = 2, fn) return fn();
    } finally {
      ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
    }
  };
  reactDom_production.preconnect = function(href, options) {
    "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
  };
  reactDom_production.prefetchDNS = function(href) {
    "string" === typeof href && Internals.d.D(href);
  };
  reactDom_production.preinit = function(href, options) {
    if ("string" === typeof href && options && "string" === typeof options.as) {
      var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
      "style" === as ? Internals.d.S(
        href,
        "string" === typeof options.precedence ? options.precedence : void 0,
        {
          crossOrigin,
          integrity,
          fetchPriority
        }
      ) : "script" === as && Internals.d.X(href, {
        crossOrigin,
        integrity,
        fetchPriority,
        nonce: "string" === typeof options.nonce ? options.nonce : void 0
      });
    }
  };
  reactDom_production.preinitModule = function(href, options) {
    if ("string" === typeof href)
      if ("object" === typeof options && null !== options) {
        if (null == options.as || "script" === options.as) {
          var crossOrigin = getCrossOriginStringAs(
            options.as,
            options.crossOrigin
          );
          Internals.d.M(href, {
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0
          });
        }
      } else null == options && Internals.d.M(href);
  };
  reactDom_production.preload = function(href, options) {
    if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
      var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
      Internals.d.L(href, as, {
        crossOrigin,
        integrity: "string" === typeof options.integrity ? options.integrity : void 0,
        nonce: "string" === typeof options.nonce ? options.nonce : void 0,
        type: "string" === typeof options.type ? options.type : void 0,
        fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
        referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
        imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
        imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
        media: "string" === typeof options.media ? options.media : void 0
      });
    }
  };
  reactDom_production.preloadModule = function(href, options) {
    if ("string" === typeof href)
      if (options) {
        var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
        Internals.d.m(href, {
          as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
          crossOrigin,
          integrity: "string" === typeof options.integrity ? options.integrity : void 0
        });
      } else Internals.d.m(href);
  };
  reactDom_production.requestFormReset = function(form) {
    Internals.d.r(form);
  };
  reactDom_production.unstable_batchedUpdates = function(fn, a) {
    return fn(a);
  };
  reactDom_production.useFormState = function(action, initialState, permalink) {
    return ReactSharedInternals.H.useFormState(action, initialState, permalink);
  };
  reactDom_production.useFormStatus = function() {
    return ReactSharedInternals.H.useHostTransitionStatus();
  };
  reactDom_production.version = "19.1.0";
  return reactDom_production;
}
var hasRequiredReactDom;
function requireReactDom() {
  if (hasRequiredReactDom) return reactDom.exports;
  hasRequiredReactDom = 1;
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    reactDom.exports = requireReactDom_production();
  }
  return reactDom.exports;
}
requireReactDom();
const dimensions = {
  window: {
    fontScale: 1,
    height: 0,
    scale: 1,
    width: 0
  },
  screen: {
    fontScale: 1,
    height: 0,
    scale: 1,
    width: 0
  }
}, listeners$1 = {};
let shouldInit = canUseDOM;
function update() {
  if (!canUseDOM) return;
  const win = window, docEl = win.document.documentElement;
  dimensions.window = {
    fontScale: 1,
    height: docEl.clientHeight,
    scale: win.devicePixelRatio || 1,
    width: docEl.clientWidth
  }, dimensions.screen = {
    fontScale: 1,
    height: win.screen.height,
    scale: win.devicePixelRatio || 1,
    width: win.screen.width
  };
}
function handleResize() {
  update(), Array.isArray(listeners$1.change) && listeners$1.change.forEach((handler) => handler(dimensions));
}
class Dimensions {
  static get(dimension) {
    return shouldInit && (shouldInit = false, update()), invariant(dimensions[dimension], `No dimension set for key ${dimension}`), dimensions[dimension];
  }
  static set(initialDimensions) {
    initialDimensions && (canUseDOM ? invariant(false, "Dimensions cannot be set in the browser") : (initialDimensions.screen != null && (dimensions.screen = initialDimensions.screen), initialDimensions.window != null && (dimensions.window = initialDimensions.window)));
  }
  static addEventListener(type, handler) {
    return listeners$1[type] = listeners$1[type] || [], listeners$1[type].push(handler), {
      remove: () => {
        this.removeEventListener(type, handler);
      }
    };
  }
  static removeEventListener(type, handler) {
    Array.isArray(listeners$1[type]) && (listeners$1[type] = listeners$1[type].filter((_handler) => _handler !== handler));
  }
}
canUseDOM && window.addEventListener("resize", handleResize, false);
React.createContext(null);
var IS_REACT_19 = typeof React.use < "u", isWeb = false, isWindowDefined = false, isServer = false, isClient = false, useIsomorphicLayoutEffect = React.useLayoutEffect, isChrome = false, isWebTouchable = false, isTouchable = true, isAndroid = process.env.TEST_NATIVE_PLATFORM === "android", isIos = process.env.TEST_NATIVE_PLATFORM === "ios", platforms = {
  ios: "ios",
  android: "android"
}, currentPlatform = platforms[Platform.OS] || "native";
var THEME_NAME_SEPARATOR = "_", THEME_CLASSNAME_PREFIX = "t_", FONT_DATA_ATTRIBUTE_NAME = "data-tamagui-font", stackDefaultStyles = {}, webViewFlexCompatStyles = {
  display: "flex",
  alignItems: "stretch",
  flexDirection: "column",
  flexBasis: "auto",
  boxSizing: "border-box",
  position: process.env.TAMAGUI_POSITION_STATIC === "1" ? "static" : "relative",
  minHeight: 0,
  minWidth: 0,
  flexShrink: 0
}, MISSING_THEME_MESSAGE = "Missing theme.";
var conf$1, getSetting = function(key) {
  var _conf_settings_key;
  return (_conf_settings_key = conf$1.settings[key]) !== null && _conf_settings_key !== void 0 ? _conf_settings_key : (
    // @ts-expect-error
    conf$1[key]
  );
}, setConfig = function(next) {
  conf$1 = next;
}, setConfigFont = function(name, font, fontParsed) {
  conf$1.fonts[name] = font, conf$1.fontsParsed[`$${name}`] = fontParsed;
}, getConfig = function() {
  if (!conf$1) throw new Error("Err0");
  return conf$1;
}, tokensMerged;
function setTokens(_) {
  tokensMerged = _;
}
var getTokens = function() {
  var {
    prefixed
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : (
    /**
    * Force either with $ or without $ prefix
    */
    {}
  );
  var {
    tokens,
    tokensParsed
  } = conf$1;
  return prefixed === false ? tokens : prefixed === true ? tokensParsed : tokensMerged;
}, getTokenObject = function(value, group) {
  var _tokensMerged_group, _tokensMerged_, _conf_specificTokens_value;
  return (_conf_specificTokens_value = conf$1.specificTokens[value]) !== null && _conf_specificTokens_value !== void 0 ? _conf_specificTokens_value : group ? (_tokensMerged_group = tokensMerged[group]) === null || _tokensMerged_group === void 0 ? void 0 : _tokensMerged_group[value] : (_tokensMerged_ = tokensMerged[Object.keys(tokensMerged).find(function(cat) {
    return tokensMerged[cat][value];
  }) || ""]) === null || _tokensMerged_ === void 0 ? void 0 : _tokensMerged_[value];
}, getToken = function(value, group) {
  var useVariable = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : isWeb, token = getTokenObject(value, group);
  return useVariable ? token == null ? void 0 : token.variable : token == null ? void 0 : token.val;
}, getTokenValue = function(value, group) {
  if (!(value === "unset" || value === "auto")) return getToken(value, group, false);
}, getThemes = function() {
  return conf$1.themes;
}, configListeners = /* @__PURE__ */ new Set(), onConfiguredOnce = function(cb) {
  conf$1 ? cb(conf$1) : configListeners.add(cb);
}, updateConfig = function(key, value) {
  Object.assign(conf$1[key], value);
}, getFont = function(name) {
  var _Object_entries_find, conf2 = getConfig(), _conf_fontsParsed_name;
  return (_conf_fontsParsed_name = conf2.fontsParsed[name]) !== null && _conf_fontsParsed_name !== void 0 ? _conf_fontsParsed_name : (_Object_entries_find = Object.entries(conf2.fontsParsed).find(function(param) {
    var [k] = param, _conf_fontsParsed_k_family, _conf_fontsParsed_k;
    return ((_conf_fontsParsed_k = conf2.fontsParsed[k]) === null || _conf_fontsParsed_k === void 0 || (_conf_fontsParsed_k_family = _conf_fontsParsed_k.family) === null || _conf_fontsParsed_k_family === void 0 ? void 0 : _conf_fontsParsed_k_family.val) === name;
  })) === null || _Object_entries_find === void 0 ? void 0 : _Object_entries_find[1];
};
function setupDev(conf2) {
}
var cache$4 = /* @__PURE__ */ new Map(), cacheSize = 0, simpleHash = function(strIn) {
  var hashMin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;
  if (cache$4.has(strIn)) return cache$4.get(strIn);
  var str = strIn;
  str[0] === "v" && str.startsWith("var(") && (str = str.slice(6, str.length - 1));
  for (var hash = 0, valids = "", added = 0, len = str.length, i = 0; i < len; i++) {
    if (hashMin !== "strict" && added <= hashMin) {
      var char = str.charCodeAt(i);
      if (char === 46) {
        valids += "--";
        continue;
      }
      if (isValidCSSCharCode(char)) {
        added++, valids += str[i];
        continue;
      }
    }
    hash = hashChar(hash, str[i]);
  }
  var res = valids + (hash ? Math.abs(hash) : "");
  return cacheSize > 1e4 && (cache$4.clear(), cacheSize = 0), cache$4.set(strIn, res), cacheSize++, res;
}, hashChar = function(hash, c) {
  return Math.imul(31, hash) + c.charCodeAt(0) | 0;
};
function isValidCSSCharCode(code) {
  return (
    // A-Z
    code >= 65 && code <= 90 || // a-z
    code >= 97 && code <= 122 || // _
    code === 95 || // -
    code === 45 || // 0-9
    code >= 48 && code <= 57
  );
}
function clamp(value, param) {
  var [min, max] = param;
  return Math.min(max, Math.max(min, value));
}
function _type_of$7(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function composeEventHandlers(og, next) {
  var {
    checkDefaultPrevented = true
  } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  return !og || !next ? next || og || void 0 : function(event) {
    if (og == null ? void 0 : og(event), !event || !(checkDefaultPrevented && (typeof event > "u" ? "undefined" : _type_of$7(event)) === "object" && "defaultPrevented" in event) || // @ts-ignore
    "defaultPrevented" in event && !event.defaultPrevented) return next == null ? void 0 : next(event);
  };
}
var StyleObjectProperty = 0, StyleObjectValue = 1, StyleObjectIdentifier = 2, StyleObjectPseudo = 3, StyleObjectRules = 4;
var ALL_PLATFORMS = ["web", "android", "ios"];
function shouldRenderNativePlatform(nativeProp) {
  if (!nativeProp) return null;
  var userRequestedPlatforms = resolvePlatformNames(nativeProp), _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
  try {
    for (var _iterator = ALL_PLATFORMS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var platform = _step.value;
      if (platform === currentPlatform && userRequestedPlatforms.has(platform)) return platform;
    }
  } catch (err) {
    _didIteratorError = true, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError) throw _iteratorError;
    }
  }
  return null;
}
function resolvePlatformNames(nativeProp) {
  var platforms2 = nativeProp === true ? (
    // all native platforms
    ALL_PLATFORMS
  ) : nativeProp === false ? (
    // no native platform
    []
  ) : Array.isArray(nativeProp) ? nativeProp : [nativeProp], set = new Set(platforms2);
  return set.has("mobile") && (set.add("android"), set.add("ios"), set.delete("mobile")), set;
}
var textColors = {
  color: true,
  textDecorationColor: true,
  textShadowColor: true
}, tokenCategories = {
  radius: {
    borderRadius: true,
    borderTopLeftRadius: true,
    borderTopRightRadius: true,
    borderBottomLeftRadius: true,
    borderBottomRightRadius: true,
    // logical
    borderStartStartRadius: true,
    borderStartEndRadius: true,
    borderEndStartRadius: true,
    borderEndEndRadius: true
  },
  size: {
    width: true,
    height: true,
    minWidth: true,
    minHeight: true,
    maxWidth: true,
    maxHeight: true,
    blockSize: true,
    minBlockSize: true,
    maxBlockSize: true,
    inlineSize: true,
    minInlineSize: true,
    maxInlineSize: true
  },
  zIndex: {
    zIndex: true
  },
  color: __spreadValues({
    backgroundColor: true,
    borderColor: true,
    borderBlockStartColor: true,
    borderBlockEndColor: true,
    borderBlockColor: true,
    borderBottomColor: true,
    borderInlineColor: true,
    borderInlineStartColor: true,
    borderInlineEndColor: true,
    borderTopColor: true,
    borderLeftColor: true,
    borderRightColor: true,
    borderEndColor: true,
    borderStartColor: true,
    shadowColor: true
  }, textColors)
}, stylePropsUnitless = {
  WebkitLineClamp: true,
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexOrder: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  fontWeight: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowGap: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnGap: true,
  gridColumnStart: true,
  gridTemplateColumns: true,
  gridTemplateAreas: true,
  lineClamp: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  scale: true,
  scaleX: true,
  scaleY: true,
  scaleZ: true,
  shadowOpacity: true
}, stylePropsTransform = {
  x: true,
  y: true,
  scale: true,
  perspective: true,
  scaleX: true,
  scaleY: true,
  skewX: true,
  skewY: true,
  matrix: true,
  rotate: true,
  rotateY: true,
  rotateX: true,
  rotateZ: true
}, stylePropsView = __spreadValues(__spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
  backfaceVisibility: true,
  borderBottomEndRadius: true,
  borderBottomStartRadius: true,
  borderBottomWidth: true,
  borderLeftWidth: true,
  borderRightWidth: true,
  borderBlockWidth: true,
  borderBlockEndWidth: true,
  borderBlockStartWidth: true,
  borderInlineWidth: true,
  borderInlineEndWidth: true,
  borderInlineStartWidth: true,
  borderStyle: true,
  borderBlockStyle: true,
  borderBlockEndStyle: true,
  borderBlockStartStyle: true,
  borderInlineStyle: true,
  borderInlineEndStyle: true,
  borderInlineStartStyle: true,
  borderTopEndRadius: true,
  borderTopStartRadius: true,
  borderTopWidth: true,
  borderWidth: true,
  transform: true,
  transformOrigin: true,
  alignContent: true,
  alignItems: true,
  alignSelf: true,
  borderEndWidth: true,
  borderStartWidth: true,
  bottom: true,
  display: true,
  end: true,
  flexBasis: true,
  flexDirection: true,
  flexWrap: true,
  gap: true,
  columnGap: true,
  rowGap: true,
  justifyContent: true,
  left: true,
  margin: true,
  marginBlock: true,
  marginBlockEnd: true,
  marginBlockStart: true,
  marginInline: true,
  marginInlineStart: true,
  marginInlineEnd: true,
  marginBottom: true,
  marginEnd: true,
  marginHorizontal: true,
  marginLeft: true,
  marginRight: true,
  marginStart: true,
  marginTop: true,
  marginVertical: true,
  overflow: true,
  padding: true,
  paddingBottom: true,
  paddingInline: true,
  paddingBlock: true,
  paddingBlockStart: true,
  paddingInlineEnd: true,
  paddingInlineStart: true,
  paddingEnd: true,
  paddingHorizontal: true,
  paddingLeft: true,
  paddingRight: true,
  paddingStart: true,
  paddingTop: true,
  paddingVertical: true,
  position: true,
  right: true,
  start: true,
  top: true,
  inset: true,
  insetBlock: true,
  insetBlockEnd: true,
  insetBlockStart: true,
  insetInline: true,
  insetInlineEnd: true,
  insetInlineStart: true,
  direction: true,
  shadowOffset: true,
  shadowRadius: true
}, tokenCategories.color), tokenCategories.radius), tokenCategories.size), tokenCategories.radius), stylePropsTransform), stylePropsUnitless), {
  boxShadow: true,
  filter: true
}), isAndroid ? {
  elevationAndroid: true
} : {}), stylePropsFont = {
  fontFamily: true,
  fontSize: true,
  fontStyle: true,
  fontWeight: true,
  fontVariant: true,
  letterSpacing: true,
  lineHeight: true,
  textTransform: true
}, stylePropsTextOnly = __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, stylePropsFont), {
  textAlign: true,
  textDecorationLine: true,
  textDecorationStyle: true
}), textColors), {
  textShadowOffset: true,
  textShadowRadius: true,
  userSelect: true,
  selectable: true,
  verticalAlign: true
}), stylePropsText = __spreadValues(__spreadValues({}, stylePropsView), stylePropsTextOnly), stylePropsAll = stylePropsText, validPseudoKeys = {
  enterStyle: true,
  exitStyle: true,
  hoverStyle: true,
  pressStyle: true,
  focusStyle: true,
  disabledStyle: true,
  focusWithinStyle: true
}, validStyles = stylePropsView;
function _type_of$6(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var Decorated = Symbol(), withStaticProperties = function(component, staticProps) {
  var next = (function() {
    if (component[Decorated]) {
      var _ = /* @__PURE__ */ React.forwardRef(function(props, ref) {
        return /* @__PURE__ */ React.createElement(component, __spreadProps(__spreadValues({}, props), {
          ref
        }));
      });
      for (var key in component) {
        var v = component[key];
        _[key] = v && (typeof v > "u" ? "undefined" : _type_of$6(v)) === "object" ? __spreadValues({}, v) : v;
      }
    }
    return component;
  })();
  return Object.assign(next, staticProps), next[Decorated] = true, next;
};
function _type_of$5(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function constructCSSVariableName(name) {
  return `var(--${process.env.TAMAGUI_CSS_VARIABLE_PREFIX || ""}${name})`;
}
var createVariable = function(props) {
  var skipHash = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  if (!skipHash && isVariable(props)) return props;
  var {
    key,
    name,
    val
  } = props;
  return {
    isVar: true,
    key,
    name: skipHash ? name : simpleHash(name, 40),
    val,
    variable: ""
  };
};
function variableToString(vrble) {
  return isVariable(vrble) ? `${vrble.val}` : `${vrble || ""}`;
}
function isVariable(v) {
  return v && (typeof v > "u" ? "undefined" : _type_of$5(v)) === "object" && "isVar" in v;
}
function getVariable(nameOrVariable) {
  var group = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "size", _tokens_group;
  if (nameOrVariable == null ? void 0 : nameOrVariable.dynamic) return nameOrVariable;
  if (setDidGetVariableValue(true), isVariable(nameOrVariable)) return variableToString(nameOrVariable);
  var tokens = getConfig().tokensParsed, _tokens_group_nameOrVariable;
  return variableToString((_tokens_group_nameOrVariable = (_tokens_group = tokens[group]) === null || _tokens_group === void 0 ? void 0 : _tokens_group[nameOrVariable]) !== null && _tokens_group_nameOrVariable !== void 0 ? _tokens_group_nameOrVariable : nameOrVariable);
}
var accessed = false, setDidGetVariableValue = function(val) {
  return accessed = val;
}, didGetVariableValue = function() {
  return accessed;
};
function getVariableValue(v, group) {
  if (isVariable(v)) return setDidGetVariableValue(true), v.val;
  if (group) {
    var _tokens_group, tokens = getConfig().tokensParsed, token = (_tokens_group = tokens[group]) === null || _tokens_group === void 0 ? void 0 : _tokens_group[v];
    if (token) return setDidGetVariableValue(true), token.val;
  }
  return v;
}
function getVariableName(v) {
  return isVariable(v) ? v.name : v;
}
function getVariableVariable(v) {
  return isVariable(v) ? v.variable : v;
}
var createCSSVariable = function(nameProp) {
  var includeVar = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var name = simpleHash(nameProp, 60);
  return includeVar ? constructCSSVariableName(name) : name;
};
function px(value) {
  return {
    val: value,
    needsPx: true
  };
}
function getOppositeScheme(scheme) {
  return scheme === "dark" ? "light" : "dark";
}
function getDynamicVal(param) {
  var {
    scheme,
    val,
    oppositeVal
  } = param, oppositeScheme = getOppositeScheme(scheme);
  return {
    dynamic: {
      [scheme]: val,
      [oppositeScheme]: oppositeVal
    }
  };
}
function extractValueFromDynamic(val, scheme) {
  return (val == null ? void 0 : val.dynamic) ? val.dynamic[scheme] : val;
}
var ThemeStateContext = React.createContext(""), allListeners = /* @__PURE__ */ new Map(), listenersByParent = {}, HasRenderedOnce = /* @__PURE__ */ new WeakMap(), HadTheme = /* @__PURE__ */ new WeakMap(), PendingUpdate = /* @__PURE__ */ new Map(), states = /* @__PURE__ */ new Map(), localStates = /* @__PURE__ */ new Map(), shouldForce = false, forceUpdateThemes = function() {
  shouldForce = true, allListeners.forEach(function(cb) {
    return cb();
  });
}, getThemeState = function(id) {
  return states.get(id);
}, themes = null, rootThemeState = null, getRootThemeState = function() {
  return rootThemeState;
}, useThemeState = function(props) {
  var isRoot = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, keys = arguments.length > 2 ? arguments[2] : void 0, {
    disable
  } = props, parentId = React.useContext(ThemeStateContext);
  if (!parentId && !isRoot) throw new Error(MISSING_THEME_MESSAGE);
  if (disable) return states.get(parentId) || {
    id: "",
    name: "light",
    theme: getConfig().themes.light,
    inverses: 0
  };
  var id = React.useId(), subscribe2 = React.useCallback(function(cb) {
    var _listenersByParent, _parentId;
    return (_listenersByParent = listenersByParent)[_parentId = parentId] || (_listenersByParent[_parentId] = /* @__PURE__ */ new Set()), listenersByParent[parentId].add(id), allListeners.set(id, function() {
      PendingUpdate.set(id, shouldForce ? "force" : true), cb();
    }), function() {
      allListeners.delete(id), listenersByParent[parentId].delete(id), localStates.delete(id), states.delete(id), PendingUpdate.delete(id);
    };
  }, [id, parentId]), propsKey = getPropsKey(props), getSnapshot = function() {
    var _keys_current, _props_needsUpdate, local = localStates.get(id), needsUpdate = props.passThrough ? false : isRoot || props.name === "light" || props.name === "dark" || props.name === null ? true : HasRenderedOnce.get(keys) ? !(keys == null || (_keys_current = keys.current) === null || _keys_current === void 0) && _keys_current.size ? true : (_props_needsUpdate = props.needsUpdate) === null || _props_needsUpdate === void 0 ? void 0 : _props_needsUpdate.call(props) : true, [rerender, next] = getNextState(local, props, propsKey, isRoot, id, parentId, needsUpdate, PendingUpdate.get(id));
    return PendingUpdate.delete(id), (!local || rerender) && (local = __spreadValues({}, next), localStates.set(id, local)), Object.assign(local, next), local.id = id, states.set(id, next), local;
  };
  var state = React.useSyncExternalStore(subscribe2, getSnapshot, getSnapshot);
  return useIsomorphicLayoutEffect(function() {
    if (!HasRenderedOnce.get(keys)) {
      HasRenderedOnce.set(keys, true);
      return;
    }
    if (!propsKey) {
      HadTheme.get(keys) && scheduleUpdate(id), HadTheme.set(keys, false);
      return;
    }
    scheduleUpdate(id), HadTheme.set(keys, true);
  }, [keys, propsKey]), state;
}, getNextState = function(lastState, props, propsKey) {
  var isRoot = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, id = arguments.length > 4 ? arguments[4] : void 0, parentId = arguments.length > 5 ? arguments[5] : void 0, needsUpdate = arguments.length > 6 ? arguments[6] : void 0, pendingUpdate = arguments.length > 7 ? arguments[7] : void 0, {
    debug
  } = props, parentState = states.get(parentId);
  if (props.passThrough) return [false, lastState || parentState || {
    name: ""
  }];
  themes || (themes = getConfig().themes);
  var name = !propsKey && (!lastState || !(lastState == null ? void 0 : lastState.isNew)) ? null : getNewThemeName(parentState == null ? void 0 : parentState.name, props, pendingUpdate === "force" ? true : !!needsUpdate), isSameAsParent = parentState && (!name || name === parentState.name), shouldRerender = !!(needsUpdate && (pendingUpdate || (lastState == null ? void 0 : lastState.name) !== (parentState == null ? void 0 : parentState.name)));
  if (isSameAsParent) return [shouldRerender, __spreadProps(__spreadValues({}, parentState), {
    isNew: false
  })];
  if (!name) {
    var next = lastState != null ? lastState : parentState;
    if (!next) throw new Error(MISSING_THEME_MESSAGE);
    if (shouldRerender) {
      var updated = __spreadValues({}, parentState || lastState);
      return [true, updated];
    }
    return [false, next];
  }
  var scheme = getScheme(name), _parentState_inverses, parentInverses = (_parentState_inverses = parentState == null ? void 0 : parentState.inverses) !== null && _parentState_inverses !== void 0 ? _parentState_inverses : 0, isInverse = parentState && scheme !== parentState.scheme, inverses = parentInverses + (isInverse ? 1 : 0), nextState = {
    id,
    name,
    theme: themes[name],
    scheme,
    parentId,
    parentName: parentState == null ? void 0 : parentState.name,
    inverses,
    isInverse,
    isNew: true
  };
  if (isRoot && (rootThemeState = nextState), pendingUpdate !== "force" && lastState && lastState.name === name) return [false, nextState];
  var shouldAvoidRerender = pendingUpdate !== "force" && lastState && !needsUpdate && nextState.name === lastState.name;
  return shouldAvoidRerender ? [false, nextState] : [true, nextState];
};
function scheduleUpdate(id) {
  for (var queue = [id], visited = /* @__PURE__ */ new Set(); queue.length; ) {
    var parent = queue.shift(), children = listenersByParent[parent];
    if (children) {
      var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
      try {
        for (var _iterator = children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var childId = _step.value;
          visited.has(childId) || (visited.add(childId), queue.push(childId));
        }
      } catch (err) {
        _didIteratorError = true, _iteratorError = err;
      } finally {
        try {
          !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError) throw _iteratorError;
        }
      }
    }
  }
  visited.forEach(function(childId2) {
    var cb = allListeners.get(childId2);
    cb == null ? void 0 : cb();
  });
}
var validSchemes = {
  light: "light",
  dark: "dark"
};
function getScheme(name) {
  return validSchemes[name.split("_")[0]];
}
function getNewThemeName() {
  var parentName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", {
    name,
    reset,
    componentName,
    inverse,
    debug
  } = arguments.length > 1 ? arguments[1] : void 0, forceUpdate = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (name && reset) throw new Error("004");
  var {
    themes: themes2
  } = getConfig();
  if (reset) {
    var isSchemeOnly = parentName === "light" || parentName === "dark";
    if (isSchemeOnly) return parentName === "light" ? "dark" : "light";
    var lastPartIndex = parentName.lastIndexOf("_"), name1 = lastPartIndex <= 0 ? parentName : parentName.slice(lastPartIndex), scheme = parentName.slice(0, lastPartIndex), result = themes2[name1] ? name1 : scheme;
    return result;
  }
  var parentParts = parentName.split("_"), lastName = parentParts[parentParts.length - 1];
  lastName && lastName[0].toLowerCase() !== lastName[0] && parentParts.pop();
  var subNames = [name && componentName ? `${name}_${componentName}` : void 0, name, componentName].filter(Boolean), found = null;
  if (name) {
    var nameHasScheme = getScheme(name);
    if (nameHasScheme) {
      var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
      try {
        for (var _iterator = subNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var subName = _step.value;
          if (subName in themes2) {
            found = subName;
            break;
          }
        }
      } catch (err) {
        _didIteratorError = true, _iteratorError = err;
      } finally {
        try {
          !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError) throw _iteratorError;
        }
      }
    }
    if (!found && !nameHasScheme) {
      var parentScheme = getScheme(parentName);
      if (parentScheme) {
        var parentBase = parentParts.join("_"), withScheme = [componentName ? `${parentBase}_${name}_${componentName}` : void 0, `${parentBase}_${name}`, componentName ? `${parentScheme}_${name}_${componentName}` : void 0, `${parentScheme}_${name}`].filter(Boolean), _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = void 0;
        try {
          for (var _iterator1 = withScheme[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
            var potential = _step1.value;
            if (potential in themes2) {
              found = potential;
              break;
            }
          }
        } catch (err) {
          _didIteratorError1 = true, _iteratorError1 = err;
        } finally {
          try {
            !_iteratorNormalCompletion1 && _iterator1.return != null && _iterator1.return();
          } finally {
            if (_didIteratorError1) throw _iteratorError1;
          }
        }
      }
    }
  }
  if (!found) if (!name && componentName) {
    var potential1 = `${parentParts.join("_")}_${componentName}`;
    potential1 in themes2 && (found = potential1);
  } else for (var max = parentParts.length, i = 0; i <= max; i++) {
    var base = (i === 0 ? parentParts : parentParts.slice(0, -i)).join("_"), _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = void 0;
    try {
      for (var _iterator2 = subNames[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var subName1 = _step2.value, potential2 = base ? `${base}_${subName1}` : subName1;
        if (potential2 in themes2) {
          found = potential2;
          break;
        }
      }
    } catch (err) {
      _didIteratorError2 = true, _iteratorError2 = err;
    } finally {
      try {
        !_iteratorNormalCompletion2 && _iterator2.return != null && _iterator2.return();
      } finally {
        if (_didIteratorError2) throw _iteratorError2;
      }
    }
    if (found) break;
  }
  if (inverse) {
    found || (found = parentName);
    var scheme1 = found.split("_")[0];
    found = found.replace(new RegExp(`^${scheme1}`), scheme1 === "light" ? "dark" : "light");
  }
  return !forceUpdate && found === parentName && // if its a scheme only sub-theme, we always consider it "new" because it likely inverses
  // and we want to avoid reparenting
  !validSchemes[found] ? null : found;
}
var getPropsKey = function(param) {
  var {
    name,
    reset,
    inverse,
    forceClassName,
    componentName
  } = param;
  return `${name || ""}${inverse || ""}${reset || ""}${forceClassName || ""}${componentName || ""}`;
}, hasThemeUpdatingProps = function(props) {
  return "inverse" in props || "name" in props || "reset" in props || "forceClassName" in props;
};
function doesRootSchemeMatchSystem() {
  var _getRootThemeState;
  return ((_getRootThemeState = getRootThemeState()) === null || _getRootThemeState === void 0 ? void 0 : _getRootThemeState.scheme) === Appearance.getColorScheme();
}
var cache$3 = /* @__PURE__ */ new Map(), curKeys, curProps, curState, emptyObject = {};
function getThemeProxied(_props, _state, _keys) {
  if (!(_state == null ? void 0 : _state.theme)) return emptyObject;
  if (curKeys = _keys, curProps = _props, curState = _state, cache$3.has(curState.theme)) {
    var proxied = cache$3.get(curState.theme);
    return proxied;
  }
  var config = getConfig();
  function track(key) {
    curKeys && (curKeys.current || (curKeys.current = /* @__PURE__ */ new Set()), curKeys.current.add(key), false);
  }
  var proxied1 = Object.fromEntries(Object.entries(_state.theme).flatMap(function(param) {
    var [key, value] = param, proxied2 = __spreadProps(__spreadValues({}, value), {
      get val() {
        return globalThis.tamaguiAvoidTracking || track(key), value.val;
      },
      get(platform) {
        if (curState) {
          var outVal = getVariable(value), {
            name,
            scheme,
            inverses
          } = curState, shouldOptimize = scheme && platform !== "web" && isIos && !curProps.deopt && getSetting("fastSchemeChange") && inverses === 0 && doesRootSchemeMatchSystem();
          if (shouldOptimize) {
            var _config_themes_name, _config_themes_oppositeName, oppositeScheme = scheme === "dark" ? "light" : "dark", oppositeName = name.replace(scheme, oppositeScheme), color = getVariable((_config_themes_name = config.themes[name]) === null || _config_themes_name === void 0 ? void 0 : _config_themes_name[key]), oppositeColor = getVariable((_config_themes_oppositeName = config.themes[oppositeName]) === null || _config_themes_oppositeName === void 0 ? void 0 : _config_themes_oppositeName[key]), dynamicVal = getDynamicVal({
              scheme,
              val: color,
              oppositeVal: oppositeColor
            });
            return dynamicVal;
          }
          return track(key), outVal;
        }
      }
    });
    return [[key, proxied2], [`$${key}`, proxied2]];
  }));
  return cache$3.set(_state.theme, proxied1), proxied1;
}
var useTheme = function() {
  var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, [theme] = useThemeWithState(props), res = theme;
  return res;
}, useThemeWithState = function(props) {
  var isRoot = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, keys = React.useRef(null), themeState = useThemeState(props, isRoot, keys);
  var themeProxied = props.passThrough ? {} : getThemeProxied(props, themeState, keys);
  return [themeProxied, themeState];
};
var _withStableStyle = function(Component, styleProvider) {
  return /* @__PURE__ */ React.forwardRef(function(props, ref) {
    var _a = props, {
      _expressions = []
    } = _a, rest = __objRest(_a, [
      "_expressions"
    ]), theme = useTheme();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Component, __spreadValues({
      ref,
      style: styleProvider(theme, _expressions)
    }, rest));
  });
};
function setRef(ref, value) {
  typeof ref == "function" ? ref(value) : ref && (ref.current = value);
}
function composeRefs() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) refs[_key] = arguments[_key];
  return function(node) {
    return refs.forEach(function(ref) {
      return setRef(ref, node);
    });
  };
}
function useComposedRefs() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) refs[_key] = arguments[_key];
  return React__namespace.useCallback(composeRefs(...refs), refs);
}
var defaultComponentState = {
  hover: false,
  press: false,
  pressIn: false,
  focus: false,
  focusVisible: false,
  focusWithin: false,
  unmounted: true,
  disabled: false
}, defaultComponentStateMounted = __spreadProps(__spreadValues({}, defaultComponentState), {
  unmounted: false
}), defaultComponentStateShouldEnter = __spreadProps(__spreadValues({}, defaultComponentState), {
  unmounted: "should-enter"
});
var matchMediaImpl = matchMediaFallback, matchMedia$1 = function() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
  return matchMediaImpl(...args);
};
function matchMediaFallback(query2) {
  return !process.env.IS_STATIC && false, {
    match: function(a, b2) {
      return false;
    },
    addListener: function() {
    },
    removeListener: function() {
    },
    matches: false
  };
}
function setupMatchMedia(_) {
  matchMediaImpl = _, globalThis.matchMedia = _;
}
exports.mediaState = // development only safeguard
{};
var mediaQueryConfig = {}, getMedia = function() {
  return exports.mediaState;
}, mediaKeys = /* @__PURE__ */ new Set(), mediaKeyRegex = /\$(platform|theme|group)-/, getMediaKey = function(key) {
  if (key[0] !== "$") return false;
  if (mediaKeys.has(key)) return true;
  var match = key.match(mediaKeyRegex);
  return match ? match[1] : false;
}, initState, mediaKeysOrdered, getMediaKeyImportance = function(key) {
  var conf2 = getConfig();
  return conf2.settings.mediaPropOrder ? defaultMediaImportance : mediaKeysOrdered.indexOf(key) + 100;
}, dispose = /* @__PURE__ */ new Set(), mediaVersion = 0, configureMedia = function(config) {
  var {
    media
  } = config, mediaQueryDefaultActive = getSetting("mediaQueryDefaultActive");
  if (media) {
    mediaVersion++;
    for (var key in media) exports.mediaState[key] = (mediaQueryDefaultActive == null ? void 0 : mediaQueryDefaultActive[key]) || false, mediaKeys.add(`$${key}`);
    Object.assign(mediaQueryConfig, media), initState = __spreadValues({}, exports.mediaState), mediaKeysOrdered = Object.keys(media), setupMediaListeners();
  }
};
function unlisten() {
  dispose.forEach(function(cb) {
    return cb();
  }), dispose.clear();
}
var setupVersion = -1;
function setupMediaListeners() {
  var _loop2 = function(key2) {
    var str = mediaObjectToString(mediaQueryConfig[key2]), getMatch = function() {
      return matchMedia$1(str);
    }, match = getMatch();
    if (!match) throw new Error(" No match");
    match.addListener(update2), dispose.add(function() {
      match.removeListener(update2);
    });
    function update2() {
      var next = !!getMatch().matches;
      next !== exports.mediaState[key2] && (exports.mediaState = __spreadProps(__spreadValues({}, exports.mediaState), {
        [key2]: next
      }), updateMediaListeners());
    }
    update2();
  };
  if (!process.env.IS_STATIC && setupVersion !== mediaVersion) {
    setupVersion = mediaVersion, unlisten();
    for (var key in mediaQueryConfig) _loop2(key);
  }
}
var listeners = /* @__PURE__ */ new Set();
function updateMediaListeners() {
  listeners.forEach(function(cb) {
    return cb(exports.mediaState);
  });
}
var States = /* @__PURE__ */ new WeakMap();
function setMediaShouldUpdate(ref, enabled, keys) {
  var cur = States.get(ref);
  (!cur || cur.enabled !== enabled || keys) && States.set(ref, __spreadProps(__spreadValues({}, cur), {
    enabled,
    keys
  }));
}
function subscribe(subscriber) {
  return listeners.add(subscriber), function() {
    listeners.delete(subscriber);
  };
}
function useMedia(componentContext, debug) {
  var componentState = componentContext ? States.get(componentContext) : null, internalRef = React.useRef(null);
  internalRef.current || (internalRef.current = {
    keys: /* @__PURE__ */ new Set(),
    lastState: exports.mediaState
  }), internalRef.current.pendingState && (internalRef.current.lastState = internalRef.current.pendingState, internalRef.current.pendingState = void 0);
  var {
    keys
  } = internalRef.current;
  keys.size && keys.clear();
  var state = React.useSyncExternalStore(subscribe, function() {
    var curKeys2 = (componentState == null ? void 0 : componentState.keys) || keys, {
      lastState,
      pendingState
    } = internalRef.current;
    if (!curKeys2.size) return lastState;
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
    try {
      for (var _iterator = curKeys2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var key = _step.value;
        if (exports.mediaState[key] !== (pendingState || lastState)[key]) return false, (componentContext == null ? void 0 : componentContext.mediaEmit) ? (componentContext.mediaEmit(exports.mediaState), internalRef.current.pendingState = exports.mediaState, lastState) : (internalRef.current.lastState = exports.mediaState, exports.mediaState);
      }
    } catch (err) {
      _didIteratorError = true, _iteratorError = err;
    } finally {
      try {
        !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
      } finally {
        if (_didIteratorError) throw _iteratorError;
      }
    }
    return lastState;
  }, getServerSnapshot);
  return new Proxy(state, {
    get(_, key) {
      return !disableMediaTouch && typeof key == "string" && keys.add(key), Reflect.get(state, key);
    }
  });
}
var getServerSnapshot = function() {
  return initState;
}, disableMediaTouch = false;
function _disableMediaTouch(val) {
  disableMediaTouch = val;
}
function getMediaState(mediaGroups, layout) {
  disableMediaTouch = true;
  var res;
  try {
    res = Object.fromEntries([...mediaGroups].map(function(mediaKey) {
      return [mediaKey, mediaKeyMatch(mediaKey, layout)];
    }));
  } finally {
    disableMediaTouch = false;
  }
  return res;
}
var getMediaImportanceIfMoreImportant = function(mediaKey, key, styleState, isSizeMedia) {
  var importance = isSizeMedia && !getSetting("mediaPropOrder") ? getMediaKeyImportance(mediaKey) : defaultMediaImportance, usedKeys = styleState.usedKeys;
  return !usedKeys[key] || importance > usedKeys[key] ? importance : null;
};
function camelToHyphen(str) {
  return str.replace(/[A-Z]/g, function(m) {
    return `-${m.toLowerCase()}`;
  }).toLowerCase();
}
var cache$2 = /* @__PURE__ */ new WeakMap();
function mediaObjectToString(query2, key) {
  if (typeof query2 == "string") return query2;
  if (cache$2.has(query2)) return cache$2.get(query2);
  var res = Object.entries(query2).map(function(param) {
    var [feature, value] = param;
    return feature = camelToHyphen(feature), typeof value == "string" ? `(${feature}: ${value})` : (typeof value == "number" && /[height|width]$/.test(feature) && (value = `${value}px`), `(${feature}: ${value})`);
  }).join(" and ");
  return cache$2.set(query2, res), res;
}
function mediaKeyMatch(key, dimensions2) {
  var mediaQueries = mediaQueryConfig[key], result = Object.keys(mediaQueries).every(function(query2) {
    var expectedVal = +mediaQueries[query2], isMax = query2.startsWith("max"), isWidth = query2.endsWith("Width"), givenVal = dimensions2[isWidth ? "width" : "height"];
    return isMax ? givenVal < expectedVal : givenVal > expectedVal;
  });
  return result;
}
function getGroupPropParts(groupProp) {
  var mediaQueries = getMedia(), [_, name, part3, part4] = groupProp.split("-"), pseudo, media = part3 in mediaQueries ? part3 : void 0;
  return media ? pseudo = part4 : pseudo = part3, {
    name,
    pseudo,
    media
  };
}
var MEDIA_SEP = "_", prefixes = null, selectors = null, groupPseudoToPseudoCSSMap = {
  press: "active",
  focusVisible: "focus-visible",
  focusWithin: "focus-within"
}, specificities = new Array(5).fill(0).map(function(_, i) {
  return new Array(i).fill(":root").join("");
});
function getThemeOrGroupSelector(name, styleInner, isGroup, groupParts) {
  var isTheme = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false, precedenceImportancePrefix = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "", selectorStart = styleInner.lastIndexOf(":root") + 5, selectorEnd = styleInner.lastIndexOf("{"), selector = styleInner.slice(selectorStart, selectorEnd), precedenceSpace = getSetting("themeClassNameOnRoot") && isTheme ? "" : " ", pseudoSelectorName = groupParts.pseudo ? groupPseudoToPseudoCSSMap[groupParts.pseudo] || groupParts.pseudo : void 0, pseudoSelector = pseudoSelectorName ? `:${pseudoSelectorName}` : "", presedencePrefix = `:root${precedenceImportancePrefix}${precedenceSpace}`, mediaSelector = `.t_${isGroup ? "group_" : ""}${name}${pseudoSelector}`;
  return [selector, `${presedencePrefix}${mediaSelector} ${selector.replaceAll(":root", "")}`];
}
var createMediaStyle = function(styleObject, mediaKeyIn, mediaQueries, type, negate, priority) {
  var [propertyIn, , identifier, pseudoIn, rules] = styleObject, property = propertyIn, enableMediaPropOrder = getSetting("mediaPropOrder"), isTheme = type === "theme", isPlatform = type === "platform", isGroup = type === "group", isNonWindowMedia = isTheme || isPlatform || isGroup, negKey = negate ? "0" : "", ogPrefix = identifier.slice(0, identifier.indexOf("-") + 1), id = `${ogPrefix}${MEDIA_SEP}${mediaKeyIn.replace("-", "")}${negKey}${MEDIA_SEP}`, styleRule = "", groupPriority = "", groupMediaKey, containerName, nextIdentifier = identifier.replace(ogPrefix, id), styleInner = rules.map(function(rule) {
    return rule.replace(identifier, nextIdentifier);
  }).join(";"), isHover = false;
  if (isNonWindowMedia) {
    var specificity = (priority || 0) + (isGroup || isPlatform ? 1 : 0);
    if (isTheme || isGroup) {
      var groupParts = getGroupPropParts(isTheme ? "theme-" + mediaKeyIn : mediaKeyIn), {
        name,
        media,
        pseudo
      } = groupParts;
      groupMediaKey = media, isGroup && (containerName = name), (pseudo === "press" || pseudoIn === "active") && (specificity += 2), pseudo === "hover" && (isHover = true);
      var [selector, nextSelector] = getThemeOrGroupSelector(name, styleInner, isGroup, groupParts, isTheme, specificities[specificity]);
      styleRule = styleInner.replace(selector, nextSelector);
    } else styleRule = `${specificities[specificity]}${styleInner}`;
  }
  if (!isNonWindowMedia || groupMediaKey) {
    if (!selectors) {
      var mediaKeys2 = Object.keys(mediaQueries);
      selectors = Object.fromEntries(mediaKeys2.map(function(key) {
        return [key, mediaObjectToString(mediaQueries[key])];
      })), enableMediaPropOrder || (prefixes = Object.fromEntries(mediaKeys2.map(function(k, index2) {
        return [k, new Array(index2 + 1).fill(":root").join("")];
      })));
    }
    var mediaKey = groupMediaKey || mediaKeyIn, mediaSelector = selectors[mediaKey], screenStr = negate ? "not all and " : "", mediaQuery = `${screenStr}${mediaSelector}`, precedenceImportancePrefix = groupMediaKey ? groupPriority : enableMediaPropOrder && priority ? (
      // this new array should be cached
      specificities[priority]
    ) : (
      // @ts-ignore
      prefixes[mediaKey]
    ), prefix = groupMediaKey ? `@container ${containerName}` : "@media";
    groupMediaKey && (styleInner = styleRule), styleInner.includes(prefix) ? styleRule = styleInner.replace("{", ` and ${mediaQuery} {`).replace("and screen and", "and") : styleRule = `${prefix} ${mediaQuery}{${precedenceImportancePrefix}${styleInner}}`, groupMediaKey && (styleRule = `@supports (contain: ${getSetting("webContainerType") || "inline-size"}) {${styleRule}}`);
  }
  return isHover && (styleRule = `@media (hover:hover){${styleRule}}`), [property, void 0, nextIdentifier, void 0, [styleRule]];
};
var defaultOffset = {
  height: 0,
  width: 0
};
var normalizeColor = function(color, opacity) {
  if (color) {
    if (color[0] === "$") return color;
    if (color.startsWith("var(")) {
      if (typeof opacity == "number" && opacity < 1) return `color-mix(in srgb, ${color} ${opacity * 100}%, transparent)`;
    } else {
      var rgba3 = getRgba(color);
      if (rgba3) {
        var colors = `${rgba3.r},${rgba3.g},${rgba3.b}`, _ref;
        return opacity === 1 ? `rgb(${colors})` : `rgba(${colors},${(_ref = opacity != null ? opacity : rgba3.a) !== null && _ref !== void 0 ? _ref : 1})`;
      }
    }
    return color;
  }
}, getRgba = function(color) {
  var colorNum = normalizeCSSColor(color);
  if (colorNum != null) return rgba(colorNum);
};
function normalizeShadow(param) {
  var {
    shadowColor,
    shadowOffset,
    shadowOpacity,
    shadowRadius
  } = param, _getRgba, {
    height,
    width
  } = shadowOffset || defaultOffset;
  return {
    shadowOffset: {
      width: width || 0,
      height: height || 0
    },
    shadowRadius: shadowRadius || 0,
    shadowColor: normalizeColor(shadowColor, 1),
    shadowOpacity: shadowOpacity != null ? shadowOpacity : shadowColor ? (_getRgba = getRgba(shadowColor)) === null || _getRgba === void 0 ? void 0 : _getRgba.a : 1
  };
}
function fixStyles(style) {
  "elevationAndroid" in style && (style.elevation = style.elevationAndroid, delete style.elevationAndroid), (style.shadowRadius != null || style.shadowColor || style.shadowOpacity != null || style.shadowOffset) && Object.assign(style, normalizeShadow(style));
  for (var key in borderDefaults) if (key in style) {
    var _style, _borderDefaults_key;
    (_style = style)[_borderDefaults_key = borderDefaults[key]] || (_style[_borderDefaults_key] = "solid");
  }
}
var nativeStyle = "borderStyle", borderDefaults = {
  borderWidth: "borderStyle",
  borderBottomWidth: nativeStyle,
  borderTopWidth: nativeStyle,
  borderLeftWidth: nativeStyle,
  borderRightWidth: nativeStyle
};
var empty = function() {
  console.warn("no-op native");
}, getCSSStylesAtomic = empty, getStyleAtomic = empty, styleToCSS = empty;
function scanAllSheets() {
}
process.env.TAMAGUI_BAIL_AFTER_SCANNING_X_CSS_RULES;
function setNonce(_) {
}
function insertStyleRules(rulesToInsert) {
}
process.env.TAMAGUI_INSERT_SELECTOR_TRIES ? +process.env.TAMAGUI_INSERT_SELECTOR_TRIES : 1;
function isActivePlatform(key) {
  if (!key.startsWith("$platform")) return true;
  var platform = key.slice(10);
  return (
    // web, ios, android
    platform === currentPlatform || // web, native
    platform === "native"
  );
}
function isActiveTheme(key, activeThemeName) {
  if (key.startsWith("$theme-")) return key.slice(7).startsWith(activeThemeName);
}
__spreadValues({}, stylePropsAll);
function normalizeValueWithProperty(value) {
  return value;
}
var _loop$1 = function(parent) {
  var _exec, _exec_index, prefix = parent.slice(0, (_exec_index = (_exec = /[A-Z]/.exec(parent)) === null || _exec === void 0 ? void 0 : _exec.index) !== null && _exec_index !== void 0 ? _exec_index : parent.length);
  expansionsNoPrefix[parent] = expansionsNoPrefix[parent].map(function(k) {
    return `${prefix}${k}`;
  });
}, resizeModeMap = {
  fill: "stretch",
  none: "center",
  "scale-down": "contain",
  contain: "contain",
  cover: "cover"
}, verticalAlignMap = {
  top: "top",
  middle: "center",
  bottom: "bottom",
  auto: "auto"
}, webToNativeDynamicExpansion = {
  objectFit: function(val) {
    var resizeMode = resizeModeMap[val] || "cover";
    return [["resizeMode", resizeMode]];
  },
  verticalAlign: function(val) {
    return [["textAlignVertical", verticalAlignMap[val] || "auto"]];
  }
}, vert$1 = ["Top", "Bottom"], es = ["End", "Start"], t = ["Top"], b = ["Bottom"], s = ["Start"], e = ["End"], h = ["Height"], w = ["Width"], expansionsNoPrefix = {
  borderBlockColor: ["TopColor", "BottomColor"],
  borderInlineColor: ["EndColor", "StartColor"],
  borderBlockWidth: ["TopWidth", "BottomWidth"],
  borderInlineWidth: ["EndWidth", "StartWidth"],
  borderBlockStyle: ["TopStyle", "BottomStyle"],
  borderInlineStyle: ["EndStyle", "StartStyle"],
  marginBlock: vert$1,
  marginInline: es,
  paddingBlock: vert$1,
  paddingInline: es,
  borderBlockStartColor: ["TopColor"],
  borderBlockEndColor: ["BottomColor"],
  borderInlineStartColor: ["StartColor"],
  borderInlineEndColor: ["EndColor"],
  borderBlockStartWidth: ["TopWidth"],
  borderBlockEndWidth: ["BottomWidth"],
  borderInlineStartWidth: ["StartWidth"],
  borderInlineEndWidth: ["EndWidth"],
  borderBlockStartStyle: ["TopStyle"],
  borderBlockEndStyle: ["BottomStyle"],
  borderInlineStartStyle: ["StartStyle"],
  borderInlineEndStyle: ["EndStyle"],
  marginBlockStart: t,
  marginBlockEnd: b,
  marginInlineStart: s,
  marginInlineEnd: e,
  paddingBlockStart: t,
  paddingBlockEnd: b,
  paddingInlineStart: s,
  paddingInlineEnd: e,
  minBlockSize: h,
  maxBlockSize: h,
  minInlineSize: w,
  maxInlineSize: w
};
for (var parent$1 in expansionsNoPrefix) _loop$1(parent$1);
var expansions = {
  inset: ["top", "right", "bottom", "left"],
  insetBlock: ["top", "bottom"],
  insetBlockStart: ["top"],
  insetBlockEnd: ["bottom"],
  insetInlineStart: ["left"],
  insetInlineEnd: ["right"],
  blockSize: ["height"],
  inlineSize: ["width"]
}, webToNativeExpansion = Object.assign(expansionsNoPrefix, expansions);
var _loop = function(parent) {
  var _exec, _exec_index, prefix = parent.slice(0, (_exec_index = (_exec = /[A-Z]/.exec(parent)) === null || _exec === void 0 ? void 0 : _exec.index) !== null && _exec_index !== void 0 ? _exec_index : parent.length);
  EXPANSIONS[parent] = EXPANSIONS[parent].map(function(k) {
    return `${prefix}${k}`;
  });
};
function expandStyle(key, value) {
  if (isAndroid && key === "elevationAndroid") return [["elevation", value]];
  if (key in EXPANSIONS) return EXPANSIONS[key].map(function(key2) {
    return [key2, value];
  });
  if (key in webToNativeExpansion) return webToNativeExpansion[key].map(function(key2) {
    return [key2, value];
  });
  if (key in webToNativeDynamicExpansion) return webToNativeDynamicExpansion[key](value);
}
var all = ["Top", "Right", "Bottom", "Left"], horiz = ["Right", "Left"], vert = ["Top", "Bottom"], xy = ["X", "Y"], EXPANSIONS = __spreadValues({
  borderColor: ["TopColor", "RightColor", "BottomColor", "LeftColor"],
  borderRadius: ["TopLeftRadius", "TopRightRadius", "BottomRightRadius", "BottomLeftRadius"],
  borderWidth: ["TopWidth", "RightWidth", "BottomWidth", "LeftWidth"],
  margin: all,
  marginHorizontal: horiz,
  marginVertical: vert,
  overscrollBehavior: xy,
  padding: all,
  paddingHorizontal: horiz,
  paddingVertical: vert
}, isWeb);
for (var parent in EXPANSIONS) _loop(parent);
var cache$1 = /* @__PURE__ */ new WeakMap(), getVariantExtras = function(styleState) {
  if (cache$1.has(styleState)) return cache$1.get(styleState);
  var {
    props,
    conf: conf2,
    context,
    theme
  } = styleState, fonts = conf2.fontsParsed;
  (context == null ? void 0 : context.language) && (fonts = getFontsForLanguage(conf2.fontsParsed, context.language));
  var next = {
    fonts,
    tokens: conf2.tokensParsed,
    theme,
    get fontFamily() {
      return getVariableValue(styleState.fontFamily || styleState.props.fontFamily) || props.fontFamily || getVariableValue(styleState.conf.defaultFont);
    },
    get font() {
      return fonts[this.fontFamily] || (!props.fontFamily || props.fontFamily[0] === "$" ? fonts[styleState.conf.defaultFont] : void 0);
    },
    props
  };
  return cache$1.set(styleState, next), next;
}, fontLanguageCache = /* @__PURE__ */ new WeakMap();
function getFontsForLanguage(fonts, language) {
  if (fontLanguageCache.has(language)) return fontLanguageCache.get(language);
  var next = __spreadValues(__spreadValues({}, fonts), Object.fromEntries(Object.entries(language).map(function(param) {
    var [name, lang] = param;
    if (lang === "default") return [];
    var langKey = `$${name}_${lang}`;
    return [`$${name}`, fonts[langKey]];
  })));
  return fontLanguageCache.set(language, next), next;
}
function _type_of$4(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var isObj = function(x) {
  return x && !Array.isArray(x) && (typeof x > "u" ? "undefined" : _type_of$4(x)) === "object";
};
function normalizeStyle$1(style) {
  var disableNormalize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, res = {};
  for (var key in style) {
    var prop = style[key];
    if (prop != null) {
      if (key in pseudoDescriptors || // this should capture all parent-based styles like media, group, etc
      key[0] === "$" && isObj(prop)) {
        res[key] = normalizeStyle$1(prop, disableNormalize);
        continue;
      }
      var value = disableNormalize ? prop : normalizeValueWithProperty(prop), out = expandStyle(key, value);
      out ? Object.assign(res, Object.fromEntries(out)) : res[key] = value;
    }
  }
  return fixStyles(res), res;
}
var webPropsToSkip = {
  whiteSpace: 1,
  wordWrap: 1,
  textOverflow: 1,
  textDecorationDistance: 1,
  cursor: 1,
  contain: 1,
  boxSizing: 1,
  touchAction: 1,
  outlineStyle: 1,
  outlineOffset: 1,
  outlineWidth: 1,
  outlineColor: 1,
  backdropFilter: 1,
  backgroundImage: 1,
  mixBlendMode: 1,
  scrollbarWidth: 1,
  backgroundOrigin: 1,
  backgroundPosition: 1,
  backgroundRepeat: 1,
  backgroundSize: 1,
  backgroundClip: 1,
  backgroundBlendMode: 1,
  backgroundAttachment: 1,
  background: 1,
  clipPath: 1,
  caretColor: 1,
  transformStyle: 1,
  mask: 1,
  maskImage: 1,
  textEmphasis: 1,
  borderImage: 1,
  float: 1,
  content: 1,
  overflowBlock: 1,
  overflowInline: 1,
  maskBorder: 1,
  maskBorderMode: 1,
  maskBorderOutset: 1,
  maskBorderRepeat: 1,
  maskBorderSlice: 1,
  maskBorderSource: 1,
  maskBorderWidth: 1,
  maskClip: 1,
  maskComposite: 1,
  maskMode: 1,
  maskOrigin: 1,
  maskPosition: 1,
  maskRepeat: 1,
  maskSize: 1,
  maskType: 1
};
var skipProps = {
  untilMeasured: 1,
  animation: 1,
  space: 1,
  animateOnly: 1,
  disableClassName: 1,
  debug: 1,
  componentName: 1,
  disableOptimization: 1,
  tag: 1,
  style: 1,
  // handled after loop so pseudos set usedKeys and override it if necessary
  group: 1,
  themeInverse: 1,
  animatePresence: 1
};
Object.assign(skipProps, webPropsToSkip);
function _type_of$3(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var propMapper = function(key, value, styleState, disabled, map) {
  if (disabled) return map(key, value);
  if (lastFontFamilyToken = null, !(!isAndroid && key === "elevationAndroid")) {
    var {
      conf: conf2,
      styleProps,
      staticConfig
    } = styleState;
    if (value === "unset") {
      var _conf_unset, unsetVal = (_conf_unset = conf2.unset) === null || _conf_unset === void 0 ? void 0 : _conf_unset[key];
      if (unsetVal != null) value = unsetVal;
      else return;
    }
    var {
      variants
    } = staticConfig;
    if (!styleProps.noExpand && variants && key in variants) {
      var variantValue = resolveVariants(key, value, styleProps, styleState, "");
      if (variantValue) {
        variantValue.forEach(function(param) {
          var [_$key, _$value] = param;
          return map(_$key, _$value);
        });
        return;
      }
    }
    if (styleProps.disableExpandShorthands || key in conf2.shorthands && (key = conf2.shorthands[key]), value != null && (value[0] === "$" ? value = getTokenForKey(key, value, styleProps, styleState) : isVariable(value) && (value = resolveVariableValue(key, value, styleProps.resolveValues))), value != null) {
      key === "fontFamily" && lastFontFamilyToken && (styleState.fontFamily = lastFontFamilyToken);
      var expanded = styleProps.noExpand ? null : expandStyle(key, value);
      if (expanded) for (var max = expanded.length, i = 0; i < max; i++) {
        var [nkey, nvalue] = expanded[i];
        map(nkey, nvalue);
      }
      else map(key, value);
    }
  }
}, resolveVariants = function(key, value, styleProps, styleState, parentVariantKey) {
  var {
    staticConfig,
    conf: conf2,
    debug
  } = styleState, {
    variants
  } = staticConfig;
  if (variants) {
    var variantValue = getVariantDefinition(variants[key], value, conf2);
    if (!variantValue) {
      if (process.env.TAMAGUI_WARN_ON_MISSING_VARIANT === "1" && typeof value != "boolean") {
        var name = staticConfig.componentName || "[UnnamedComponent]";
        console.warn(`No variant found: ${name} has variant "${key}", but no matching value "${value}"`);
      }
      return;
    }
    if (typeof variantValue == "function") {
      var fn = variantValue, extras = getVariantExtras(styleState);
      variantValue = fn(value, extras);
    }
    var fontFamilyResult;
    if (isObj(variantValue)) {
      var fontFamilyUpdate = variantValue.fontFamily || variantValue[conf2.inverseShorthands.fontFamily];
      fontFamilyUpdate && (fontFamilyResult = getFontFamilyFromNameOrVariable(fontFamilyUpdate, conf2), styleState.fontFamily = fontFamilyResult, false), variantValue = resolveTokensAndVariants(key, variantValue, styleProps, styleState, parentVariantKey);
    }
    if (variantValue) {
      var expanded = normalizeStyle$1(variantValue, !!styleProps.noNormalize);
      var next = Object.entries(expanded);
      return fontFamilyResult && fontFamilyResult[0] === "$" && (lastFontFamilyToken = getVariableValue(fontFamilyResult)), next;
    }
  }
};
function getFontFamilyFromNameOrVariable(input, conf2) {
  if (isVariable(input)) {
    var val = variableToFontNameCache.get(input);
    if (val) return val;
    for (var key in conf2.fontsParsed) {
      var familyVariable = conf2.fontsParsed[key].family;
      if (isVariable(familyVariable) && (variableToFontNameCache.set(familyVariable, key), familyVariable === input)) return key;
    }
  } else if (typeof input == "string" && input[0] === "$") return input;
}
var variableToFontNameCache = /* @__PURE__ */ new WeakMap(), resolveTokensAndVariants = function(key, value, styleProps, styleState, parentVariantKey) {
  var {
    conf: conf2,
    staticConfig,
    debug,
    theme
  } = styleState, {
    variants
  } = staticConfig, res = {};
  for (var _key in value) {
    var subKey = conf2.shorthands[_key] || _key, val = value[_key];
    if (!(!styleProps.noSkip && subKey in skipProps)) {
      if (styleProps.noExpand) res[subKey] = val;
      else if (variants && subKey in variants) {
        if (parentVariantKey && parentVariantKey === key) res[subKey] = // SYNC WITH *1
        val[0] === "$" ? getTokenForKey(subKey, val, styleProps, styleState) : val;
        else {
          var variantOut = resolveVariants(subKey, val, styleProps, styleState, key);
          if (variantOut) {
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
            try {
              for (var _iterator = variantOut[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var [_$key, val1] = _step.value;
                if (val1 != null) if (_$key in pseudoDescriptors) {
                  var _res, _key1, _;
                  (_ = (_res = res)[_key1 = _$key]) !== null && _ !== void 0 || (_res[_key1] = {}), Object.assign(res[_$key], val1);
                } else res[_$key] = val1;
              }
            } catch (err) {
              _didIteratorError = true, _iteratorError = err;
            } finally {
              try {
                !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
              } finally {
                if (_didIteratorError) throw _iteratorError;
              }
            }
          }
        }
        continue;
      }
      if (isVariable(val)) {
        res[subKey] = resolveVariableValue(subKey, val, styleProps.resolveValues);
        continue;
      }
      if (typeof val == "string") {
        var fVal = (
          // SYNC WITH *1
          val[0] === "$" ? getTokenForKey(subKey, val, styleProps, styleState) : val
        );
        res[subKey] = fVal;
        continue;
      }
      if (isObj(val)) {
        var _res1, _subKey, subObject = resolveTokensAndVariants(subKey, val, styleProps, styleState, key);
        var _1;
        (_1 = (_res1 = res)[_subKey = subKey]) !== null && _1 !== void 0 || (_res1[_subKey] = {}), Object.assign(res[subKey], subObject);
      } else res[subKey] = val;
    }
  }
  return res;
}, tokenCats = ["size", "color", "radius", "space", "zIndex"].map(function(name) {
  return {
    name,
    spreadName: `...${name}`
  };
});
function getVariantDefinition(variant, value, conf2) {
  if (variant) {
    if (typeof variant == "function") return variant;
    var exact = variant[value];
    if (exact) return exact;
    if (value != null) {
      var {
        tokensParsed
      } = conf2, _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
      try {
        for (var _iterator = tokenCats[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var {
            name,
            spreadName
          } = _step.value;
          if (spreadName in variant && name in tokensParsed && value in tokensParsed[name]) return variant[spreadName];
        }
      } catch (err) {
        _didIteratorError = true, _iteratorError = err;
      } finally {
        try {
          !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError) throw _iteratorError;
        }
      }
      var fontSizeVariant = variant["...fontSize"];
      if (fontSizeVariant && conf2.fontSizeTokens.has(value)) return fontSizeVariant;
    }
    return variant[`:${typeof value > "u" ? "undefined" : _type_of$3(value)}`] || variant["..."];
  }
}
var fontShorthand = {
  fontSize: "size",
  fontWeight: "weight"
}, lastFontFamilyToken = null, getTokenForKey = function(key, value, styleProps, styleState) {
  var _staticConfig_accept, resolveAs = styleProps.resolveValues || "none";
  if (resolveAs === "none") return value;
  var {
    theme,
    conf: conf2 = getConfig(),
    context,
    fontFamily,
    staticConfig
  } = styleState, themeValue = theme ? theme[value] || theme[value.slice(1)] : void 0, tokensParsed = conf2.tokensParsed, valOrVar, hasSet = false, customTokenAccept = staticConfig == null || (_staticConfig_accept = staticConfig.accept) === null || _staticConfig_accept === void 0 ? void 0 : _staticConfig_accept[key];
  if (customTokenAccept) {
    var val = themeValue != null ? themeValue : tokensParsed[customTokenAccept][value];
    val != null && (resolveAs = "value", valOrVar = val, hasSet = true);
  }
  if (themeValue) {
    if (resolveAs === "except-theme") return value;
    valOrVar = themeValue, hasSet = true;
  } else {
    if (value in conf2.specificTokens) hasSet = true, valOrVar = conf2.specificTokens[value];
    else {
      switch (key) {
        case "fontFamily": {
          var _fontsParsed_value, fontsParsed = (context == null ? void 0 : context.language) ? getFontsForLanguage(conf2.fontsParsed, context.language) : conf2.fontsParsed;
          valOrVar = ((_fontsParsed_value = fontsParsed[value]) === null || _fontsParsed_value === void 0 ? void 0 : _fontsParsed_value.family) || value, lastFontFamilyToken = value, hasSet = true;
          break;
        }
        case "fontSize":
        case "lineHeight":
        case "letterSpacing":
        case "fontWeight": {
          var fam = fontFamily || conf2.defaultFontToken;
          if (fam) {
            var _font_, fontsParsed1 = (context == null ? void 0 : context.language) ? getFontsForLanguage(conf2.fontsParsed, context.language) : conf2.fontsParsed, font = fontsParsed1[fam] || fontsParsed1[conf2.defaultFontToken];
            valOrVar = (font == null || (_font_ = font[fontShorthand[key] || key]) === null || _font_ === void 0 ? void 0 : _font_[value]) || value, hasSet = true;
          }
          break;
        }
      }
      for (var cat in tokenCategories) if (key in tokenCategories[cat]) {
        var _tokensParsed_cat, res = (_tokensParsed_cat = tokensParsed[cat]) === null || _tokensParsed_cat === void 0 ? void 0 : _tokensParsed_cat[value];
        res != null ? (valOrVar = res, hasSet = true) : false;
      }
    }
    if (!hasSet) {
      var spaceVar = tokensParsed.space[value];
      spaceVar != null && (valOrVar = spaceVar, hasSet = true);
    }
  }
  if (hasSet) {
    var out = resolveVariableValue(key, valOrVar, resolveAs);
    return out;
  }
};
function resolveVariableValue(key, valOrVar, resolveValues) {
  if (resolveValues === "none") return valOrVar;
  if (isVariable(valOrVar)) {
    if (resolveValues === "value") return valOrVar.val;
    var get = valOrVar == null ? void 0 : valOrVar.get;
    if (key !== "shadowColor" && typeof get == "function") {
      var resolveDynamicFor = resolveValues === "web" ? "web" : void 0;
      return get(resolveDynamicFor);
    }
    return valOrVar.val;
  }
  return valOrVar;
}
var sortString = function(a, b2) {
  return a < b2 ? -1 : a > b2 ? 1 : 0;
};
function transformsToString(transforms) {
  return transforms.map(
    // { scale: 2 } => 'scale(2)'
    // { translateX: 20 } => 'translateX(20px)'
    // { matrix: [1,2,3,4,5,6] } => 'matrix(1,2,3,4,5,6)'
    // { perspective: 1000 } => perspective(1000px)
    function(transform) {
      var type = Object.keys(transform)[0], value = transform[type];
      return type === "matrix" || type === "matrix3d" ? `${type}(${value.join(",")})` : `${type}(${normalizeValueWithProperty(value)})`;
    }
  ).join(" ");
}
function _type_of$2(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var conf, PROP_SPLIT = "-";
function isValidStyleKey(key, validStyles2, accept) {
  return key in validStyles2 ? true : accept && key in accept;
}
var getSplitStyles = function(props, staticConfig, theme, themeName, componentState, styleProps, parentSplitStyles, componentContext, groupContext, elementType, startedUnhydrated, debug) {
  var _loop2 = function(keyOg2) {
    var keyInit = keyOg2, valInit = props[keyInit];
    if (keyInit === "children") return viewProps[keyInit] = valInit, "continue";
    if (accept) {
      var accepted = accept[keyInit];
      if ((accepted === "style" || accepted === "textStyle") && valInit && (typeof valInit > "u" ? "undefined" : _type_of$2(valInit)) === "object") return viewProps[keyInit] = getSubStyle(styleState, keyInit, valInit, styleProps.noClass), "continue";
    }
    if (disableExpandShorthands || keyInit in shorthands && (keyInit = shorthands[keyInit]), keyInit === "className") return "continue";
    if (keyInit in skipProps && !noSkip && !isHOC) {
      return "continue";
    }
    var isValidStyleKeyInit = isValidStyleKey(keyInit, validStyles$1, accept);
    if (!isValidStyleKeyInit) {
      if (!isAndroid && keyInit === "elevationAndroid") return "continue";
      if (keyInit === "userSelect") keyInit = "selectable", valInit = valInit !== "none";
      else if (keyInit.startsWith("data-")) return "continue";
    }
    if (keyInit === "dataSet") {
      for (var keyInit1 in valInit) viewProps[`data-${hyphenate(keyInit1)}`] = valInit[keyInit1];
      return "continue";
    }
    var isVariant = !isValidStyleKeyInit && variants && keyInit in variants, isStyleLikeKey = isValidStyleKeyInit || isVariant, isPseudo = keyInit in validPseudoKeys, isMedia = !isStyleLikeKey && !isPseudo ? getMediaKey(keyInit) : false, isMediaOrPseudo = !!(isMedia || isPseudo);
    if (isMediaOrPseudo && isMedia === "group") {
      var parts = keyInit.split("-"), plen = parts.length;
      if (
        // check if its actually a simple group selector to avoid breaking selectors
        plen === 2 || plen === 3 && pseudoPriorities[parts[parts.length - 1]]
      ) {
        var name2 = parts[1];
        groupContext && !(groupContext == null ? void 0 : groupContext[name2]) && (keyInit = keyInit.replace("$group-", "$group-true-"));
      }
    }
    var isStyleProp = isValidStyleKeyInit || isMediaOrPseudo || isVariant && !noExpand;
    if (isStyleProp && (asChild === "except-style" || asChild === "except-style-web")) return "continue";
    var shouldPassProp = !isStyleProp && isHOC || // is in parent variants
    isHOC && parentVariants && keyInit in parentVariants || (inlineProps == null ? void 0 : inlineProps.has(keyInit)), parentVariant = parentVariants == null ? void 0 : parentVariants[keyInit], isHOCShouldPassThrough = !!(isHOC && (isValidStyleKeyInit || isMediaOrPseudo || parentVariant || keyInit in skipProps)), shouldPassThrough = shouldPassProp || isHOCShouldPassThrough;
    if (shouldPassThrough && (passDownProp(viewProps, keyInit, valInit, isMediaOrPseudo), !isVariant)) return "continue";
    if (!noSkip && keyInit in skipProps) return "continue";
    (isText || isInput) && valInit && (keyInit === "fontFamily" || keyInit === shorthands.fontFamily) && valInit in conf.fontsParsed && (styleState.fontFamily = valInit);
    var disablePropMap = isMediaOrPseudo || !isStyleLikeKey;
    if (propMapper(keyInit, valInit, styleState, disablePropMap, function(key4, val2) {
      var _parentStaticConfig_variants, isStyledContextProp = styledContext && key4 in styledContext;
      if (!isHOC && disablePropMap && !isStyledContextProp && !isMediaOrPseudo) {
        viewProps[key4] = val2;
        return;
      }
      if (val2 != null) {
        if (key4 === "pointerEvents") {
          viewProps[key4] = val2;
          return;
        }
        if (!isHOC && isValidStyleKey(key4, validStyles$1, accept) || isAndroid && key4 === "elevation") {
          mergeStyle(styleState, key4, val2, 1);
          return;
        }
        if (isPseudo = key4 in validPseudoKeys, isMedia = isPseudo ? false : getMediaKey(key4), isMediaOrPseudo = !!(isMedia || isPseudo), isVariant = variants && key4 in variants, (inlineProps == null ? void 0 : inlineProps.has(key4)) || process.env.IS_STATIC === "is_static" && (inlineWhenUnflattened == null ? void 0 : inlineWhenUnflattened.has(key4))) {
          var _props_key;
          viewProps[key4] = (_props_key = props[key4]) !== null && _props_key !== void 0 ? _props_key : val2;
        }
        var shouldPassThrough2 = styleProps.noExpand && isPseudo || isHOC && (isMediaOrPseudo || (parentStaticConfig == null || (_parentStaticConfig_variants = parentStaticConfig.variants) === null || _parentStaticConfig_variants === void 0 ? void 0 : _parentStaticConfig_variants[keyInit]));
        if (shouldPassThrough2) {
          passDownProp(viewProps, key4, val2, isMediaOrPseudo);
          return;
        }
        if (isPseudo) {
          if (!val2) return;
          var pseudoStyleObject = getSubStyle(styleState, key4, val2, styleProps.noClass && process.env.IS_STATIC !== "is_static");
          {
            var _pseudos, _key;
            if (pseudos || (pseudos = {}), (_pseudos = pseudos)[_key = key4] || (_pseudos[_key] = {}), process.env.IS_STATIC === "is_static") {
              Object.assign(pseudos[key4], pseudoStyleObject);
              return;
            }
          }
          var descriptor = pseudoDescriptors[key4], isEnter = key4 === "enterStyle", isExit = key4 === "exitStyle";
          if (!descriptor) return;
          {
            var descriptorKey = descriptor.stateKey || descriptor.name, isDisabled2 = componentState[descriptorKey] === false;
            isExit && (isDisabled2 = !styleProps.isExiting), isEnter && componentState.unmounted === false && (isDisabled2 = true);
            var importance = descriptor.priority;
            for (var pkey in pseudoStyleObject) {
              var _$val = pseudoStyleObject[pkey];
              if (isDisabled2) applyDefaultStyle(pkey, styleState);
              else {
                var curImportance = styleState.usedKeys[pkey] || 0, shouldMerge = importance >= curImportance;
                if (shouldMerge) {
                  if (process.env.IS_STATIC === "is_static") {
                    var _pseudos1, _key1;
                    pseudos || (pseudos = {}), (_pseudos1 = pseudos)[_key1 = key4] || (_pseudos1[_key1] = {}), pseudos[key4][pkey] = _$val;
                  }
                  mergeStyle(styleState, pkey, _$val, importance);
                }
              }
            }
            if (!isDisabled2) for (var _$key in val2) {
              var k = shorthands[_$key] || _$key;
              styleState.usedKeys[k] = Math.max(importance, styleState.usedKeys[k] || 0);
            }
          }
          return;
        }
        if (isMedia) {
          if (!val2) return;
          val2.space;
          var mediaKeyShort = key4.slice(isMedia == "theme" ? 7 : 1);
          if (hasMedia || (hasMedia = true), (!hasMedia || typeof hasMedia == "boolean") && (hasMedia = /* @__PURE__ */ new Set()), hasMedia.add(mediaKeyShort), isMedia === "platform" && !isActivePlatform(key4)) return;
          var priority = mediaStylesSeen;
          if (mediaStylesSeen += 1, shouldDoClasses) ;
          else {
            let mergeMediaStyle2 = function(key5, val3) {
              var _styleState4;
              (_styleState4 = styleState).style || (_styleState4.style = {});
              var didMerge = mergeMediaByImportance(styleState, mediaKeyShort, key5, val3, mediaState[mediaKeyShort], importanceBump);
              didMerge && key5 === "fontFamily" && (styleState.fontFamily = mediaStyle1.fontFamily);
            };
            var isThemeMedia = isMedia === "theme", isGroupMedia = isMedia === "group", isPlatformMedia = isMedia === "platform";
            if (!isThemeMedia && !isPlatformMedia && !isGroupMedia) {
              if (!mediaState[mediaKeyShort]) {
                return;
              }
            }
            var mediaStyle1 = getSubStyle(styleState, key4, val2, true), importanceBump = 0;
            if (isThemeMedia) {
              if (dynamicThemeAccess = true, isIos && getSetting("fastSchemeChange")) {
                var _styleState3;
                (_styleState3 = styleState).style || (_styleState3.style = {});
                var scheme = mediaKeyShort, oppositeScheme = getOppositeScheme(mediaKeyShort);
                for (var subKey1 in mediaStyle1) {
                  var _$val1 = extractValueFromDynamic(mediaStyle1[subKey1], scheme), oppositeVal = extractValueFromDynamic(styleState.style[subKey1], oppositeScheme);
                  mediaStyle1[subKey1] = getDynamicVal({
                    scheme,
                    val: _$val1,
                    oppositeVal
                  }), mergeStyle(styleState, subKey1, mediaStyle1[subKey1], priority);
                }
              } else if (!(themeName === mediaKeyShort || themeName.startsWith(mediaKeyShort))) return;
            } else if (isGroupMedia) {
              var _groupContext_groupName, _componentState_group, groupInfo = getGroupPropParts(mediaKeyShort), groupName = groupInfo.name, groupState = groupContext == null || (_groupContext_groupName = groupContext[groupName]) === null || _groupContext_groupName === void 0 ? void 0 : _groupContext_groupName.state, groupPseudoKey = groupInfo.pseudo, groupMediaKey = groupInfo.media;
              if (!groupState) {
                pseudoGroups || (pseudoGroups = /* @__PURE__ */ new Set());
                return;
              }
              var componentGroupState = (_componentState_group = componentState.group) === null || _componentState_group === void 0 ? void 0 : _componentState_group[groupName];
              if (groupMediaKey) {
                mediaGroups || (mediaGroups = /* @__PURE__ */ new Set()), mediaGroups.add(groupMediaKey);
                var mediaState1 = componentGroupState == null ? void 0 : componentGroupState.media, isActive = mediaState1 == null ? void 0 : mediaState1[groupMediaKey];
                if (!mediaState1 && groupState.layout && (isActive = mediaKeyMatch(groupMediaKey, groupState.layout)), !isActive) {
                  for (var pkey1 in mediaStyle1) applyDefaultStyle(pkey1, styleState);
                  return;
                }
                importanceBump = 2;
              }
              if (groupPseudoKey) {
                var _this;
                pseudoGroups || (pseudoGroups = /* @__PURE__ */ new Set()), pseudoGroups.add(groupName);
                var componentGroupPseudoState = (_this = componentGroupState || (groupContext == null ? void 0 : groupContext[groupName].state)) === null || _this === void 0 ? void 0 : _this.pseudo, isActive1 = componentGroupPseudoState == null ? void 0 : componentGroupPseudoState[groupPseudoKey], priority1 = pseudoPriorities[groupPseudoKey];
                if (!isActive1) {
                  for (var pkey2 in mediaStyle1) applyDefaultStyle(pkey2, styleState);
                  return;
                }
                importanceBump = priority1;
              }
            }
            for (var subKey2 in mediaStyle1) {
              if (subKey2 === "space") {
                space = valInit.space;
                continue;
              }
              if (subKey2[0] === "$") {
                if (!isActivePlatform(subKey2) || !isActiveTheme(subKey2, themeName)) continue;
                for (var subSubKey in mediaStyle1[subKey2]) mergeMediaStyle2(subSubKey, mediaStyle1[subKey2][subSubKey]);
              } else mergeMediaStyle2(subKey2, mediaStyle1[subKey2]);
            }
          }
          return;
        }
        if (!isVariant) {
          if (isStyledContextProp) return;
          viewProps[key4] = val2;
        }
      }
    }), false) ;
  };
  conf = conf || getConfig();
  (componentContext == null ? void 0 : componentContext.animationDriver) || conf.animations;
  if (props.passThrough) return null;
  var {
    shorthands
  } = conf, {
    isHOC,
    isText,
    isInput,
    variants,
    isReactNative,
    inlineProps,
    inlineWhenUnflattened,
    parentStaticConfig,
    acceptsClassName
  } = staticConfig, viewProps = {}, mediaState = styleProps.mediaState || exports.mediaState, shouldDoClasses = acceptsClassName && isWeb, rulesToInsert = void 0, classNames = {}, pseudos = null, space = props.space, hasMedia = false, dynamicThemeAccess, pseudoGroups, mediaGroups;
  props.className || "";
  var mediaStylesSeen = 0, validStyles$1 = staticConfig.validStyles || (staticConfig.isText || staticConfig.isInput ? stylePropsText : validStyles);
  var styleState = {
    classNames,
    conf,
    props,
    styleProps,
    componentState,
    staticConfig,
    style: null,
    theme,
    usedKeys: {},
    viewProps,
    context: componentContext,
    debug
  };
  if (process.env.IS_STATIC === "is_static") {
    var {
      fallbackProps
    } = styleProps;
    fallbackProps && (styleState.props = new Proxy(props, {
      get(_, key4, val2) {
        return Reflect.has(props, key4) ? Reflect.get(props, key4) : Reflect.get(fallbackProps, key4);
      }
    }));
  }
  var {
    asChild
  } = props, {
    accept
  } = staticConfig, {
    noSkip,
    disableExpandShorthands,
    noExpand,
    styledContext
  } = styleProps, {
    webContainerType
  } = conf.settings, parentVariants = parentStaticConfig == null ? void 0 : parentStaticConfig.variants;
  for (var keyOg in props) _loop2(keyOg);
  var avoidNormalize = styleProps.noNormalize === false;
  if (!avoidNormalize) {
    if (styleState.style && (fixStyles(styleState.style), !styleProps.noExpand && !styleProps.noMergeStyle && isWeb), styleState.flatTransforms) {
      var _styleState;
      (_styleState = styleState).style || (_styleState.style = {}), mergeFlatTransforms(styleState.style, styleState.flatTransforms);
    }
    if (parentSplitStyles) {
      for (var key1 in parentSplitStyles.style) {
        var _styleState1;
        key1 in classNames || styleState.style && key1 in styleState.style || ((_styleState1 = styleState).style || (_styleState1.style = {}), styleState.style[key1] = parentSplitStyles.style[key1]);
      }
    }
  }
  var styleProp = props.style;
  if (!styleProps.noMergeStyle && styleProp) if (isHOC) viewProps.style = normalizeStyle(styleProp);
  else for (var isArray = Array.isArray(styleProp), len = isArray ? styleProp.length : 1, i = 0; i < len; i++) {
    var style = isArray ? styleProp[i] : styleProp;
    if (style) if (style.$$css) Object.assign(styleState.classNames, style);
    else {
      var _styleState2;
      (_styleState2 = styleState).style || (_styleState2.style = {}), Object.assign(styleState.style, normalizeStyle(style));
    }
  }
  var style1 = styleState.style;
  if (style1 == null ? void 0 : style1.fontFamily) {
    var _getFont, faceInfo = (_getFont = getFont(style1.fontFamily)) === null || _getFont === void 0 ? void 0 : _getFont.face;
    if (faceInfo) {
      var _faceInfo_style_fontWeight_, _faceInfo_style_fontWeight, overrideFace = (_faceInfo_style_fontWeight = faceInfo[style1.fontWeight]) === null || _faceInfo_style_fontWeight === void 0 || (_faceInfo_style_fontWeight_ = _faceInfo_style_fontWeight[style1.fontStyle || "normal"]) === null || _faceInfo_style_fontWeight_ === void 0 ? void 0 : _faceInfo_style_fontWeight_.val;
      overrideFace && (style1.fontFamily = overrideFace, styleState.fontFamily = overrideFace, delete style1.fontWeight, delete style1.fontStyle);
    }
  }
  var result = {
    space,
    hasMedia,
    fontFamily: styleState.fontFamily,
    viewProps,
    style: styleState.style,
    pseudos,
    classNames,
    rulesToInsert,
    dynamicThemeAccess,
    pseudoGroups,
    mediaGroups
  }, asChildExceptStyleLike = asChild === "except-style" || asChild === "except-style-web";
  if (!styleProps.noMergeStyle && !asChildExceptStyleLike) {
    var style2 = styleState.style;
    style2 && (viewProps.style = style2);
  }
  return result;
};
function mergeFlatTransforms(target, flatTransforms) {
  Object.entries(flatTransforms).sort(function(param, param1) {
    var [a] = param, [b2] = param1;
    return sortString(a, b2);
  }).forEach(function(param) {
    var [key, val] = param;
    mergeTransform(target, key, val, true);
  });
}
function mergeStyle(styleState, key, val, importance) {
  var {
    viewProps,
    styleProps,
    staticConfig,
    usedKeys
  } = styleState, existingImportance = usedKeys[key] || 0;
  if (!(existingImportance > importance)) if (key in stylePropsTransform) {
    var _styleState;
    (_styleState = styleState).flatTransforms || (_styleState.flatTransforms = {}), usedKeys[key] = importance, styleState.flatTransforms[key] = val;
  } else {
    var shouldNormalize = isWeb, out = shouldNormalize ? normalizeValueWithProperty(val) : val;
    if (
      // accept is for props not styles
      staticConfig.accept && key in staticConfig.accept
    ) viewProps[key] = out;
    else {
      var _styleState1;
      (_styleState1 = styleState).style || (_styleState1.style = {}), usedKeys[key] = importance, styleState.style[key] = // if you dont do this you'll be passing props.transform arrays directly here and then mutating them
      // if theres any flatTransforms later, causing issues (mutating props is bad, in strict mode styles get borked)
      key === "transform" && Array.isArray(out) ? [...out] : out;
    }
  }
}
var getSubStyle = function(styleState, subKey, styleIn, avoidMergeTransform) {
  var _loop2 = function(key1) {
    var val = styleIn[key1];
    key1 = conf2.shorthands[key1] || key1;
    var shouldSkip = !staticConfig.isHOC && key1 in skipProps && !styleProps.noSkip;
    if (shouldSkip) return key = key1, "continue";
    propMapper(key1, val, styleState, false, function(skey, sval) {
      skey in validPseudoKeys && (sval = getSubStyle(styleState, skey, sval, avoidMergeTransform)), !avoidMergeTransform && skey in stylePropsTransform ? mergeTransform(styleOut, skey, sval) : styleOut[skey] = styleProps.noNormalize ? sval : normalizeValueWithProperty(sval);
    }), key = key1;
  }, {
    staticConfig,
    conf: conf2,
    styleProps
  } = styleState, styleOut = {};
  for (var key in styleIn) _loop2(key);
  if (!avoidMergeTransform) {
    if (Array.isArray(styleOut.transform)) {
      var _styleState_style, parentTransform = (_styleState_style = styleState.style) === null || _styleState_style === void 0 ? void 0 : _styleState_style.transform;
      parentTransform && (styleOut.transform = [...parentTransform, ...styleOut.transform]);
    }
    styleState.flatTransforms && mergeFlatTransforms(styleOut, styleState.flatTransforms);
  }
  return styleProps.noNormalize || fixStyles(styleOut), styleOut;
}, useSplitStyles = function(a, b2, c, d, e2, f, g, h2, i, j, k, l) {
  var res = getSplitStyles(a, b2, c, d, e2, f, g, h2, i, j, k, l);
  return res;
};
var defaultColor = process.env.TAMAGUI_DEFAULT_COLOR || "rgba(0,0,0,0)", animatableDefaults = __spreadProps(__spreadValues({}, Object.fromEntries(Object.entries(tokenCategories.color).map(function(param) {
  var [k, v] = param;
  return [k, defaultColor];
}))), {
  opacity: 1,
  scale: 1,
  rotate: "0deg",
  rotateY: "0deg",
  rotateX: "0deg",
  x: 0,
  y: 0,
  borderRadius: 0
}), lowercaseHyphenate = function(match) {
  return `-${match.toLowerCase()}`;
}, hyphenate = function(str) {
  return str.replace(/[A-Z]/g, lowercaseHyphenate);
}, mergeTransform = function(obj, key, val) {
  var backwards = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, _obj;
  typeof obj.transform != "string" && ((_obj = obj).transform || (_obj.transform = []), obj.transform[backwards ? "unshift" : "push"]({
    [mapTransformKeys[key] || key]: val
  }));
}, mapTransformKeys = {
  x: "translateX",
  y: "translateY"
};
function passDownProp(viewProps, key, val) {
  var shouldMergeObject = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (shouldMergeObject) {
    var next = __spreadValues(__spreadValues({}, viewProps[key]), val);
    delete viewProps[key], viewProps[key] = next;
  } else viewProps[key] = val;
}
function mergeMediaByImportance(styleState, mediaKey, key, value, isSizeMedia, importanceBump, debugProp) {
  styleState.usedKeys;
  var importance = getMediaImportanceIfMoreImportant(mediaKey, key, styleState, isSizeMedia);
  if (importanceBump && (importance = (importance || 0) + importanceBump), importance === null) return false;
  if (key in pseudoDescriptors) {
    var descriptor = pseudoDescriptors[key], descriptorKey = descriptor.stateKey || descriptor.name, isDisabled2 = styleState.componentState[descriptorKey] === false;
    if (isDisabled2) return false;
    for (var subKey in value) mergeStyle(styleState, subKey, value[subKey], importance);
  } else mergeStyle(styleState, key, value, importance);
  return true;
}
function normalizeStyle(style) {
  var out = {};
  for (var key in style) {
    var val = style[key];
    key in stylePropsTransform ? mergeTransform(out, key, val) : out[key] = normalizeValueWithProperty(val);
  }
  return fixStyles(out), out;
}
function applyDefaultStyle(pkey, styleState) {
  var defaultValues = animatableDefaults[pkey];
  defaultValues != null && !(pkey in styleState.usedKeys) && (!styleState.style || !(pkey in styleState.style)) && mergeStyle(styleState, pkey, defaultValues, 1);
}
function setElementProps(element) {
  element && !element.getBoundingClientRect && (element.getBoundingClientRect = function() {
    if (element.unstable_getBoundingClientRect != null) return element.unstable_getBoundingClientRect();
  });
}
var subscribeToContextGroup = function(props) {
  var {
    pseudoGroups,
    mediaGroups,
    groupContext
  } = props;
  if (pseudoGroups || mediaGroups) {
    var disposables = /* @__PURE__ */ new Set();
    if (pseudoGroups) for (var _i = 0, _iter = [...pseudoGroups]; _i < _iter.length; _i++) {
      var name = _iter[_i];
      disposables.add(createGroupListener(name, props));
    }
    if (mediaGroups) for (var _i1 = 0, _iter1 = [...mediaGroups]; _i1 < _iter1.length; _i1++) {
      var name1 = _iter1[_i1];
      disposables.add(createGroupListener(name1, props));
    }
    return function() {
      disposables.forEach(function(d) {
        return d();
      });
    };
  }
}, createGroupListener = function(name, param) {
  var {
    setStateShallow,
    pseudoGroups,
    mediaGroups,
    groupContext
  } = param, parent = groupContext == null ? void 0 : groupContext[name];
  if (!parent) return function() {
  };
  var dispose2 = parent.subscribe(function(param2) {
    var {
      layout,
      pseudo
    } = param2;
    setStateShallow(function(prev) {
      var _prev_group, didChange = false, group = ((_prev_group = prev.group) === null || _prev_group === void 0 ? void 0 : _prev_group[name]) || {
        pseudo: {},
        media: {}
      };
      if (pseudo && (pseudoGroups == null ? void 0 : pseudoGroups.has(name))) {
        var _group;
        (_group = group).pseudo || (_group.pseudo = {});
        var next = mergeIfNotShallowEqual(group.pseudo, pseudo);
        next !== group.pseudo && (Object.assign(group.pseudo, pseudo), didChange = true);
      } else if (layout && mediaGroups) {
        var _group1;
        (_group1 = group).media || (_group1.media = {});
        var mediaState = getMediaState(mediaGroups, layout), next1 = mergeIfNotShallowEqual(group.media, mediaState);
        next1 !== group.media && (Object.assign(group.media, next1), didChange = true);
      }
      return didChange ? {
        group: __spreadProps(__spreadValues({}, prev.group), {
          [name]: group
        })
      } : prev;
    });
  });
  return function() {
    dispose2(), setStateShallow({
      group: {}
    });
  };
};
var Theme = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  if (props.disable) return props.children;
  var {
    passThrough
  } = props, isRoot = !!props._isRoot, [_, themeState] = useThemeWithState(props, isRoot), disableDirectChildTheme = props["disable-child-theme"], finalChildren = disableDirectChildTheme ? React.Children.map(props.children, function(child) {
    return passThrough ? child : /* @__PURE__ */ React.cloneElement(child, {
      "data-disable-theme": true
    });
  }) : props.children;
  if (ref) try {
    React.Children.only(finalChildren), finalChildren = /* @__PURE__ */ React.cloneElement(finalChildren, {
      ref
    });
  } catch (e2) {
  }
  var stateRef = React.useRef({
    hasEverThemed: false
  });
  return getThemedChildren(themeState, finalChildren, props, isRoot, stateRef, passThrough);
});
Theme.avoidForwardRef = true;
function getThemedChildren(themeState, children, props) {
  var isRoot = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, stateRef = arguments.length > 4 ? arguments[4] : void 0, passThrough = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false, {
    shallow,
    forceClassName
  } = props, state = stateRef.current, hasEverThemed = state.hasEverThemed, shouldRenderChildrenWithTheme = hasEverThemed || themeState.isNew || isRoot || hasThemeUpdatingProps(props);
  if (!shouldRenderChildrenWithTheme) return children;
  children = /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeStateContext.Provider, {
    value: themeState.id,
    children
  });
  var {
    isInverse,
    name
  } = themeState, requiresExtraWrapper = isInverse || forceClassName;
  if (state.hasEverThemed || (state.hasEverThemed = true), (requiresExtraWrapper || // if the theme is exactly dark or light, its likely to change between dark/light
  // and that would require wrapping which would re-parent, so to avoid re-parenting do this
  themeState.name === "dark" || themeState.name === "light") && (state.hasEverThemed = "wrapped"), shallow && themeState.parentId) {
    var parentState = getThemeState(themeState.isNew ? themeState.id : themeState.parentId);
    if (!parentState) throw new Error("010");
    children = React.Children.toArray(children).map(function(child) {
      return /* @__PURE__ */ React.isValidElement(child) ? passThrough ? child : /* @__PURE__ */ React.cloneElement(child, void 0, /* @__PURE__ */ jsxRuntimeExports.jsx(Theme, {
        name: parentState.name,
        children: child.props.children
      })) : child;
    });
  }
  if (forceClassName === false) return children;
  return children;
}
function themeable(Component, staticConfig) {
  var optimize = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, withThemeComponent = /* @__PURE__ */ React.forwardRef(function(props, ref) {
    var _a = props, {
      themeInverse,
      theme,
      componentName,
      themeReset
    } = _a, rest = __objRest(_a, [
      "themeInverse",
      "theme",
      "componentName",
      "themeReset"
    ]), overriddenContextProps, context = staticConfig == null ? void 0 : staticConfig.context;
    if (context) for (var key in context.props) {
      var val = props[key];
      val !== void 0 && (overriddenContextProps || (overriddenContextProps = {}), overriddenContextProps[key] = val);
    }
    var element = (
      // @ts-expect-error its ok
      /* @__PURE__ */ jsxRuntimeExports.jsx(Component, __spreadProps(__spreadValues({
        ref
      }, rest), {
        "data-disable-theme": true
      }))
    ), filteredProps = null, compName = componentName || (staticConfig == null ? void 0 : staticConfig.componentName);
    if (compName && (filteredProps || (filteredProps = {}), filteredProps.componentName = compName), "debug" in props && (filteredProps || (filteredProps = {}), filteredProps.debug = props.debug), "theme" in props && (filteredProps || (filteredProps = {}), filteredProps.name = props.theme), "themeInverse" in props && (filteredProps || (filteredProps = {}), filteredProps.inverse = props.themeInverse), "themeReset" in props && (filteredProps || (filteredProps = {}), filteredProps.reset = themeReset), optimize && !filteredProps) return element;
    var contents = /* @__PURE__ */ jsxRuntimeExports.jsx(Theme, __spreadProps(__spreadValues({
      "disable-child-theme": true
    }, filteredProps), {
      children: element
    }));
    if (context) {
      var Provider = context.Provider, contextValue = React.useContext(context);
      contents = /* @__PURE__ */ jsxRuntimeExports.jsx(Provider, __spreadProps(__spreadValues(__spreadValues({}, contextValue), overriddenContextProps), {
        children: contents
      }));
    }
    return contents;
  }), withTheme = withThemeComponent;
  return withTheme.displayName = `Themed(${(Component == null ? void 0 : Component.displayName) || (Component == null ? void 0 : Component.name) || "Anonymous"})`, withTheme;
}
function getStyleTags(styles) {
}
var ClientOnlyContext = /* @__PURE__ */ React.createContext(false), ClientOnly = function(param) {
  var {
    children,
    enabled
  } = param, existingValue = React.useContext(ClientOnlyContext);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ClientOnlyContext.Provider, {
    value: enabled != null ? enabled : existingValue,
    children
  });
};
var useIsClientOnly = function() {
  return React__namespace.useContext(ClientOnlyContext);
};
function useDidFinishSSR() {
  React__namespace.useContext(ClientOnlyContext);
  return true;
}
function useClientValue(value) {
  useDidFinishSSR();
  return typeof value == "function" ? value() : value;
}
function _type_of$1(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var useComponentState = function(props, animationDriver, staticConfig, config) {
  var _animationDriver_usePresence, isHydrated = useDidFinishSSR(), needsHydration = !useIsClientOnly(), useAnimations = animationDriver == null ? void 0 : animationDriver.useAnimations, {
    isHOC
  } = staticConfig, stateRef = React.useRef(
    // performance: avoid creating object every render
    void 0
  );
  stateRef.current || (stateRef.current = {
    startedUnhydrated: needsHydration && !isHydrated
  });
  var hasAnimationProp = !!(!isHOC && "animation" in props || props.style && hasAnimatedStyleValue(props.style)), supportsCSS = animationDriver == null ? void 0 : animationDriver.supportsCSS, curStateRef = stateRef.current;
  !needsHydration && hasAnimationProp && (curStateRef.hasAnimated = true);
  var willBeAnimatedClient = (function() {
    var next = !!(hasAnimationProp && !isHOC && useAnimations);
    return !!(next || curStateRef.hasAnimated);
  })(), willBeAnimated = willBeAnimatedClient;
  willBeAnimated && !curStateRef.hasAnimated && (curStateRef.hasAnimated = true);
  var {
    disableClassName
  } = props, presence = !isHOC && willBeAnimated && props.animatePresence !== false && (animationDriver == null || (_animationDriver_usePresence = animationDriver.usePresence) === null || _animationDriver_usePresence === void 0 ? void 0 : _animationDriver_usePresence.call(animationDriver)) || null, presenceState = presence == null ? void 0 : presence[2], isExiting = (presenceState == null ? void 0 : presenceState.isPresent) === false, isEntering = (presenceState == null ? void 0 : presenceState.isPresent) === true && presenceState.initial !== false, hasEnterStyle = !!props.enterStyle, hasAnimationThatNeedsHydrate = hasAnimationProp && !isHydrated, canImmediatelyEnter = hasEnterStyle || isEntering, shouldEnter = !isHOC && (hasEnterStyle || isEntering || hasAnimationThatNeedsHydrate || // disableClassName doesnt work server side, only client, so needs hydrate
  // this is just for a better ux, supports css variables for light/dark, media queries, etc
  disableClassName), initialState = shouldEnter ? (
    // on the very first render we switch all spring animation drivers to css rendering
    // this is because we need to use css variables, which they don't support to do proper SSR
    // without flickers of the wrong colors.
    // but once we do that initial hydration and we are in client side rendering mode,
    // we can avoid the extra re-render on mount
    canImmediatelyEnter ? defaultComponentStateShouldEnter : defaultComponentState
  ) : defaultComponentStateMounted, disabled = isDisabled(props);
  disabled != null && (initialState.disabled = disabled);
  var states2 = React.useState(initialState), state = props.forceStyle ? __spreadProps(__spreadValues({}, states2[0]), {
    [props.forceStyle]: true
  }) : states2[0], setState = states2[1], isAnimated = willBeAnimated;
  disabled !== state.disabled && (disabled && Object.assign(state, defaultComponentStateMounted), state.disabled = disabled, setState(function(_) {
    return __spreadValues({}, state);
  }));
  var groupName = props.group, setStateShallow = useCreateShallowSetState(setState, props.debug);
  if (presenceState && isAnimated && isHydrated && staticConfig.variants) {
    var {
      enterVariant,
      exitVariant,
      enterExitVariant,
      custom
    } = presenceState;
    isObj(custom) && Object.assign(props, custom);
    var exv = exitVariant != null ? exitVariant : enterExitVariant, env = enterVariant != null ? enterVariant : enterExitVariant;
    state.unmounted && env && staticConfig.variants[env] ? props[env] = true : isExiting && exv && (props[exv] = exitVariant !== enterExitVariant);
  }
  var noClass = !isWeb;
  return {
    startedUnhydrated: curStateRef.startedUnhydrated,
    curStateRef,
    disabled,
    groupName,
    hasAnimationProp,
    hasEnterStyle,
    isAnimated,
    isExiting,
    isHydrated,
    presence,
    presenceState,
    setState,
    setStateShallow,
    noClass,
    state,
    stateRef,
    supportsCSS,
    willBeAnimated,
    willBeAnimatedClient
  };
};
function hasAnimatedStyleValue(style) {
  return Object.keys(style).some(function(k) {
    var val = style[k];
    return val && (typeof val > "u" ? "undefined" : _type_of$1(val)) === "object" && "_animation" in val;
  });
}
var isDisabled = function(props) {
  var _props_accessibilityState;
  return props.disabled || props.passThrough || ((_props_accessibilityState = props.accessibilityState) === null || _props_accessibilityState === void 0 ? void 0 : _props_accessibilityState.disabled) || props["aria-disabled"] || props.accessibilityDisabled || false;
};
var hooks = {};
function setupHooks(next) {
  Object.assign(hooks, next);
}
var is19 = React.version.startsWith("19."), Slot = /* @__PURE__ */ React.memo(/* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    children
  } = _a, slotProps = __objRest(_a, [
    "children"
  ]);
  if (/* @__PURE__ */ React.isValidElement(children)) {
    var mergedProps = mergeSlotProps(children, slotProps);
    return /* @__PURE__ */ React.cloneElement(children, children.type.avoidForwardRef ? mergedProps : __spreadProps(__spreadValues({}, mergedProps), {
      ref: composeRefs(forwardedRef, is19 ? children.props.ref : children.ref)
    }));
  }
  return React.Children.count(children) > 1 ? React.Children.only(null) : null;
})), Slottable = function(param) {
  var {
    children
  } = param;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children
  });
};
Slottable.displayName = "Slottable";
var pressMap = {};
function mergeSlotProps(child, slotProps) {
  var childProps = child.props, overrideProps = __spreadValues({}, childProps), isHTMLChild = typeof child.type == "string";
  if (isHTMLChild) for (var key in pressMap) key in slotProps && (slotProps[pressMap[key]] = slotProps[key], delete slotProps[key]);
  for (var propName in childProps) {
    var slotPropValue = slotProps[propName], childPropValue = childProps[propName];
    isHTMLChild && propName in pressMap && (propName = pressMap[propName], delete overrideProps[propName]);
    var isHandler = handleRegex.test(propName);
    isHandler ? overrideProps[propName] = composeEventHandlers(childPropValue, slotPropValue) : propName === "style" ? overrideProps[propName] = __spreadValues(__spreadValues({}, slotPropValue), childPropValue) : propName === "className" && (overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" "));
  }
  return __spreadValues(__spreadValues({}, slotProps), overrideProps);
}
var handleRegex = /^on[A-Z]/;
var componentSetStates = /* @__PURE__ */ new Set(), avoidReRenderKeys = /* @__PURE__ */ new Set(["hover", "press", "pressIn", "group", "focus", "focusWithin", "media", "group"]);
var BaseText, BaseView, hasSetupBaseViews = false, lastInteractionWasKeyboard = {
  value: false
};
function createComponent(staticConfig) {
  var {
    componentName
  } = staticConfig, config = null, defaultProps = staticConfig.defaultProps;
  onConfiguredOnce(function(conf2) {
    if (config = conf2, componentName) {
      var _conf_defaultProps, defaultForComponent = (_conf_defaultProps = conf2.defaultProps) === null || _conf_defaultProps === void 0 ? void 0 : _conf_defaultProps[componentName];
      defaultForComponent && (defaultProps = __spreadValues(__spreadValues({}, defaultForComponent), defaultProps));
    }
  });
  var {
    Component,
    isText,
    isZStack,
    isHOC
  } = staticConfig;
  var component = /* @__PURE__ */ React.forwardRef(function(propsIn, forwardedRef) {
    var _hooks_usePropsTransform, _hooks_useEvents, _config_animations;
    if (!hasSetupBaseViews) {
      var _hooks_getBaseViews;
      hasSetupBaseViews = true;
      var baseViews2 = (_hooks_getBaseViews = hooks.getBaseViews) === null || _hooks_getBaseViews === void 0 ? void 0 : _hooks_getBaseViews.call(hooks);
      baseViews2 && (BaseText = baseViews2.Text, BaseView = baseViews2.View);
    }
    var {
      context,
      isReactNative
    } = staticConfig, debugProp = propsIn.debug, styledContextValue = context ? React.useContext(context) : void 0, overriddenContextProps = null;
    var props = propsIn;
    if (styledContextValue || defaultProps) {
      var [nextProps, overrides] = mergeComponentProps(defaultProps, styledContextValue, propsIn);
      nextProps && (props = nextProps), overriddenContextProps = overrides;
    }
    var componentName2 = props.componentName || staticConfig.componentName;
    var componentContext = React.useContext(ComponentContext), groupContextParent = React.useContext(GroupContext), animationDriver = componentContext.animationDriver, useAnimations = animationDriver == null ? void 0 : animationDriver.useAnimations, componentState = useComponentState(props, animationDriver, staticConfig), {
      disabled,
      groupName,
      hasAnimationProp,
      hasEnterStyle,
      isAnimated,
      isExiting,
      isHydrated,
      presence,
      presenceState,
      setState,
      noClass,
      state,
      stateRef,
      supportsCSS,
      willBeAnimated,
      willBeAnimatedClient,
      startedUnhydrated
    } = componentState;
    hasAnimationProp && (animationDriver == null ? void 0 : animationDriver.avoidReRenders) && useIsomorphicLayoutEffect(function() {
      var pendingState = stateRef.current.nextState;
      pendingState && (stateRef.current.nextState = void 0, componentState.setStateShallow(pendingState));
    });
    var allGroupContexts = React.useMemo(function() {
      var _stateRef_current_group_listeners, _stateRef_current_group;
      if (!groupName || props.passThrough) return groupContextParent;
      var listeners2 = /* @__PURE__ */ new Set();
      return (_stateRef_current_group = stateRef.current.group) === null || _stateRef_current_group === void 0 || (_stateRef_current_group_listeners = _stateRef_current_group.listeners) === null || _stateRef_current_group_listeners === void 0 || _stateRef_current_group_listeners.clear(), stateRef.current.group = {
        listeners: listeners2,
        emit(state2) {
          listeners2.forEach(function(l) {
            return l(state2);
          });
        },
        subscribe(cb) {
          return listeners2.add(cb), listeners2.size === 1 && setStateShallow({
            hasDynGroupChildren: true
          }), function() {
            listeners2.delete(cb), listeners2.size === 0 && setStateShallow({
              hasDynGroupChildren: false
            });
          };
        }
      }, __spreadProps(__spreadValues({}, groupContextParent), {
        [groupName]: {
          state: {
            pseudo: defaultComponentStateMounted
          },
          subscribe: function(listener) {
            var _stateRef_current_group2, dispose2 = (_stateRef_current_group2 = stateRef.current.group) === null || _stateRef_current_group2 === void 0 ? void 0 : _stateRef_current_group2.subscribe(listener);
            return function() {
              dispose2 == null ? void 0 : dispose2();
            };
          }
        }
      });
    }, [stateRef, groupName, groupContextParent]), setStateShallow = componentState.setStateShallow;
    var isTaggable = !Component || typeof Component == "string", tagProp = props.tag, element = Component, BaseTextComponent = BaseText || element || "span", BaseViewComponent = BaseView || element || "div", elementType = isText ? BaseTextComponent : BaseViewComponent;
    animationDriver && isAnimated && // this should really be behind another prop as it's not really related to
    // "needsWebStyles" basically with motion we just animate a plain div, but
    // we still have animated.View/Text for Sheet which wants to control
    // things declaratively
    !animationDriver.needsWebStyles && (elementType = animationDriver[isText ? "Text" : "View"] || elementType);
    var disableTheme = isHOC;
    props.themeShallow && (stateRef.current.themeShallow = true);
    var themeStateProps = {
      componentName: componentName2,
      disable: disableTheme,
      shallow: stateRef.current.themeShallow,
      debug: debugProp
    };
    if ("themeInverse" in props && (themeStateProps.inverse = props.themeInverse), "theme" in props && (themeStateProps.name = props.theme), typeof stateRef.current.isListeningToTheme == "boolean" && (themeStateProps.needsUpdate = function() {
      return !!stateRef.current.isListeningToTheme;
    }), themeStateProps.deopt = willBeAnimated, false) ;
    var [theme, themeState] = useThemeWithState(themeStateProps);
    elementType = Component || elementType;
    var mediaState = useMedia(componentContext);
    setDidGetVariableValue(false);
    var resolveValues = (
      // if HOC + mounted + has animation prop, resolve as value so it passes non-variable to child
      isAnimated && !supportsCSS || isHOC && state.unmounted == false && hasAnimationProp ? "value" : "auto"
    ), styleProps = {
      mediaState,
      noClass,
      resolveValues,
      isExiting,
      isAnimated,
      willBeAnimated,
      styledContext: styledContextValue
    }, themeName = (themeState == null ? void 0 : themeState.name) || "";
    var splitStyles = useSplitStyles(props, staticConfig, theme, themeName, state, styleProps, null, componentContext, allGroupContexts, elementType, startedUnhydrated, debugProp), isPassthrough = !splitStyles, groupContext = groupName && (allGroupContexts == null ? void 0 : allGroupContexts[groupName]) || null;
    if (!isPassthrough && groupContext && // avoids onLayout if we don't need it
    props.containerType !== "normal") {
      var groupState = groupContext == null ? void 0 : groupContext.state;
      if (groupState && groupState.layout === void 0) {
        var _splitStyles_style, _splitStyles_style1;
        (!((_splitStyles_style = splitStyles.style) === null || _splitStyles_style === void 0) && _splitStyles_style.width || !((_splitStyles_style1 = splitStyles.style) === null || _splitStyles_style1 === void 0) && _splitStyles_style1.height) && (groupState.layout = {
          width: fromPx(splitStyles.style.width),
          height: fromPx(splitStyles.style.height)
        });
      }
    }
    if (!isPassthrough && (hasAnimationProp || groupName) && (animationDriver == null ? void 0 : animationDriver.avoidReRenders)) {
      let updateGroupListeners2 = function() {
        var updatedState = stateRef.current.nextState;
        if (groupContext) {
          var _a2 = updatedState, {
            group,
            hasDynGroupChildren,
            unmounted,
            animation
          } = _a2, childrenGroupState = __objRest(_a2, [
            "group",
            "hasDynGroupChildren",
            "unmounted",
            "animation"
          ]);
          notifyGroupSubscribers(groupContext, stateRef.current.group || null, childrenGroupState);
        }
      };
      var _componentContext, ogSetStateShallow = setStateShallow;
      stateRef.current.updateStyleListener = function() {
        var updatedState = stateRef.current.nextState || state, mediaState2 = stateRef.current.nextMedia, nextStyles = getSplitStyles(props, staticConfig, theme, themeName, updatedState, mediaState2 ? __spreadProps(__spreadValues({}, styleProps), {
          mediaState: mediaState2
        }) : styleProps, null, componentContext, allGroupContexts, elementType, startedUnhydrated, debugProp), useStyleListener = stateRef.current.useStyleListener;
        useStyleListener == null ? void 0 : useStyleListener((nextStyles == null ? void 0 : nextStyles.style) || {});
      }, (_componentContext = componentContext).mediaEmit || (_componentContext.mediaEmit = function(next) {
        var _stateRef_current_updateStyleListener, _stateRef_current;
        stateRef.current.nextMedia = next, (_stateRef_current_updateStyleListener = (_stateRef_current = stateRef.current).updateStyleListener) === null || _stateRef_current_updateStyleListener === void 0 || _stateRef_current_updateStyleListener.call(_stateRef_current);
      }), stateRef.current.setStateShallow = function(nextOrGetNext) {
        var prev = stateRef.current.nextState || state, next = typeof nextOrGetNext == "function" ? nextOrGetNext(prev) : nextOrGetNext;
        if (!(next === prev || isEqualShallow(prev, next))) {
          var canAvoidReRender = Object.keys(next).every(function(key2) {
            return avoidReRenderKeys.has(key2);
          }), updatedState = __spreadValues(__spreadValues({}, prev), next);
          if (stateRef.current.nextState = updatedState, canAvoidReRender) {
            var _stateRef_current_updateStyleListener, _stateRef_current;
            updateGroupListeners2(), (_stateRef_current_updateStyleListener = (_stateRef_current = stateRef.current).updateStyleListener) === null || _stateRef_current_updateStyleListener === void 0 || _stateRef_current_updateStyleListener.call(_stateRef_current);
          } else ogSetStateShallow(next);
        }
      }, setStateShallow = function(state2) {
        var _stateRef_current_setStateShallow, _stateRef_current;
        (_stateRef_current_setStateShallow = (_stateRef_current = stateRef.current).setStateShallow) === null || _stateRef_current_setStateShallow === void 0 || _stateRef_current_setStateShallow.call(_stateRef_current, state2);
      };
    }
    if (splitStyles) {
      if (props.group && props.untilMeasured === "hide" && !stateRef.current.hasMeasured) {
        var _splitStyles;
        (_splitStyles = splitStyles).style || (_splitStyles.style = {}), splitStyles.style.opacity = 0;
      }
      splitStyles.dynamicThemeAccess != null && (stateRef.current.isListeningToTheme = splitStyles.dynamicThemeAccess);
    }
    var hasRuntimeMediaKeys = (splitStyles == null ? void 0 : splitStyles.hasMedia) && splitStyles.hasMedia !== true, shouldListenForMedia = didGetVariableValue() || hasRuntimeMediaKeys || noClass && (splitStyles == null ? void 0 : splitStyles.hasMedia) === true, mediaListeningKeys = hasRuntimeMediaKeys ? splitStyles.hasMedia : null;
    setMediaShouldUpdate(componentContext, shouldListenForMedia, mediaListeningKeys);
    var {
      viewProps: viewPropsIn,
      pseudos,
      style: splitStylesStyle,
      classNames,
      space,
      pseudoGroups,
      mediaGroups
    } = splitStyles || {}, propsWithAnimation = props, _a = viewPropsIn || {}, {
      asChild,
      children,
      themeShallow,
      spaceDirection: _spaceDirection,
      onPress,
      onLongPress,
      onPressIn,
      onPressOut,
      onHoverIn,
      onHoverOut,
      onMouseUp,
      onMouseDown,
      onMouseEnter,
      onMouseLeave,
      onFocus,
      onBlur,
      separator,
      passThrough: passThrough,
      forceStyle: _forceStyle,
      onClick: onClick,
      theme: _themeProp
    } = _a, nonTamaguiProps = __objRest(_a, [
      "asChild",
      "children",
      "themeShallow",
      "spaceDirection",
      "onPress",
      "onLongPress",
      "onPressIn",
      "onPressOut",
      "onHoverIn",
      "onHoverOut",
      "onMouseUp",
      "onMouseDown",
      "onMouseEnter",
      "onMouseLeave",
      "onFocus",
      "onBlur",
      "separator",
      // ignore from here on out
      "passThrough",
      "forceStyle",
      // @ts-ignore  for next/link compat etc
      "onClick",
      "theme"
    ]), viewProps = nonTamaguiProps;
    !isTaggable && props.forceStyle && (viewProps.forceStyle = props.forceStyle), isHOC && (typeof _themeProp < "u" && (viewProps.theme = _themeProp), typeof passThrough < "u" && (viewProps.passThrough = passThrough)), tagProp && elementType.acceptTagProp && (viewProps.tag = tagProp);
    var animationStyles, shouldUseAnimation = (
      // if it supports css vars we run it on server too to get matching initial style
      (supportsCSS ? willBeAnimatedClient : willBeAnimated) && useAnimations && !isHOC
    ), animatedRef;
    if (shouldUseAnimation) {
      var useStyleEmitter = (animationDriver == null ? void 0 : animationDriver.avoidReRenders) ? function(listener) {
        stateRef.current.useStyleListener = listener;
      } : void 0, animations = useAnimations({
        props: propsWithAnimation,
        // if hydrating, send empty style
        style: splitStylesStyle || {},
        // @ts-ignore
        styleState: splitStyles,
        useStyleEmitter,
        presence,
        componentState: state,
        styleProps,
        theme,
        pseudos: pseudos || null,
        staticConfig,
        stateRef
      });
      animations && (animations.ref && (animatedRef = animations.ref), isHydrated && animations && (animationStyles = animations.style, viewProps.style = animationStyles, animations.className && (viewProps.className = `${state.unmounted === "should-enter" ? "t_unmounted " : ""}${viewProps.className || ""} ${animations.className}`)));
    }
    !isPassthrough && groupContext && // avoids onLayout if we don't need it
    props.containerType !== "normal" && (nonTamaguiProps.onLayout = composeEventHandlers(nonTamaguiProps.onLayout, function(e2) {
      var _stateRef_current_group, layout = e2.nativeEvent.layout;
      groupContext.state.layout = layout, (_stateRef_current_group = stateRef.current.group) === null || _stateRef_current_group === void 0 || _stateRef_current_group.emit({
        layout
      }), !stateRef.current.hasMeasured && props.untilMeasured === "hide" && setState(function(prev) {
        return __spreadValues({}, prev);
      }), stateRef.current.hasMeasured = true;
    })), viewProps = ((_hooks_usePropsTransform = hooks.usePropsTransform) === null || _hooks_usePropsTransform === void 0 ? void 0 : _hooks_usePropsTransform.call(hooks, elementType, nonTamaguiProps, stateRef, stateRef.current.willHydrate)) || nonTamaguiProps, stateRef.current.composedRef || (stateRef.current.composedRef = composeRefs(function(x) {
      return stateRef.current.host = x;
    }, forwardedRef, setElementProps, animatedRef)), viewProps.ref = stateRef.current.composedRef;
    var unPress = function() {
      setStateShallow({
        press: false,
        pressIn: false
      });
    };
    useIsomorphicLayoutEffect(function() {
      if (state.unmounted === true && hasEnterStyle) {
        setStateShallow({
          unmounted: "should-enter"
        });
        return;
      }
      var tm;
      if (state.unmounted) {
        if ((animationDriver == null ? void 0 : animationDriver.supportsCSS) || isAndroid) return tm = setTimeout(function() {
          setStateShallow({
            unmounted: false
          });
        }), function() {
          return clearTimeout(tm);
        };
        setStateShallow({
          unmounted: false
        });
        return;
      }
      return function() {
        componentSetStates.delete(setState);
      };
    }, [state.unmounted, disabled]), useIsomorphicLayoutEffect(function() {
      if (!disabled && !(!pseudoGroups && !mediaGroups) && allGroupContexts) return subscribeToContextGroup({
        groupContext: allGroupContexts,
        setStateShallow,
        mediaGroups,
        pseudoGroups
      });
    }, [allGroupContexts, disabled, pseudoGroups ? objectIdentityKey(pseudoGroups) : 0, mediaGroups ? objectIdentityKey(mediaGroups) : 0]);
    var groupEmitter = stateRef.current.group;
    useIsomorphicLayoutEffect(function() {
      !groupContext || !groupEmitter || notifyGroupSubscribers(groupContext, groupEmitter, state);
    }, [groupContext, groupEmitter, state]);
    var runtimePressStyle = !disabled && noClass && (pseudos == null ? void 0 : pseudos.pressStyle), runtimeFocusStyle = !disabled && noClass && (pseudos == null ? void 0 : pseudos.focusStyle), runtimeFocusVisibleStyle = !disabled && noClass && (pseudos == null ? void 0 : pseudos.focusVisibleStyle), attachFocus = !!(runtimePressStyle || runtimeFocusStyle || runtimeFocusVisibleStyle || onFocus || onBlur || componentContext.setParentFocusState), hasDynamicGroupChildren = !!(groupName && state.hasDynGroupChildren), attachPress = !!(hasDynamicGroupChildren || runtimePressStyle || onPress || onPressOut || onPressIn || onMouseDown || onMouseUp || onLongPress || onClick || (pseudos == null ? void 0 : pseudos.focusVisibleStyle)), runtimeHoverStyle = !disabled && noClass && (pseudos == null ? void 0 : pseudos.hoverStyle), needsHoverState = !!(hasDynamicGroupChildren || runtimeHoverStyle), attachHover = isWeb, shouldAttach = !disabled && !props.asChild && !!(attachFocus || attachPress || attachHover || runtimePressStyle || runtimeHoverStyle || runtimeFocusStyle), needsPressState = !!(hasDynamicGroupChildren || runtimePressStyle);
    var events = shouldAttach ? __spreadValues(__spreadValues(__spreadProps(__spreadValues({
      onPressOut: attachPress ? function(e2) {
        unPress(), onPressOut == null ? void 0 : onPressOut(e2), onMouseUp == null ? void 0 : onMouseUp(e2);
      } : void 0
    }, attachPress && {
      onMouseEnter: function(e2) {
        var next = {};
        needsHoverState && (next.hover = true), needsPressState && state.pressIn && (next.press = true), setStateShallow(next), onHoverIn == null ? void 0 : onHoverIn(e2), onMouseEnter == null ? void 0 : onMouseEnter(e2);
      },
      onMouseLeave: function(e2) {
        var next = {};
        needsHoverState && (next.hover = false), needsPressState && (next.press = false, next.pressIn = false), setStateShallow(next), onHoverOut == null ? void 0 : onHoverOut(e2), onMouseLeave == null ? void 0 : onMouseLeave(e2);
      }
    }), {
      onPressIn: attachPress ? function(e2) {
        needsPressState && setStateShallow({
          press: true,
          pressIn: true
        }), onPressIn == null ? void 0 : onPressIn(e2), onMouseDown == null ? void 0 : onMouseDown(e2);
      } : void 0,
      onPress: attachPress ? function(e2) {
        unPress(), onPress == null ? void 0 : onPress(e2);
      } : void 0
    }), attachPress && onLongPress && {
      onLongPress: function(e2) {
        unPress(), onLongPress == null ? void 0 : onLongPress(e2);
      }
    }), attachFocus && {
      onFocus: function(e2) {
        var next = {};
        componentContext.setParentFocusState && (next.focusWithin = true), (pseudos == null ? void 0 : pseudos.focusVisibleStyle) && lastInteractionWasKeyboard.value ? next.focusVisible = true : next.focus = true, setStateShallow(next), onFocus == null ? void 0 : onFocus(e2);
      },
      onBlur: function(e2) {
        componentContext.setParentFocusState && componentContext.setParentFocusState({
          focusWithin: false
        }), setStateShallow({
          focus: false,
          focusVisible: false,
          focusWithin: false
        }), onBlur == null ? void 0 : onBlur(e2);
      }
    }) : null;
    if (events && !asChild) {
      var _viewProps_focusable;
      Object.assign(events, {
        cancelable: !viewProps.rejectResponderTermination,
        disabled,
        hitSlop: viewProps.hitSlop,
        delayLongPress: viewProps.delayLongPress,
        delayPressIn: viewProps.delayPressIn,
        delayPressOut: viewProps.delayPressOut,
        focusable: (_viewProps_focusable = viewProps.focusable) !== null && _viewProps_focusable !== void 0 ? _viewProps_focusable : true,
        minPressDuration: 0
      });
    }
    (_hooks_useEvents = hooks.useEvents) === null || _hooks_useEvents === void 0 || _hooks_useEvents.call(hooks, viewProps, events, splitStyles, setStateShallow, staticConfig);
    var direction = props.spaceDirection || "both";
    var content = !children || asChild || !splitStyles ? children : spacedChildren({
      separator,
      children,
      space,
      direction,
      isZStack
    });
    if (asChild) if (elementType = Slot, 0) ;
    else Object.assign(viewProps, {
      onPress,
      onLongPress
    });
    isPassthrough && (content = propsIn.children, elementType = BaseViewComponent, viewProps = {
      style: {
        display: "contents"
      }
    });
    var useChildrenResult;
    hooks.useChildren && (useChildrenResult = hooks.useChildren(elementType, content, viewProps)), useChildrenResult ? content = useChildrenResult : content = /* @__PURE__ */ React.createElement(elementType, viewProps, content);
    var ResetPresence = config == null || (_config_animations = config.animations) === null || _config_animations === void 0 ? void 0 : _config_animations.ResetPresence, needsReset = !!// not when passing down to child
    (!asChild && // not when passThrough
    splitStyles && // not when HOC
    !isHOC && ResetPresence && willBeAnimated && (hasEnterStyle || presenceState)), hasEverReset = stateRef.current.hasEverResetPresence;
    needsReset && !hasEverReset && (stateRef.current.hasEverResetPresence = true);
    var renderReset = needsReset || hasEverReset;
    if (renderReset && ResetPresence && (content = /* @__PURE__ */ jsxRuntimeExports.jsx(ResetPresence, {
      disabled: !needsReset,
      children: content
    })), "focusWithinStyle" in propsIn && (content = /* @__PURE__ */ jsxRuntimeExports.jsx(ComponentContext.Provider, __spreadProps(__spreadValues({}, componentContext), {
      setParentFocusState: setStateShallow,
      children: content
    }))), "group" in props && (content = /* @__PURE__ */ jsxRuntimeExports.jsx(GroupContext.Provider, {
      value: allGroupContexts,
      children: content
    })), content = disableTheme || !splitStyles ? content : getThemedChildren(themeState, content, themeStateProps, false, stateRef), overriddenContextProps) {
      var Provider = staticConfig.context.Provider;
      for (var key in styledContextValue) key in overriddenContextProps || (overriddenContextProps[key] = styledContextValue[key]);
      debugProp && console.info("overriddenContextProps", overriddenContextProps), content = /* @__PURE__ */ jsxRuntimeExports.jsx(Provider, __spreadProps(__spreadValues({
        __disableMergeDefaultValues: true
      }, overriddenContextProps), {
        children: content
      }));
    }
    return content;
  });
  function notifyGroupSubscribers(groupContext, groupEmitter, pseudo) {
    if (!(!groupContext || !groupEmitter)) {
      var nextState = __spreadProps(__spreadValues({}, groupContext.state), {
        pseudo
      });
      groupEmitter.emit(nextState), groupContext.state = nextState;
    }
  }
  staticConfig.componentName && (component.displayName = staticConfig.componentName);
  var res = component;
  (process.env.TAMAGUI_FORCE_MEMO || staticConfig.memo) && (res = /* @__PURE__ */ React.memo(res)), res.staticConfig = staticConfig;
  function extendStyledConfig(extended) {
    return __spreadProps(__spreadValues(__spreadValues({}, staticConfig), extended), {
      neverFlatten: true,
      isHOC: true,
      isStyledHOC: false
    });
  }
  function extractable(Component2, extended) {
    return Component2.staticConfig = extendStyledConfig(extended), Component2.styleable = styleable, Component2;
  }
  function styleable(Component2, options) {
    var _Component_render, skipForwardRef = IS_REACT_19 && typeof Component2 == "function" && Component2.length === 1 || ((_Component_render = Component2.render) === null || _Component_render === void 0 ? void 0 : _Component_render.length) === 2, out = skipForwardRef ? Component2 : /* @__PURE__ */ React.forwardRef(Component2), extendedConfig = extendStyledConfig(options == null ? void 0 : options.staticConfig);
    return out = (options == null ? void 0 : options.disableTheme) ? out : themeable(out, extendedConfig, true), (extendedConfig.memo || process.env.TAMAGUI_MEMOIZE_STYLEABLE) && (out = /* @__PURE__ */ React.memo(out)), out.staticConfig = extendedConfig, out.styleable = styleable, out;
  }
  return res.extractable = extractable, res.styleable = styleable, res;
}
function Unspaced(props) {
  return props.children;
}
Unspaced.isUnspaced = true;
var getSpacerSize = function(size, param) {
  var {
    tokens
  } = param;
  size = size === false ? 0 : size === true ? "$true" : size;
  var _tokens_space_size, sizePx = (_tokens_space_size = tokens.space[size]) !== null && _tokens_space_size !== void 0 ? _tokens_space_size : size;
  return {
    width: sizePx,
    height: sizePx,
    minWidth: sizePx,
    minHeight: sizePx
  };
}, Spacer = createComponent({
  acceptsClassName: true,
  memo: true,
  componentName: "Spacer",
  validStyles,
  defaultProps: __spreadProps(__spreadValues({}, stackDefaultStyles), {
    // avoid nesting issues
    tag: "span",
    size: true,
    pointerEvents: "none"
  }),
  variants: {
    size: {
      "...": getSpacerSize
    },
    flex: {
      true: {
        flexGrow: 1
      }
    },
    direction: {
      horizontal: {
        height: 0,
        minHeight: 0
      },
      vertical: {
        width: 0,
        minWidth: 0
      },
      both: {}
    }
  }
});
function spacedChildren(props) {
  var _childrenList__type, _childrenList_, {
    isZStack,
    children,
    space,
    direction,
    spaceFlex,
    separator,
    ensureKeys
  } = props, hasSpace = !!(space || spaceFlex), hasSeparator = separator != null, areChildrenArray = Array.isArray(children);
  if (!ensureKeys && !(hasSpace || hasSeparator || isZStack)) return children;
  var childrenList = areChildrenArray ? children : React.Children.toArray(children), len = childrenList.length;
  if (len <= 1 && !isZStack && !(!((_childrenList_ = childrenList[0]) === null || _childrenList_ === void 0 || (_childrenList__type = _childrenList_.type) === null || _childrenList__type === void 0) && _childrenList__type.shouldForwardSpace)) return children;
  var final = [], _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
  try {
    for (var _iterator = childrenList.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var [index2, child] = _step.value, _child_type, isEmpty = child == null || Array.isArray(child) && child.length === 0;
      if (!isEmpty && /* @__PURE__ */ React.isValidElement(child) && !((_child_type = child.type) === null || _child_type === void 0) && _child_type.shouldForwardSpace && (child = /* @__PURE__ */ React.cloneElement(child, {
        // @ts-expect-error we explicitly know with shouldForwardSpace
        space,
        spaceFlex,
        separator,
        key: child.key
      })), isEmpty || !child || child.key && !isZStack ? final.push(child) : final.push(/* @__PURE__ */ jsxRuntimeExports.jsx(React.Fragment, {
        children: isZStack ? /* @__PURE__ */ jsxRuntimeExports.jsx(AbsoluteFill, {
          children: child
        }) : child
      }, `${index2}0t`)), !(isUnspaced(child) && index2 === 0) && !isZStack) {
        var next = childrenList[index2 + 1];
        next && !isEmpty && !isUnspaced(next) && (separator ? (hasSpace && final.push(createSpacer({
          key: `_${index2}_00t`,
          direction,
          space,
          spaceFlex
        })), final.push(/* @__PURE__ */ jsxRuntimeExports.jsx(React.Fragment, {
          children: separator
        }, `${index2}03t`)), hasSpace && final.push(createSpacer({
          key: `_${index2}01t`,
          direction,
          space,
          spaceFlex
        }))) : final.push(createSpacer({
          key: `_${index2}02t`,
          direction,
          space,
          spaceFlex
        })));
      }
    }
  } catch (err) {
    _didIteratorError = true, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError) throw _iteratorError;
    }
  }
  return final;
}
function createSpacer(param) {
  var {
    key,
    direction,
    space,
    spaceFlex
  } = param;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, __spreadValues({
    size: space,
    direction
  }, typeof spaceFlex < "u" && {
    flex: spaceFlex === true ? 1 : spaceFlex === false ? 0 : spaceFlex
  }), key);
}
function isUnspaced(child) {
  var t2 = child == null ? void 0 : child.type;
  return (t2 == null ? void 0 : t2.isVisuallyHidden) || (t2 == null ? void 0 : t2.isUnspaced);
}
var AbsoluteFill = createComponent({
  defaultProps: __spreadProps(__spreadValues({}, stackDefaultStyles), {
    flexDirection: "column",
    position: "absolute",
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    pointerEvents: "box-none"
  })
}), fromPx = function(val) {
  return typeof val == "number" ? val : typeof val == "string" ? +val.replace("px", "") : 0;
};
function getExpandedShorthands(props) {
  var shorthands = getConfig().shorthands;
  if (!shorthands) return props;
  var res = {};
  for (var key in props) res[shorthands[key] || key] = props[key];
  return res;
}
function getExpandedShorthand(propKey, props) {
  var shorthands = getConfig().inverseShorthands, _props_propKey;
  return (_props_propKey = props[propKey]) !== null && _props_propKey !== void 0 ? _props_propKey : props[shorthands[propKey]];
}
var inverseShorthands = null, getShorthandValue = function(props, key) {
  inverseShorthands || (inverseShorthands = getConfig().inverseShorthands);
  var _props_key;
  return (_props_key = props[key]) !== null && _props_key !== void 0 ? _props_key : inverseShorthands ? props[inverseShorthands[key]] : void 0;
};
function getThemeCSSRules() {
  return [];
}
function isTamaguiComponent(comp, name) {
  var config = comp == null ? void 0 : comp.staticConfig;
  return !!(config && (!name || name === config.componentName));
}
var isTamaguiElement = function(child, name) {
  return /* @__PURE__ */ React.isValidElement(child) && isTamaguiComponent(child.type, name);
};
var themesRaw = {};
function proxyThemesToParents(dedupedThemes) {
  var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
  try {
    for (var _iterator = dedupedThemes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var {
        names,
        theme
      } = _step.value, _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = void 0;
      try {
        for (var _iterator1 = names[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
          var name = _step1.value;
          themesRaw[name] = theme;
        }
      } catch (err) {
        _didIteratorError1 = true, _iteratorError1 = err;
      } finally {
        try {
          !_iteratorNormalCompletion1 && _iterator1.return != null && _iterator1.return();
        } finally {
          if (_didIteratorError1) throw _iteratorError1;
        }
      }
    }
  } catch (err) {
    _didIteratorError = true, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError) throw _iteratorError;
    }
  }
  var themes2 = {}, _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = void 0;
  try {
    for (var _iterator2 = dedupedThemes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var {
        names: names1,
        theme: theme1
      } = _step2.value, _iteratorNormalCompletion3 = true, _didIteratorError3 = false, _iteratorError3 = void 0;
      try {
        for (var _iterator3 = names1[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var themeName = _step3.value, proxiedTheme = proxyThemeToParents(themeName, theme1);
          themes2[themeName] = proxiedTheme;
        }
      } catch (err) {
        _didIteratorError3 = true, _iteratorError3 = err;
      } finally {
        try {
          !_iteratorNormalCompletion3 && _iterator3.return != null && _iterator3.return();
        } finally {
          if (_didIteratorError3) throw _iteratorError3;
        }
      }
    }
  } catch (err) {
    _didIteratorError2 = true, _iteratorError2 = err;
  } finally {
    try {
      !_iteratorNormalCompletion2 && _iterator2.return != null && _iterator2.return();
    } finally {
      if (_didIteratorError2) throw _iteratorError2;
    }
  }
  return themes2;
}
function proxyThemeToParents(themeName, theme) {
  var out = {}, cur = [], parents = themeName.split("_").slice(0, -1).map(function(part) {
    return cur.push(part), cur.join("_");
  }), _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
  try {
    for (var _iterator = parents[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var parent = _step.value;
      Object.assign(out, themesRaw[parent]);
    }
  } catch (err) {
    _didIteratorError = true, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError) throw _iteratorError;
    }
  }
  return Object.assign(out, theme), out;
}
function proxyThemeVariables(obj) {
  return new Proxy(obj || {}, {
    has(target, key) {
      return Reflect.has(target, removeStarting$(key));
    },
    get(target, key) {
      return Reflect.get(target, removeStarting$(key));
    }
  });
}
var removeStarting$ = function(str) {
  return typeof str == "string" && str[0] === "$" ? str.slice(1) : str;
};
function ensureThemeVariable(theme, key) {
  var val = theme[key];
  isVariable(val) ? val.name !== key && (theme[key] = createVariable({
    key: val.name,
    name: key,
    val: val.val
  })) : theme[key] = createVariable({
    key,
    name: key,
    val
  });
}
var fontWeights = ["100", "200", "300", "400", "500", "600", "700", "800", "900"], processSection = function(section, keys, defaultValue2) {
  if (typeof section == "string") return section;
  var sectionKeys = Object.keys(section), fillValue = section[sectionKeys[0]];
  return Object.fromEntries([.../* @__PURE__ */ new Set([...keys, ...sectionKeys])].map(function(key) {
    var _section_key, _ref, value = (_ref = (_section_key = section[key]) !== null && _section_key !== void 0 ? _section_key : defaultValue2) !== null && _ref !== void 0 ? _ref : fillValue;
    return fillValue = value, defaultValue2 = value, [key, value];
  }));
}, createFont = function(font) {
  var sizeKeys = Object.keys(font.size || {}), processedFont = Object.fromEntries(Object.entries(font).map(function(param) {
    var [key, section] = param;
    return [key, processSection(section, key === "face" ? fontWeights : sizeKeys, key === "face" ? {
      normal: font.family
    } : void 0)];
  }));
  return Object.freeze(processedFont);
};
function createShorthands(shorthands) {
  return Object.freeze(shorthands);
}
function _type_of(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var cache = /* @__PURE__ */ new WeakMap(), createVariables = function(tokens) {
  var parentPath = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  if (cache.has(tokens)) return tokens;
  var res = {};
  for (var keyIn in tokens) {
    var val = tokens[keyIn], isPrefixed = keyIn[0] === "$", keyWithPrefix = isPrefixed ? keyIn : `$${keyIn}`, key = isPrefixed ? keyWithPrefix.slice(1) : keyIn;
    if (isVariable(val)) {
      res[key] = val;
      continue;
    }
    var niceKey = simpleHash(key, 1e3), name = parentPath && parentPath !== "t-color" ? `${parentPath}-${niceKey}` : `c-${niceKey}`;
    if (val && (typeof val > "u" ? "undefined" : _type_of(val)) === "object" && "needsPx" in val && "val" in val) {
      var finalValue = createVariable({
        val: val.val,
        name,
        key: keyWithPrefix
      });
      res[key] = finalValue;
      continue;
    }
    if (val && (typeof val > "u" ? "undefined" : _type_of(val)) === "object") {
      res[key] = createVariables(tokens[key], name, false);
      continue;
    }
    var finalValue1 = isVariable(val) ? val : createVariable({
      val,
      name,
      key: keyWithPrefix
    });
    res[key] = finalValue1;
  }
  return cache.set(res, true), res;
};
var registerCSSVariable = function(v) {
  tokensValueToVariable.set(getVariableValue(v), v);
}, variableToCSS = function(v) {
  var unitless = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  return `--${process.env.TAMAGUI_CSS_VARIABLE_PREFIX || ""}${createCSSVariable(v.name, false)}:${!unitless && typeof v.val == "number" ? `${v.val}px` : v.val}`;
}, tokensValueToVariable = /* @__PURE__ */ new Map();
function insertFont(name, fontIn) {
  var font = createFont(fontIn), tokened = createVariables(font, name), parsed = parseFont(tokened);
  return setConfigFont(name, tokened, parsed), parsed;
}
var updateFont = insertFont;
function parseFont(definition) {
  var parsed = {};
  for (var attrKey in definition) {
    var attr = definition[attrKey];
    if (attrKey === "family" || attrKey === "face") parsed[attrKey] = attr;
    else {
      parsed[attrKey] = {};
      for (var key in attr) {
        var _val_val, val = attr[key];
        ((_val_val = val.val) === null || _val_val === void 0 ? void 0 : _val_val[0]) === "$" && (val = val.val), parsed[attrKey][`$${key}`] = val;
      }
    }
  }
  return parsed;
}
function registerFontVariables(parsedFont) {
  var response = [];
  for (var fkey in parsedFont) if (fkey !== "face") if (fkey === "family") {
    var val = parsedFont[fkey];
    registerCSSVariable(val), response.push(variableToCSS(val));
  } else for (var fskey in parsedFont[fkey]) {
    var fval = parsedFont[fkey][fskey];
    if (typeof fval != "string") {
      var val1 = parsedFont[fkey][fskey];
      registerCSSVariable(val1), response.push(variableToCSS(val1));
    }
  }
  return response;
}
var Tamagui = /* @__PURE__ */ (function() {
})(), identifierToValue = /* @__PURE__ */ new Map(), getValueFromIdentifier = function(identifier) {
  return identifierToValue.get(identifier);
}, setIdentifierValue = function(identifier, value) {
  identifierToValue.set(identifier, value);
};
function createTamagui$1(configIn) {
  var _configIn_settings;
  var tokensParsed = {}, tokens = createVariables(configIn.tokens || {});
  if (configIn.tokens) {
    var tokensMerged2 = {};
    for (var cat in tokens) {
      tokensParsed[cat] = {}, tokensMerged2[cat] = {};
      var tokenCat = tokens[cat];
      for (var key in tokenCat) {
        var val = tokenCat[key], prefixedKey = `$${key}`;
        tokensParsed[cat][prefixedKey] = val, tokensMerged2[cat][prefixedKey] = val, tokensMerged2[cat][key] = val;
      }
    }
    setTokens(tokensMerged2);
  }
  var foundThemes;
  if (configIn.themes) {
    var noThemes = Object.keys(configIn.themes).length === 0;
    noThemes && (foundThemes = scanAllSheets());
  }
  var fontSizeTokens = null, fontsParsed;
  if (configIn.fonts) {
    var fontTokens = Object.fromEntries(Object.entries(configIn.fonts).map(function(param) {
      var [k, v] = param;
      return [k, createVariables(v, "f", true)];
    }));
    fontsParsed = (function() {
      var res = {};
      for (var familyName in fontTokens) {
        var font = fontTokens[familyName], fontParsed = parseFont(font);
        res[`$${familyName}`] = fontParsed, !fontSizeTokens && fontParsed.size && (fontSizeTokens = new Set(Object.keys(fontParsed.size)));
      }
      return res;
    })();
  }
  var specificTokens = {}, themeConfig = (function() {
    var cssRuleSets = [];
    for (var key2 in tokens) for (var skey in tokens[key2]) {
      var variable = tokens[key2][skey];
      if (specificTokens[`$${key2}.${skey}`] = variable, false) ;
    }
    var themesIn = configIn.themes, dedupedThemes = foundThemes != null ? foundThemes : getThemesDeduped(themesIn, tokens.color), themes2 = proxyThemesToParents(dedupedThemes);
    return {
      themes: themes2,
      cssRuleSets,
      getThemeRulesSets() {
        var themeRuleSets = [];
        return themeRuleSets;
      }
    };
  })(), userShorthands = configIn.shorthands || {}, shorthands = __spreadValues(__spreadValues({}, builtinShorthands), userShorthands), getCSS = function() {
    return "";
  }, getNewCSS = function(opts) {
    return getCSS(__spreadValues({}, opts));
  }, _configIn_settings_defaultFont, defaultFontSetting = (_configIn_settings_defaultFont = (_configIn_settings = configIn.settings) === null || _configIn_settings === void 0 ? void 0 : _configIn_settings.defaultFont) !== null && _configIn_settings_defaultFont !== void 0 ? _configIn_settings_defaultFont : configIn.defaultFont, defaultFont = (function() {
    var val2 = defaultFontSetting;
    return (val2 == null ? void 0 : val2[0]) === "$" && (val2 = val2.slice(1)), val2;
  })(), defaultFontToken = defaultFont ? `$${defaultFont}` : "", unset = __spreadValues({}, configIn.unset);
  !unset.fontFamily && defaultFont && (unset.fontFamily = defaultFontToken);
  var config = __spreadProps(__spreadValues({
    fonts: {},
    onlyAllowShorthands: false,
    fontLanguages: [],
    animations: {},
    media: {}
  }, configIn), {
    unset,
    settings: __spreadValues({
      // move deprecated settings here so we can reference them all using `getSetting`
      // TODO remove this on v2
      disableSSR: configIn.disableSSR,
      defaultFont: configIn.defaultFont,
      disableRootThemeClass: configIn.disableRootThemeClass,
      onlyAllowShorthands: configIn.onlyAllowShorthands,
      mediaQueryDefaultActive: configIn.mediaQueryDefaultActive,
      themeClassNameOnRoot: configIn.themeClassNameOnRoot,
      cssStyleSeparator: configIn.cssStyleSeparator,
      webContainerType: "inline-size"
    }, configIn.settings),
    tokens,
    // vite made this into a function if it wasn't set
    shorthands,
    userShorthands,
    inverseShorthands: shorthands ? Object.fromEntries(Object.entries(shorthands).map(function(param) {
      var [k, v] = param;
      return [v, k];
    })) : {},
    themes: themeConfig.themes,
    fontsParsed: fontsParsed || {},
    themeConfig,
    tokensParsed,
    parsed: true,
    getNewCSS,
    getCSS,
    defaultFont,
    fontSizeTokens: fontSizeTokens || /* @__PURE__ */ new Set(),
    specificTokens,
    defaultFontToken
  });
  if (setConfig(config), configureMedia(config), configListeners.size && (configListeners.forEach(function(cb) {
    return cb(config);
  }), configListeners.clear()), false) ;
  return config;
}
function getThemesDeduped(themes2, colorTokens) {
  var dedupedThemes = [], existing = /* @__PURE__ */ new Map();
  for (var themeName in themes2) {
    var darkOrLightSpecificPrefix = themeName.startsWith("dark") ? "dark" : themeName.startsWith("light") ? "light" : "", rawTheme = themes2[themeName], key = darkOrLightSpecificPrefix + JSON.stringify(rawTheme);
    if (existing.has(key)) {
      var e2 = existing.get(key);
      e2.names.push(themeName);
      continue;
    }
    var theme = __spreadValues({}, rawTheme);
    colorTokens && Object.assign(theme, colorTokens);
    for (var key1 in theme) ensureThemeVariable(theme, key1);
    var deduped = {
      names: [themeName],
      theme
    };
    dedupedThemes.push(deduped), existing.set(key, deduped);
  }
  return dedupedThemes;
}
var builtinShorthands = {
  fd: "flexDirection",
  fb: "flexBasis",
  bblr: "borderBottomLeftRadius",
  bbrr: "borderBottomRightRadius",
  fwr: "flexWrap",
  col: "color",
  ff: "fontFamily",
  fst: "fontStyle",
  tr: "transform",
  tt: "textTransform",
  td: "textDecorationLine",
  va: "verticalAlign",
  ws: "whiteSpace",
  wb: "wordBreak",
  ww: "wordWrap",
  brc: "borderRightColor",
  brw: "borderRightWidth",
  bs: "borderStyle",
  btc: "borderTopColor",
  btlr: "borderTopLeftRadius",
  btrr: "borderTopRightRadius",
  btw: "borderTopWidth",
  bw: "borderWidth",
  o: "opacity",
  cur: "cursor",
  pe: "pointerEvents",
  ov: "overflow",
  pos: "position",
  dsp: "display",
  fw: "fontWeight",
  fs: "fontSize",
  ls: "letterSpacing",
  lh: "lineHeight",
  bxs: "boxSizing",
  bxsh: "boxShadow",
  ox: "overflowX",
  oy: "overflowY"
};
var createTheme = function(theme) {
  return theme;
};
function createTokens(tokens) {
  var _process_env_TAMAGUI_TOKEN_PREFIX;
  return createVariables(tokens, (_process_env_TAMAGUI_TOKEN_PREFIX = process.env.TAMAGUI_TOKEN_PREFIX) !== null && _process_env_TAMAGUI_TOKEN_PREFIX !== void 0 ? _process_env_TAMAGUI_TOKEN_PREFIX : "t");
}
function getReactNativeConfig(Component) {
  if (Component) {
    var _Component_propTypes, _Component_propTypes1, _Component_propTypes2;
    return !((_Component_propTypes = Component.propTypes) === null || _Component_propTypes === void 0) && _Component_propTypes.onTextInput || !((_Component_propTypes1 = Component.propTypes) === null || _Component_propTypes1 === void 0) && _Component_propTypes1.onChangeText ? RNConfigs.TextInput : Component.getSizeWithHeaders ? RNConfigs.Image : !((_Component_propTypes2 = Component.propTypes) === null || _Component_propTypes2 === void 0) && _Component_propTypes2.textBreakStrategy ? RNConfigs.Text : RNConfigs.default;
  }
}
var RNConfigs = {
  Image: {
    isReactNative: true,
    inlineProps: /* @__PURE__ */ new Set(["src", "width", "height"])
  },
  Text: {
    isReactNative: true,
    isText: true
  },
  TextInput: {
    isReactNative: true,
    isInput: true,
    isText: true
  },
  default: {
    isReactNative: true
  }
};
function setupReactNative(rnExports) {
}
var mergeVariants = function(parentVariants, ourVariants) {
  var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, variants = {};
  for (var key in ourVariants) {
    var parentVariant = parentVariants == null ? void 0 : parentVariants[key], ourVariant = ourVariants[key];
    !parentVariant || typeof ourVariant == "function" ? variants[key] = ourVariant : parentVariant && !ourVariant ? variants[key] = parentVariant[key] : level === 0 ? variants[key] = mergeVariants(parentVariant, ourVariant, level + 1) : variants[key] = __spreadValues(__spreadValues({}, parentVariant), ourVariant);
  }
  return __spreadValues(__spreadValues({}, parentVariants), variants);
};
function styled(ComponentIn, options, config) {
  var parentStaticConfig = ComponentIn.staticConfig, isPlainStyledComponent = !!parentStaticConfig && !(parentStaticConfig.isReactNative || parentStaticConfig.isHOC), isNonStyledHOC = (parentStaticConfig == null ? void 0 : parentStaticConfig.isHOC) && !(parentStaticConfig == null ? void 0 : parentStaticConfig.isStyledHOC), Component = isNonStyledHOC || isPlainStyledComponent ? ComponentIn : (parentStaticConfig == null ? void 0 : parentStaticConfig.Component) || ComponentIn, reactNativeConfig = parentStaticConfig ? void 0 : getReactNativeConfig(Component), isReactNative = !!(reactNativeConfig || (config == null ? void 0 : config.isReactNative) || (parentStaticConfig == null ? void 0 : parentStaticConfig.isReactNative)), staticConfigProps = (function() {
    var _a = options || {}, {
      variants,
      name,
      defaultVariants,
      acceptsClassName: acceptsClassNameProp,
      context
    } = _a, defaultProps = __objRest(_a, [
      "variants",
      "name",
      "defaultVariants",
      "acceptsClassName",
      "context"
    ]), parentDefaultVariants, parentDefaultProps;
    if (parentStaticConfig) {
      var avoid = parentStaticConfig.isHOC && !parentStaticConfig.isStyledHOC;
      if (!avoid) {
        var pdp = parentStaticConfig.defaultProps;
        for (var key2 in pdp) {
          var val = pdp[key2];
          parentStaticConfig.defaultVariants && key2 in parentStaticConfig.defaultVariants && (!defaultVariants || !(key2 in defaultVariants)) && (parentDefaultVariants || (parentDefaultVariants = {}), parentDefaultVariants[key2] = val), !(key2 in defaultProps) && (!defaultVariants || !(key2 in defaultVariants)) && (parentDefaultProps || (parentDefaultProps = {}), parentDefaultProps[key2] = pdp[key2]);
        }
        parentStaticConfig.variants && (variants = mergeVariants(parentStaticConfig.variants, variants));
      }
    }
    (parentDefaultProps || defaultVariants || parentDefaultVariants) && (defaultProps = __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, parentDefaultProps), parentDefaultVariants), defaultProps), defaultVariants)), (parentStaticConfig == null ? void 0 : parentStaticConfig.isHOC) && name && (defaultProps.componentName = name);
    var isText = !!((config == null ? void 0 : config.isText) || (parentStaticConfig == null ? void 0 : parentStaticConfig.isText)), _config_acceptsClassName, _ref, acceptsClassName = (_ref = (_config_acceptsClassName = config == null ? void 0 : config.acceptsClassName) !== null && _config_acceptsClassName !== void 0 ? _config_acceptsClassName : acceptsClassNameProp) !== null && _ref !== void 0 ? _ref : isPlainStyledComponent || isReactNative || (parentStaticConfig == null ? void 0 : parentStaticConfig.isHOC) && (parentStaticConfig == null ? void 0 : parentStaticConfig.acceptsClassName), conf2 = __spreadProps(__spreadValues(__spreadProps(__spreadValues(__spreadValues(__spreadValues({}, parentStaticConfig), config), !isPlainStyledComponent && {
      Component
    }), {
      // @ts-expect-error
      variants,
      defaultProps,
      defaultVariants,
      componentName: name || (parentStaticConfig == null ? void 0 : parentStaticConfig.componentName),
      isReactNative,
      isText,
      acceptsClassName,
      context
    }), reactNativeConfig), {
      isStyledHOC: !!(parentStaticConfig == null ? void 0 : parentStaticConfig.isHOC),
      parentStaticConfig
    });
    return (defaultProps.children || !acceptsClassName || context) && (conf2.neverFlatten = true), conf2;
  })(), component = createComponent(staticConfigProps || {});
  for (var key in ComponentIn) key !== "propTypes" && (key in component || (component[key] = ComponentIn[key]));
  return component;
}
var useIsTouchDevice = function() {
  return true;
};
var Stack$1 = createComponent({
  acceptsClassName: true,
  defaultProps: stackDefaultStyles,
  validStyles
});
Stack$1.displayName = "Stack";
function useProps(props, opts) {
  var [propsOut, styleOut] = usePropsAndStyle(props, __spreadProps(__spreadValues({}, opts), {
    noExpand: true,
    noNormalize: true,
    resolveValues: "none"
  }));
  return __spreadValues(__spreadValues({}, propsOut), styleOut);
}
function useStyle(props, opts) {
  return usePropsAndStyle(props, opts)[1] || {};
}
function usePropsAndStyle(props, opts) {
  var _opts_forComponent, _opts_forComponent_staticConfig, staticConfig = (_opts_forComponent_staticConfig = opts == null || (_opts_forComponent = opts.forComponent) === null || _opts_forComponent === void 0 ? void 0 : _opts_forComponent.staticConfig) !== null && _opts_forComponent_staticConfig !== void 0 ? _opts_forComponent_staticConfig : Stack$1.staticConfig, [theme, themeState] = useThemeWithState({
    componentName: staticConfig.componentName,
    name: "theme" in props ? props.theme : void 0,
    inverse: "themeInverse" in props ? props.themeInverse : void 0,
    needsUpdate() {
      return true;
    }
  }), componentContext = React.useContext(ComponentContext), groupContext = React.useContext(GroupContext), {
    state,
    disabled,
    setStateShallow
  } = useComponentState(props, componentContext.animationDriver, staticConfig, getConfig()), mediaStateNow = (opts == null ? void 0 : opts.noMedia) ? (
    // not safe to use mediaState but really marginal to hit this
    exports.mediaState
  ) : useMedia(), splitStyles = useSplitStyles(props, staticConfig, theme, (themeState == null ? void 0 : themeState.name) || "", state, __spreadValues({
    isAnimated: false,
    mediaState: mediaStateNow,
    noSkip: true,
    noMergeStyle: true,
    noClass: true,
    resolveValues: "auto"
  }, opts), null, componentContext, groupContext), {
    mediaGroups,
    pseudoGroups
  } = splitStyles || {};
  return useIsomorphicLayoutEffect(function() {
    if (!disabled) {
      if (state.unmounted) {
        setStateShallow({
          unmounted: false
        });
        return;
      }
      if (groupContext) return subscribeToContextGroup({
        groupContext,
        setStateShallow,
        mediaGroups,
        pseudoGroups
      });
    }
  }, [disabled, groupContext, pseudoGroups ? Object.keys([...pseudoGroups]).join("") : 0, mediaGroups ? Object.keys([...mediaGroups]).join("") : 0]), [(splitStyles == null ? void 0 : splitStyles.viewProps) || {}, (splitStyles == null ? void 0 : splitStyles.style) || {}, theme, exports.mediaState];
}
var forceUpdateState = {
  forceClassName: true,
  deopt: true,
  needsUpdate: function() {
    return true;
  }
}, forceKeys = {
  current: /* @__PURE__ */ new Set([""])
};
function useThemeName() {
  var _useThemeState;
  return ((_useThemeState = useThemeState(forceUpdateState, false, forceKeys)) === null || _useThemeState === void 0 ? void 0 : _useThemeState.name) || "";
}
var Configuration = function(props) {
  var current = React.useContext(ComponentContext), _props_disableSSR;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ClientOnly, {
    enabled: (_props_disableSSR = props.disableSSR) !== null && _props_disableSSR !== void 0 ? _props_disableSSR : current.disableSSR,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ComponentContext.Provider, __spreadValues(__spreadValues({}, current), props))
  });
};
function FontLanguage(param) {
  var _a = param, {
    children
  } = _a, props = __objRest(_a, [
    "children"
  ]), parentProps = React.useContext(ComponentContext), language = React.useMemo(function() {
    return props;
  }, [JSON.stringify(props)]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ComponentContext.Provider, __spreadProps(__spreadValues({}, parentProps), {
    language,
    children
  }));
}
var ThemeProvider = function(props) {
  var _props_disableRootThemeClass, disableRootThemeClass = (_props_disableRootThemeClass = props.disableRootThemeClass) !== null && _props_disableRootThemeClass !== void 0 ? _props_disableRootThemeClass : getSetting("disableRootThemeClass"), _props_themeClassNameOnRoot, themeClassNameOnRoot = (_props_themeClassNameOnRoot = props.themeClassNameOnRoot) !== null && _props_themeClassNameOnRoot !== void 0 ? _props_themeClassNameOnRoot : getSetting("themeClassNameOnRoot");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Theme, {
    className: props.className,
    name: props.defaultTheme,
    // if root class disabled, force class here
    forceClassName: !disableRootThemeClass && !themeClassNameOnRoot,
    // @ts-expect-error
    _isRoot: React.useId,
    children: props.children
  });
};
function TamaguiProvider$1(param) {
  var {
    children,
    disableInjectCSS,
    config,
    className,
    defaultTheme,
    disableRootThemeClass,
    reset,
    themeClassNameOnRoot
  } = param;
  useIsomorphicLayoutEffect(function() {
    updateMediaListeners();
  }, []);
  var contents = /* @__PURE__ */ jsxRuntimeExports.jsx(UnmountedClassName, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ComponentContext.Provider, {
      animationDriver: config == null ? void 0 : config.animations,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider, {
        themeClassNameOnRoot: themeClassNameOnRoot != null ? themeClassNameOnRoot : getSetting("themeClassNameOnRoot"),
        disableRootThemeClass: disableRootThemeClass != null ? disableRootThemeClass : getSetting("disableRootThemeClass"),
        defaultTheme: defaultTheme != null ? defaultTheme : config ? Object.keys(config.themes)[0] : "",
        reset,
        className,
        children
      })
    })
  });
  return getSetting("disableSSR") && (contents = /* @__PURE__ */ jsxRuntimeExports.jsx(ClientOnly, {
    enabled: true,
    children: contents
  })), /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
    children: [contents, false]
  });
}
function UnmountedClassName(props) {
  var [mounted, setMounted] = React.useState(false);
  return React.useEffect(function() {
    setMounted(true);
  }, []), props.children;
}
TamaguiProvider$1.displayName = "TamaguiProvider";
var ellipsisStyle = {
  numberOfLines: 1,
  lineBreakMode: "clip"
}, Text$1 = createComponent({
  acceptsClassName: true,
  isText: true,
  defaultProps: {
    fontFamily: "unset",
    suppressHighlighting: true
  },
  inlineWhenUnflattened: /* @__PURE__ */ new Set(["fontFamily"]),
  variants: {
    /**
    * @deprecated Use ellipsis instead
    */
    ellipse: {
      true: ellipsisStyle
    },
    ellipsis: {
      true: ellipsisStyle
    }
  },
  validStyles: __spreadValues(__spreadValues({}, validStyles), stylePropsTextOnly)
});
Text$1.displayName = "Text";
var View$1 = createComponent({
  acceptsClassName: true,
  defaultProps: stackDefaultStyles,
  validStyles
});
function useGet(currentValue, initialValue, forwardToFunction) {
  var curRef = React__namespace.useRef(initialValue != null ? initialValue : currentValue);
  return useIsomorphicLayoutEffect(function() {
    curRef.current = currentValue;
  }), React__namespace.useCallback(forwardToFunction ? function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
    var _curRef_current;
    return (_curRef_current = curRef.current) === null || _curRef_current === void 0 ? void 0 : _curRef_current.apply(null, args);
  } : function() {
    return curRef.current;
  }, []);
}
function useEvent(callback) {
  return useGet(callback, defaultValue, true);
}
var defaultValue = function() {
  throw new Error("Cannot call an event handler while rendering.");
};
var RE_MEDIA_QUERY = /(?:(only|not)?\s*([^\s\(\)]+)(?:\s*and)?\s*)?(.+)?/i, RE_MQ_EXPRESSION = /\(\s*([^\s\:\)]+)\s*(?:\:\s*([^\s\)]+))?\s*\)/, RE_MQ_FEATURE = /^(?:(min|max)-)?(.+)/, RE_LENGTH_UNIT = /(em|rem|px|cm|mm|in|pt|pc)?$/, RE_RESOLUTION_UNIT = /(dpi|dpcm|dppx)?$/;
function matchQuery(mediaQuery, values) {
  return parseQuery(mediaQuery).some(function(query2) {
    if (query2) {
      var inverse = query2.inverse, typeMatch = query2.type === "all" || values.type === query2.type;
      if (typeMatch && inverse || !(typeMatch || inverse)) return false;
      var expressionsMatch = query2.expressions.every(function(expression) {
        var feature = expression.feature, modifier = expression.modifier, expValue = expression.value, value = values[feature];
        if (!value) return false;
        switch (feature) {
          case "orientation":
          case "scan":
            return value.toLowerCase() === expValue.toLowerCase();
          case "width":
          case "height":
          case "device-width":
          case "device-height":
            expValue = toPx(expValue), value = toPx(value);
            break;
          case "resolution":
            expValue = toDpi(expValue), value = toDpi(value);
            break;
          case "aspect-ratio":
          case "device-aspect-ratio":
          case /* Deprecated */
          "device-pixel-ratio":
            expValue = toDecimal(expValue), value = toDecimal(value);
            break;
          case "grid":
          case "color":
          case "color-index":
          case "monochrome":
            expValue = Number.parseInt(expValue, 10) || 1, value = Number.parseInt(value, 10) || 0;
            break;
        }
        switch (modifier) {
          case "min":
            return value >= expValue;
          case "max":
            return value <= expValue;
          default:
            return value === expValue;
        }
      });
      return expressionsMatch && !inverse || !expressionsMatch && inverse;
    }
  });
}
function parseQuery(mediaQuery) {
  return mediaQuery.split(",").map(function(query2) {
    query2 = query2.trim();
    var captures = query2.match(RE_MEDIA_QUERY);
    if (!captures) return null;
    var modifier = captures[1], type = captures[2], expressionsCapture = captures[3] || "", expressions = expressionsCapture.match(/\([^\)]+\)/g) || [];
    return {
      inverse: !!modifier && modifier.toLowerCase() === "not",
      type: type ? type.toLowerCase() : "all",
      expressions: expressions.map(function(expression) {
        var captures2 = expression.match(RE_MQ_EXPRESSION), feature = captures2[1].toLowerCase().match(RE_MQ_FEATURE);
        return {
          modifier: feature[1],
          feature: feature[2],
          value: captures2[2]
        };
      })
    };
  });
}
function toDecimal(ratio) {
  var decimal = Number(ratio), numbers;
  return decimal || (numbers = ratio.match(/^(\d+)\s*\/\s*(\d+)$/), decimal = numbers[1] / numbers[2]), decimal;
}
function toDpi(resolution) {
  var _String_match, value = Number.parseFloat(resolution), units = (_String_match = String(resolution).match(RE_RESOLUTION_UNIT)) === null || _String_match === void 0 ? void 0 : _String_match[1];
  switch (units) {
    case "dpcm":
      return value / 2.54;
    case "dppx":
      return value * 96;
    default:
      return value;
  }
}
function toPx(length) {
  var _String_match, value = Number.parseFloat(length), units = (_String_match = String(length).match(RE_LENGTH_UNIT)) === null || _String_match === void 0 ? void 0 : _String_match[1];
  switch (units) {
    case "em":
      return value * 16;
    case "rem":
      return value * 16;
    case "cm":
      return value * 96 / 2.54;
    case "mm":
      return value * 96 / 2.54 / 10;
    case "in":
      return value * 96;
    case "pt":
      return value * 72;
    case "pc":
      return value * 72 / 12;
    default:
      return value;
  }
}
function _class_call_check(instance, Constructor) {
  if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor && (descriptor.writable = true), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties(Constructor.prototype, protoProps), Constructor;
}
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: true,
    configurable: true,
    writable: true
  }) : obj[key] = value, obj;
}
var NativeMediaQueryList = /* @__PURE__ */ (function() {
  function NativeMediaQueryList2(query2) {
    var _this = this;
    _class_call_check(this, NativeMediaQueryList2), _define_property(this, "query", void 0), _define_property(this, "listeners", void 0), this.query = query2, this.listeners = [], this.notify(), Dimensions.addEventListener("change", function() {
      _this.notify();
    });
  }
  return _create_class(NativeMediaQueryList2, [{
    key: "orientation",
    get: function() {
      var windowDimensions = Dimensions.get("window");
      return windowDimensions.height > windowDimensions.width ? "portrait" : "landscape";
    }
  }, {
    key: "notify",
    value: function() {
      var _this = this;
      this.listeners.forEach(function(listener) {
        listener(_this.orientation);
      });
    }
  }, {
    key: "addListener",
    value: function(listener) {
      this.listeners.push(listener);
    }
  }, {
    key: "removeListener",
    value: function(listener) {
      var index2 = this.listeners.indexOf(listener);
      index2 !== -1 && this.listeners.splice(index2, 1);
    }
  }, {
    key: "match",
    value: function(query2, param) {
      var {
        width,
        height
      } = param;
      return matchQuery(query2, {
        type: "screen",
        orientation: height > width ? "portrait" : "landscape",
        "device-width": width,
        "device-height": height
      });
    }
  }, {
    key: "matches",
    get: function() {
      var windowDimensions = Dimensions.get("window"), matches = matchQuery(this.query, __spreadProps(__spreadValues({
        type: "screen",
        orientation: this.orientation
      }, windowDimensions), {
        "device-width": windowDimensions.width,
        "device-height": windowDimensions.height
      }));
      return matches;
    }
  }]), NativeMediaQueryList2;
})();
var matchMedia = function(query2) {
  return new NativeMediaQueryList(query2);
};
function createMedia(media) {
  return setupMatchMedia(matchMedia), media;
}
function getReactNativeVersion() {
  let version = process.env.REACT_NATIVE_VERSION || "";
  if (!process.env.REACT_NATIVE_VERSION) {
    try {
      const ReactNativeOfficalVersion = require("react-native/Libraries/Core/ReactNativeVersion");
      if (ReactNativeOfficalVersion) {
        const {
          version: { major: major2, minor: minor2, patch: patch2 }
        } = ReactNativeOfficalVersion;
        version = `${major2}.${minor2}.${patch2}`;
      }
    } catch (e2) {
    } finally {
      if (!version) {
        version = "0.77";
      }
    }
  }
  const [major, minor, patch] = version.split(".");
  return [+major, +minor, +patch];
}
function addNativeValidStyles() {
  const [major, minor] = getReactNativeVersion();
  if (major === 0 && minor >= 77) {
    const additional = {
      boxSizing: true,
      mixBlendMode: true,
      outlineWidth: true,
      outlineStyle: true,
      outlineSpread: true,
      outlineColor: true
    };
    Object.assign(validStyles, additional);
    Object.assign(stylePropsAll, additional);
  }
}
function createOptimizedView(children, viewProps, baseViews2) {
  var _a, _b, _c;
  const TextAncestor = baseViews2.TextAncestor;
  const {
    accessibilityElementsHidden,
    accessibilityLabel,
    accessibilityLabelledBy,
    accessibilityLiveRegion,
    accessibilityState,
    accessibilityValue,
    "aria-busy": ariaBusy,
    "aria-checked": ariaChecked,
    "aria-disabled": ariaDisabled,
    "aria-expanded": ariaExpanded,
    "aria-hidden": ariaHidden,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    "aria-live": ariaLive,
    "aria-selected": ariaSelected,
    "aria-valuemax": ariaValueMax,
    "aria-valuemin": ariaValueMin,
    "aria-valuenow": ariaValueNow,
    "aria-valuetext": ariaValueText,
    focusable,
    id,
    role,
    tabIndex
    // ...otherProps
  } = viewProps;
  const _accessibilityLabelledBy = (_a = ariaLabelledBy == null ? void 0 : ariaLabelledBy.split(/\s*,\s*/g)) != null ? _a : accessibilityLabelledBy;
  let _accessibilityState;
  if (accessibilityState != null || ariaBusy != null || ariaChecked != null || ariaDisabled != null || ariaExpanded != null || ariaSelected != null) {
    _accessibilityState = {
      busy: ariaBusy != null ? ariaBusy : accessibilityState == null ? void 0 : accessibilityState.busy,
      checked: ariaChecked != null ? ariaChecked : accessibilityState == null ? void 0 : accessibilityState.checked,
      disabled: ariaDisabled != null ? ariaDisabled : accessibilityState == null ? void 0 : accessibilityState.disabled,
      expanded: ariaExpanded != null ? ariaExpanded : accessibilityState == null ? void 0 : accessibilityState.expanded,
      selected: ariaSelected != null ? ariaSelected : accessibilityState == null ? void 0 : accessibilityState.selected
    };
  }
  let _accessibilityValue;
  if (accessibilityValue != null || ariaValueMax != null || ariaValueMin != null || ariaValueNow != null || ariaValueText != null) {
    _accessibilityValue = {
      max: ariaValueMax != null ? ariaValueMax : accessibilityValue == null ? void 0 : accessibilityValue.max,
      min: ariaValueMin != null ? ariaValueMin : accessibilityValue == null ? void 0 : accessibilityValue.min,
      now: ariaValueNow != null ? ariaValueNow : accessibilityValue == null ? void 0 : accessibilityValue.now,
      text: ariaValueText != null ? ariaValueText : accessibilityValue == null ? void 0 : accessibilityValue.text
    };
  }
  if ((_b = viewProps.style) == null ? void 0 : _b.pointerEvents) {
    viewProps.pointerEvents = (_c = viewProps.style) == null ? void 0 : _c.pointerEvents;
  }
  if (id) {
    viewProps.nativeID = id;
  }
  if (ariaHidden === true) {
    viewProps.importantForAccessibility = "no-hide-descendants";
  }
  if (_accessibilityValue) {
    viewProps.accessibilityValue = _accessibilityValue;
  }
  if (role) {
    viewProps.accessibilityRole = getAccessibilityRoleFromRole(role);
  }
  if (ariaLive === "off") {
    viewProps.accessibilityLiveRegion = "none";
  } else {
    const alr = ariaLive != null ? ariaLive : accessibilityLiveRegion;
    if (alr) {
      viewProps.accessibilityLiveRegion = alr;
    }
  }
  const al = ariaLabel != null ? ariaLabel : accessibilityLabel;
  if (al) {
    viewProps.accessibilityLabel = al;
  }
  const f = tabIndex !== void 0 ? !tabIndex : focusable;
  if (f != null) {
    viewProps.focusable = f;
  }
  if (_accessibilityState != null) {
    viewProps.accessibilityState = _accessibilityState;
  }
  const ah = ariaHidden != null ? ariaHidden : accessibilityElementsHidden;
  if (ah != null) {
    viewProps.accessibilityElementsHidden = ah;
  }
  if (_accessibilityLabelledBy) {
    viewProps.accessibilityLabelledBy = _accessibilityLabelledBy;
  }
  const isInText = React.useContext(TextAncestor);
  const finalElement = React.createElement("RCTView", viewProps, children);
  if (!isInText) {
    return finalElement;
  }
  return React.createElement(TextAncestor.Provider, { value: false }, finalElement);
}
function getAccessibilityRoleFromRole(role) {
  switch (role) {
    case "alert":
      return "alert";
    case "alertdialog":
      return;
    case "application":
      return;
    case "article":
      return;
    case "banner":
      return;
    case "button":
      return "button";
    case "cell":
      return;
    case "checkbox":
      return "checkbox";
    case "columnheader":
      return;
    case "combobox":
      return "combobox";
    case "complementary":
      return;
    case "contentinfo":
      return;
    case "definition":
      return;
    case "dialog":
      return;
    case "directory":
      return;
    case "document":
      return;
    case "feed":
      return;
    case "figure":
      return;
    case "form":
      return;
    case "grid":
      return "grid";
    case "group":
      return;
    case "heading":
      return "header";
    case "img":
      return "image";
    case "link":
      return "link";
    case "list":
      return "list";
    case "listitem":
      return;
    case "log":
      return;
    case "main":
      return;
    case "marquee":
      return;
    case "math":
      return;
    case "menu":
      return "menu";
    case "menubar":
      return "menubar";
    case "menuitem":
      return "menuitem";
    case "meter":
      return;
    case "navigation":
      return;
    case "none":
      return "none";
    case "note":
      return;
    case "option":
      return;
    case "presentation":
      return "none";
    case "progressbar":
      return "progressbar";
    case "radio":
      return "radio";
    case "radiogroup":
      return "radiogroup";
    case "region":
      return;
    case "row":
      return;
    case "rowgroup":
      return;
    case "rowheader":
      return;
    case "scrollbar":
      return "scrollbar";
    case "searchbox":
      return "search";
    case "separator":
      return;
    case "slider":
      return "adjustable";
    case "spinbutton":
      return "spinbutton";
    case "status":
      return;
    case "summary":
      return "summary";
    case "switch":
      return "switch";
    case "tab":
      return "tab";
    case "table":
      return;
    case "tablist":
      return "tablist";
    case "tabpanel":
      return;
    case "term":
      return;
    case "timer":
      return "timer";
    case "toolbar":
      return "toolbar";
    case "tooltip":
      return;
    case "tree":
      return;
    case "treegrid":
      return;
    case "treeitem":
      return;
  }
  return;
}
function getBaseViews() {
  var _a, _b, _c, _d;
  const native = require("react-native");
  return {
    View: native.View || ((_a = native.default) == null ? void 0 : _a.View),
    Text: native.Text || ((_b = native.default) == null ? void 0 : _b.Text),
    TextAncestor: native.unstable_TextAncestorContext,
    StyleSheet: native.StyleSheet || ((_c = native.default) == null ? void 0 : _c.StyleSheet),
    Pressable: native.Pressable || ((_d = native.default) == null ? void 0 : _d.Pressable)
  };
}
require("react-native/Libraries/Pressability/Pressability").default;
const usePressability = require("react-native/Libraries/Pressability/usePressability").default;
addNativeValidStyles();
const TamaguiProvider = (props) => {
  useIsomorphicLayoutEffect(() => {
    enable();
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TamaguiProvider$1, __spreadValues({}, props));
};
const createTamagui = (conf2) => {
  {
    if (conf2.media) {
      conf2.media = createMedia(conf2.media);
    }
  }
  return createTamagui$1(conf2);
};
const baseViews = getBaseViews();
setupHooks(__spreadValues({
  getBaseViews,
  setElementProps: (node) => {
  },
  usePropsTransform(elementType, propsIn, stateRef, willHydrate) {
  },
  useEvents(viewProps, events, splitStyles, setStateShallow, staticConfig) {
    {
      if (events) {
        if (events.onFocus) {
          viewProps["onFocus"] = events.onFocus;
        }
        if (events.onBlur) {
          viewProps["onBlur"] = events.onBlur;
        }
      }
      if (staticConfig.isInput) {
        if (events) {
          const { onPressIn, onPressOut, onPress } = events;
          const inputEvents = {
            onPressIn,
            onPressOut: onPressOut || onPress
          };
          if (onPressOut && onPress) {
            inputEvents.onPressOut = composeEventHandlers(onPress, onPressOut);
          }
          Object.assign(viewProps, inputEvents);
        }
      } else {
        if (events && viewProps.hitSlop) {
          events.hitSlop = viewProps.hitSlop;
        }
        const pressability = usePressability(events);
        if (events) {
          if (events.onPress) {
            for (const key in pressability) {
              const og = viewProps[key];
              const val = pressability[key];
              viewProps[key] = og && !dontComposePressabilityKeys[key] ? composeEventHandlers(og, val) : val;
            }
          }
        }
      }
    }
  }
}, {
  useChildren(elementType, children, viewProps) {
    if (elementType === baseViews.View && baseViews.TextAncestor) {
      return createOptimizedView(children, viewProps, baseViews);
    }
  }
}));
const dontComposePressabilityKeys = {
  onClick: true
};
const View = View$1;
const Stack = Stack$1;
const Text = Text$1;
exports.ClientOnly = ClientOnly;
exports.ClientOnlyContext = ClientOnlyContext;
exports.ComponentContext = ComponentContext;
exports.Configuration = Configuration;
exports.FONT_DATA_ATTRIBUTE_NAME = FONT_DATA_ATTRIBUTE_NAME;
exports.FontLanguage = FontLanguage;
exports.GroupContext = GroupContext;
exports.IS_REACT_19 = IS_REACT_19;
exports.LayoutMeasurementController = LayoutMeasurementController;
exports.MEDIA_SEP = MEDIA_SEP;
exports.MISSING_THEME_MESSAGE = MISSING_THEME_MESSAGE;
exports.PROP_SPLIT = PROP_SPLIT;
exports.Slot = Slot;
exports.Slottable = Slottable;
exports.Spacer = Spacer;
exports.Stack = Stack;
exports.StyleObjectIdentifier = StyleObjectIdentifier;
exports.StyleObjectProperty = StyleObjectProperty;
exports.StyleObjectPseudo = StyleObjectPseudo;
exports.StyleObjectRules = StyleObjectRules;
exports.StyleObjectValue = StyleObjectValue;
exports.THEME_CLASSNAME_PREFIX = THEME_CLASSNAME_PREFIX;
exports.THEME_NAME_SEPARATOR = THEME_NAME_SEPARATOR;
exports.Tamagui = Tamagui;
exports.TamaguiProvider = TamaguiProvider;
exports.Text = Text;
exports.Theme = Theme;
exports.ThemeProvider = ThemeProvider;
exports.Unspaced = Unspaced;
exports.View = View;
exports._disableMediaTouch = _disableMediaTouch;
exports._withStableStyle = _withStableStyle;
exports.clamp = clamp;
exports.componentSetStates = componentSetStates;
exports.composeEventHandlers = composeEventHandlers;
exports.composeRefs = composeRefs;
exports.configureMedia = configureMedia;
exports.createCSSVariable = createCSSVariable;
exports.createComponent = createComponent;
exports.createFont = createFont;
exports.createMediaStyle = createMediaStyle;
exports.createShorthands = createShorthands;
exports.createStyledContext = createStyledContext;
exports.createTamagui = createTamagui;
exports.createTheme = createTheme;
exports.createTokens = createTokens;
exports.createVariable = createVariable;
exports.createVariables = createVariables;
exports.currentPlatform = currentPlatform;
exports.defaultMediaImportance = defaultMediaImportance;
exports.didGetVariableValue = didGetVariableValue;
exports.ensureThemeVariable = ensureThemeVariable;
exports.fixStyles = fixStyles;
exports.forceUpdateThemes = forceUpdateThemes;
exports.getCSSStylesAtomic = getCSSStylesAtomic;
exports.getConfig = getConfig;
exports.getExpandedShorthand = getExpandedShorthand;
exports.getExpandedShorthands = getExpandedShorthands;
exports.getFontFamilyFromNameOrVariable = getFontFamilyFromNameOrVariable;
exports.getFontsForLanguage = getFontsForLanguage;
exports.getMedia = getMedia;
exports.getReactNativeConfig = getReactNativeConfig;
exports.getRgba = getRgba;
exports.getSetting = getSetting;
exports.getShorthandValue = getShorthandValue;
exports.getSplitStyles = getSplitStyles;
exports.getStyleAtomic = getStyleAtomic;
exports.getStyleTags = getStyleTags;
exports.getSubStyle = getSubStyle;
exports.getThemeCSSRules = getThemeCSSRules;
exports.getThemedChildren = getThemedChildren;
exports.getThemes = getThemes;
exports.getToken = getToken;
exports.getTokenForKey = getTokenForKey;
exports.getTokenValue = getTokenValue;
exports.getTokens = getTokens;
exports.getValueFromIdentifier = getValueFromIdentifier;
exports.getVariable = getVariable;
exports.getVariableName = getVariableName;
exports.getVariableValue = getVariableValue;
exports.getVariableVariable = getVariableVariable;
exports.getVariantExtras = getVariantExtras;
exports.hooks = hooks;
exports.insertFont = insertFont;
exports.insertStyleRules = insertStyleRules;
exports.isAndroid = isAndroid;
exports.isChrome = isChrome;
exports.isClient = isClient;
exports.isEqualShallow = isEqualShallow;
exports.isIos = isIos;
exports.isServer = isServer;
exports.isTamaguiComponent = isTamaguiComponent;
exports.isTamaguiElement = isTamaguiElement;
exports.isTouchable = isTouchable;
exports.isVariable = isVariable;
exports.isWeb = isWeb;
exports.isWebTouchable = isWebTouchable;
exports.isWindowDefined = isWindowDefined;
exports.matchMedia = matchMedia$1;
exports.mediaKeyMatch = mediaKeyMatch;
exports.mediaObjectToString = mediaObjectToString;
exports.mediaQueryConfig = mediaQueryConfig;
exports.mergeComponentProps = mergeComponentProps;
exports.mergeIfNotShallowEqual = mergeIfNotShallowEqual;
exports.mergeProps = mergeProps;
exports.normalizeColor = normalizeColor;
exports.normalizeStyle = normalizeStyle$1;
exports.normalizeValueWithProperty = normalizeValueWithProperty;
exports.parseFont = parseFont;
exports.propMapper = propMapper;
exports.proxyThemeToParents = proxyThemeToParents;
exports.proxyThemeVariables = proxyThemeVariables;
exports.proxyThemesToParents = proxyThemesToParents;
exports.pseudoDescriptors = pseudoDescriptors;
exports.pseudoDescriptorsBase = pseudoDescriptorsBase;
exports.pseudoPriorities = pseudoPriorities;
exports.px = px;
exports.registerFontVariables = registerFontVariables;
exports.rgba = rgba;
exports.setConfig = setConfig;
exports.setDidGetVariableValue = setDidGetVariableValue;
exports.setIdentifierValue = setIdentifierValue;
exports.setNonce = setNonce;
exports.setOnLayoutStrategy = setOnLayoutStrategy;
exports.setRef = setRef;
exports.setupDev = setupDev;
exports.setupHooks = setupHooks;
exports.setupMatchMedia = setupMatchMedia;
exports.setupReactNative = setupReactNative;
exports.shouldRenderNativePlatform = shouldRenderNativePlatform;
exports.simpleHash = simpleHash;
exports.spacedChildren = spacedChildren;
exports.stackDefaultStyles = stackDefaultStyles;
exports.stylePropsAll = stylePropsAll;
exports.stylePropsText = stylePropsText;
exports.stylePropsTextOnly = stylePropsTextOnly;
exports.stylePropsTransform = stylePropsTransform;
exports.stylePropsUnitless = stylePropsUnitless;
exports.stylePropsView = stylePropsView;
exports.styleToCSS = styleToCSS;
exports.styled = styled;
exports.themeable = themeable;
exports.tokenCategories = tokenCategories;
exports.transformsToString = transformsToString;
exports.updateConfig = updateConfig;
exports.updateFont = updateFont;
exports.useClientValue = useClientValue;
exports.useComposedRefs = useComposedRefs;
exports.useConfiguration = useConfiguration;
exports.useCreateShallowSetState = useCreateShallowSetState;
exports.useDidFinishSSR = useDidFinishSSR;
exports.useEvent = useEvent;
exports.useGet = useGet;
exports.useIsClientOnly = useIsClientOnly;
exports.useIsTouchDevice = useIsTouchDevice;
exports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;
exports.useMedia = useMedia;
exports.useProps = useProps;
exports.usePropsAndStyle = usePropsAndStyle;
exports.useSplitStyles = useSplitStyles;
exports.useStyle = useStyle;
exports.useTheme = useTheme;
exports.useThemeName = useThemeName;
exports.useThemeWithState = useThemeWithState;
exports.validPseudoKeys = validPseudoKeys;
exports.validStyles = validStyles;
exports.variableToString = variableToString;
exports.webViewFlexCompatStyles = webViewFlexCompatStyles;
exports.withStaticProperties = withStaticProperties;

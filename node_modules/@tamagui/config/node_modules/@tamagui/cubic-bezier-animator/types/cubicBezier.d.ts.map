{
  "mappings": "AAqEA,OAAO,iBAAS,OACd,aACA,aACA,aACA,eACE",
  "names": [],
  "sources": [
    "src/cubicBezier.tsx"
  ],
  "sourcesContent": [
    "/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\n */\n\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\nconst NEWTON_ITERATIONS = 4\nconst NEWTON_MIN_SLOPE = 0.001\nconst SUBDIVISION_PRECISION = 0.0000001\nconst SUBDIVISION_MAX_ITERATIONS = 10\n\nconst kSplineTableSize = 11\nconst kSampleStepSize = 1.0 / (kSplineTableSize - 1.0)\n\nconst float32ArraySupported = typeof Float32Array === 'function'\n\nfunction A(aA1: number, aA2: number) {\n  return 1.0 - 3.0 * aA2 + 3.0 * aA1\n}\nfunction B(aA1: number, aA2: number) {\n  return 3.0 * aA2 - 6.0 * aA1\n}\nfunction C(aA1: number) {\n  return 3.0 * aA1\n}\n\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nfunction calcBezier(aT: number, aA1: number, aA2: number) {\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT\n}\n\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\nfunction getSlope(aT: number, aA1: number, aA2: number) {\n  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1)\n}\n\nfunction binarySubdivide(aX: number, aA: number, aB: number, mX1: number, mX2: number) {\n  let currentX: number\n  let currentT: number\n  let i = 0\n  do {\n    currentT = aA + (aB - aA) / 2.0\n    currentX = calcBezier(currentT, mX1, mX2) - aX\n    if (currentX > 0.0) {\n      aB = currentT\n    } else {\n      aA = currentT\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS)\n  return currentT\n}\n\nfunction newtonRaphsonIterate(aX: number, aGuessT: number, mX1: number, mX2: number) {\n  for (let i = 0; i < NEWTON_ITERATIONS; ++i) {\n    const currentSlope = getSlope(aGuessT, mX1, mX2)\n    if (currentSlope === 0.0) {\n      return aGuessT\n    }\n    const currentX = calcBezier(aGuessT, mX1, mX2) - aX\n    aGuessT -= currentX / currentSlope\n  }\n  return aGuessT\n}\n\nfunction LinearEasing(x: number): number {\n  return x\n}\n\nexport function bezier(\n  mX1: number,\n  mY1: number,\n  mX2: number,\n  mY2: number\n): (x: number) => number {\n  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range')\n  }\n\n  if (mX1 === mY1 && mX2 === mY2) {\n    return LinearEasing\n  }\n\n  // Precompute samples table\n  const sampleValues = float32ArraySupported\n    ? new Float32Array(kSplineTableSize)\n    : new Array(kSplineTableSize)\n  for (let i = 0; i < kSplineTableSize; ++i) {\n    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2)\n  }\n\n  function getTForX(aX) {\n    let intervalStart = 0.0\n    let currentSample = 1\n    const lastSample = kSplineTableSize - 1\n\n    for (\n      ;\n      currentSample !== lastSample && sampleValues[currentSample] <= aX;\n      ++currentSample\n    ) {\n      intervalStart += kSampleStepSize\n    }\n    --currentSample\n\n    // Interpolate to provide an initial guess for t\n    const dist =\n      (aX - sampleValues[currentSample]) /\n      (sampleValues[currentSample + 1] - sampleValues[currentSample])\n    const guessForT = intervalStart + dist * kSampleStepSize\n\n    const initialSlope = getSlope(guessForT, mX1, mX2)\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2)\n    }\n    if (initialSlope === 0.0) {\n      return guessForT\n    }\n    return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2)\n  }\n\n  return function BezierEasing(x: number) {\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (x === 0 || x === 1) {\n      return x\n    }\n    return calcBezier(getTForX(x), mY1, mY2)\n  }\n}\n"
  ],
  "version": 3
}
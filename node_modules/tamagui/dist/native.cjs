"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a, prop, b2[prop]);
    }
  return a;
};
var __spreadProps = (a, b2) => __defProps(a, __getOwnPropDescs(b2));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const React = require("react");
function _interopNamespaceDefault(e2) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e2) {
    for (const k in e2) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e2, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e2[k]
        });
      }
    }
  }
  n.default = e2;
  return Object.freeze(n);
}
function _mergeNamespaces(n, m) {
  for (var i = 0; i < m.length; i++) {
    const e2 = m[i];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k in e2) {
        if (k !== "default" && !(k in n)) {
          const d = Object.getOwnPropertyDescriptor(e2, k);
          if (d) {
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: () => e2[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
const React__namespace = /* @__PURE__ */ _interopNamespaceDefault(React);
if (typeof globalThis["__DEV__"] === "undefined") {
  globalThis["__DEV__"] = false;
}
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production;
function requireReactJsxRuntime_production() {
  if (hasRequiredReactJsxRuntime_production) return reactJsxRuntime_production;
  hasRequiredReactJsxRuntime_production = 1;
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
  function jsxProd(type, config, maybeKey) {
    var key = null;
    void 0 !== maybeKey && (key = "" + maybeKey);
    void 0 !== config.key && (key = "" + config.key);
    if ("key" in config) {
      maybeKey = {};
      for (var propName in config)
        "key" !== propName && (maybeKey[propName] = config[propName]);
    } else maybeKey = config;
    config = maybeKey.ref;
    return {
      $$typeof: REACT_ELEMENT_TYPE,
      type,
      key,
      ref: void 0 !== config ? config : null,
      props: maybeKey
    };
  }
  reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE;
  reactJsxRuntime_production.jsx = jsxProd;
  reactJsxRuntime_production.jsxs = jsxProd;
  return reactJsxRuntime_production;
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  if (hasRequiredJsxRuntime) return jsxRuntime.exports;
  hasRequiredJsxRuntime = 1;
  {
    jsxRuntime.exports = requireReactJsxRuntime_production();
  }
  return jsxRuntime.exports;
}
var jsxRuntimeExports = requireJsxRuntime();
const assets = [];
function getAssetByID(assetId) {
  return assets[assetId - 1];
}
const defaultProps = {
  children: true,
  dataSet: true,
  nativeID: true,
  ref: true,
  suppressHydrationWarning: true,
  testID: true,
  id: true
}, accessibilityProps = {
  accessibilityActiveDescendant: true,
  accessibilityAtomic: true,
  accessibilityAutoComplete: true,
  accessibilityBusy: true,
  accessibilityChecked: true,
  accessibilityColumnCount: true,
  accessibilityColumnIndex: true,
  accessibilityColumnSpan: true,
  accessibilityControls: true,
  accessibilityCurrent: true,
  accessibilityDescribedBy: true,
  accessibilityDetails: true,
  accessibilityDisabled: true,
  accessibilityErrorMessage: true,
  accessibilityExpanded: true,
  accessibilityFlowTo: true,
  accessibilityHasPopup: true,
  accessibilityHidden: true,
  accessibilityInvalid: true,
  accessibilityKeyShortcuts: true,
  accessibilityLabel: true,
  accessibilityLabelledBy: true,
  accessibilityLevel: true,
  accessibilityLiveRegion: true,
  accessibilityModal: true,
  accessibilityMultiline: true,
  accessibilityMultiSelectable: true,
  accessibilityOrientation: true,
  accessibilityOwns: true,
  accessibilityPlaceholder: true,
  accessibilityPosInSet: true,
  accessibilityPressed: true,
  accessibilityReadOnly: true,
  accessibilityRequired: true,
  accessibilityRole: true,
  accessibilityRoleDescription: true,
  accessibilityRowCount: true,
  accessibilityRowIndex: true,
  accessibilityRowSpan: true,
  accessibilitySelected: true,
  accessibilitySetSize: true,
  accessibilitySort: true,
  accessibilityValueMax: true,
  accessibilityValueMin: true,
  accessibilityValueNow: true,
  accessibilityValueText: true,
  dir: true,
  focusable: true
}, clickProps = {
  onClick: true,
  onClickCapture: true,
  onContextMenu: true
}, focusProps = {
  onBlur: true,
  onFocus: true
}, keyboardProps = {
  onKeyDown: true,
  onKeyDownCapture: true,
  onKeyUp: true,
  onKeyUpCapture: true
}, mouseProps = {
  onMouseDown: true,
  onMouseEnter: true,
  onMouseLeave: true,
  onMouseMove: true,
  onMouseOver: true,
  onMouseOut: true,
  onMouseUp: true
}, touchProps = {
  onTouchCancel: true,
  onTouchCancelCapture: true,
  onTouchEnd: true,
  onTouchEndCapture: true,
  onTouchMove: true,
  onTouchMoveCapture: true,
  onTouchStart: true,
  onTouchStartCapture: true
}, styleProps = {
  classList: true,
  style: true
}, forwardedProps = {
  defaultProps,
  accessibilityProps,
  clickProps,
  focusProps,
  keyboardProps,
  mouseProps,
  touchProps,
  styleProps
}, forwardPropsListText = __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, defaultProps), accessibilityProps), clickProps), focusProps), keyboardProps), mouseProps), touchProps), styleProps), {
  href: true,
  lang: true,
  pointerEvents: true
}), forwardPropsListView = __spreadProps(__spreadValues({}, forwardPropsListText), {
  onScroll: true,
  onWheel: true
});
function mergeRefs(...args) {
  return function(node) {
    args.forEach((ref) => {
      if (ref != null) {
        if (typeof ref == "function") {
          ref(node);
          return;
        }
        if (typeof ref == "object") {
          ref.current = node;
          return;
        }
        console.error(`mergeRefs cannot handle Refs of type boolean, number or string, received ref ${String(ref)}`);
      }
    });
  };
}
const canUseDOM$1 = !!(typeof window < "u" && window.document && window.document.createElement);
const rtlScripts = /* @__PURE__ */ new Set(["Arab", "Syrc", "Samr", "Mand", "Thaa", "Mend", "Nkoo", "Adlm", "Rohg", "Hebr"]), rtlLangs = /* @__PURE__ */ new Set([
  "ae",
  // Avestan
  "ar",
  // Arabic
  "arc",
  // Aramaic
  "bcc",
  // Southern Balochi
  "bqi",
  // Bakthiari
  "ckb",
  // Sorani
  "dv",
  // Dhivehi
  "fa",
  "far",
  // Persian
  "glk",
  // Gilaki
  "he",
  "iw",
  // Hebrew
  "khw",
  // Khowar
  "ks",
  // Kashmiri
  "ku",
  // Kurdish
  "mzn",
  // Mazanderani
  "nqo",
  // N'Ko
  "pnb",
  // Western Punjabi
  "ps",
  // Pashto
  "sd",
  // Sindhi
  "ug",
  // Uyghur
  "ur",
  // Urdu
  "yi"
  // Yiddish
]), cache$7 = /* @__PURE__ */ new Map();
function isLocaleRTL(locale) {
  const cachedRTL = cache$7.get(locale);
  if (cachedRTL) return cachedRTL;
  let isRTL = false;
  if (Intl.Locale) {
    const script = new Intl.Locale(locale).maximize().script;
    isRTL = rtlScripts.has(script);
  } else {
    const lang = locale.split("-")[0];
    isRTL = rtlLangs.has(lang);
  }
  return cache$7.set(locale, isRTL), isRTL;
}
const defaultLocale = {
  direction: "ltr",
  locale: "en-US"
}, LocaleContext = React.createContext(defaultLocale);
function getLocaleDirection(locale) {
  return isLocaleRTL(locale) ? "rtl" : "ltr";
}
function LocaleProvider(props) {
  const {
    direction,
    locale,
    children
  } = props;
  return direction || locale ? /* @__PURE__ */ jsxRuntimeExports.jsx(LocaleContext.Provider, {
    value: {
      direction: locale ? getLocaleDirection(locale) : direction,
      locale
    },
    children
  }) : children;
}
function useLocaleContext() {
  return React.useContext(LocaleContext);
}
function useCreateShallowSetState(setter, debug) {
  return React.useCallback(function(stateOrGetState) {
    setter(function(prev) {
      var next = typeof stateOrGetState == "function" ? stateOrGetState(prev) : stateOrGetState, update2 = mergeIfNotShallowEqual(prev, next);
      return update2;
    });
  }, [setter, debug]);
}
function mergeIfNotShallowEqual(prev, next) {
  return !prev || !next || isEqualShallow(prev, next) ? prev || next : __spreadValues(__spreadValues({}, prev), next);
}
function isEqualShallow(prev, next) {
  for (var key in next) if (prev[key] !== next[key]) return false;
  return true;
}
function _instanceof$1(left, right) {
  return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
}
var LayoutHandlers = /* @__PURE__ */ new WeakMap(), LayoutDisableKey = /* @__PURE__ */ new WeakMap(), Nodes = /* @__PURE__ */ new Set(), IntersectionState = /* @__PURE__ */ new WeakMap(), DisableLayoutContextKey = /* @__PURE__ */ React.createContext(""), LayoutMeasurementController = function(param) {
  var {
    disable,
    children
  } = param, id2 = React.useId();
  return useIsomorphicLayoutEffect(function() {
  }, [disable, id2]), /* @__PURE__ */ jsxRuntimeExports.jsx(DisableLayoutContextKey.Provider, {
    value: id2,
    children
  });
};
function setOnLayoutStrategy(state) {
}
var NodeRectCache = /* @__PURE__ */ new WeakMap(), LastChangeTime = /* @__PURE__ */ new WeakMap(), avoidUpdates = true, queuedUpdates = /* @__PURE__ */ new Map();
function enable() {
  avoidUpdates && (avoidUpdates = false, queuedUpdates && (queuedUpdates.forEach(function(cb) {
    return cb();
  }), queuedUpdates.clear()));
}
var getElementLayoutEvent = function(nodeRect, parentRect) {
  return {
    nativeEvent: {
      layout: getRelativeDimensions(nodeRect, parentRect),
      target: nodeRect
    },
    timeStamp: Date.now()
  };
}, getRelativeDimensions = function(a, b2) {
  var {
    height,
    left,
    top,
    width
  } = a, x = left - b2.left, y = top - b2.top;
  return {
    x,
    y,
    width,
    height,
    pageX: a.left,
    pageY: a.top
  };
};
function useElementLayout$1(ref, onLayout) {
  var _ref_current, disableKey = React.useContext(DisableLayoutContextKey), node = ensureWebElement((_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.host);
  node && onLayout && (LayoutHandlers.set(node, onLayout), LayoutDisableKey.set(node, disableKey)), useIsomorphicLayoutEffect(function() {
    var _ref_current2;
    if (onLayout) {
      var node2 = (_ref_current2 = ref.current) === null || _ref_current2 === void 0 ? void 0 : _ref_current2.host;
      if (node2) {
        Nodes.add(node2);
        var parentNode = node2.parentNode;
        return parentNode && onLayout(getElementLayoutEvent(node2.getBoundingClientRect(), parentNode.getBoundingClientRect())), function() {
          Nodes.delete(node2), LayoutHandlers.delete(node2), NodeRectCache.delete(node2), LastChangeTime.delete(node2), IntersectionState.delete(node2);
        };
      }
    }
  }, [ref, !!onLayout]);
}
function ensureWebElement(x) {
  if (!(typeof HTMLElement > "u")) return _instanceof$1(x, HTMLElement) ? x : void 0;
}
var getBoundingClientRectAsync = function(node) {
  return new Promise(function(res) {
    if (!node || node.nodeType !== 1) return res(false);
    var io = new IntersectionObserver(function(entries) {
      return io.disconnect(), res(entries[0].boundingClientRect);
    }, {
      threshold: 0
    });
    io.observe(node);
  });
}, measureNode = function(node, relativeTo) {
  return __async(this, null, function* () {
    var relativeNode = relativeTo || (node == null ? void 0 : node.parentElement);
    if (_instanceof$1(relativeNode, HTMLElement)) {
      var [nodeDim, relativeNodeDim] = yield Promise.all([getBoundingClientRectAsync(node), getBoundingClientRectAsync(relativeNode)]);
      if (relativeNodeDim && nodeDim) return getRelativeDimensions(nodeDim, relativeNodeDim);
    }
    return null;
  });
}, measure = function(node, callback) {
  return __async(this, null, function* () {
    var out = yield measureNode(node, _instanceof$1(node.parentNode, HTMLElement) ? node.parentNode : null);
    return out && (callback == null ? void 0 : callback(out.x, out.y, out.width, out.height, out.pageX, out.pageY)), out;
  });
};
function createMeasure(node) {
  return function(callback) {
    return measure(node, callback);
  };
}
var measureInWindow = function(node, callback) {
  return __async(this, null, function* () {
    var out = yield measureNode(node, null);
    return out && (callback == null ? void 0 : callback(out.pageX, out.pageY, out.width, out.height)), out;
  });
}, createMeasureInWindow = function(node) {
  return function(callback) {
    return measureInWindow(node, callback);
  };
}, measureLayout$1 = function(node, relativeNode, callback) {
  return __async(this, null, function* () {
    var out = yield measureNode(node, relativeNode);
    return out && (callback == null ? void 0 : callback(out.x, out.y, out.width, out.height, out.pageX, out.pageY)), out;
  });
};
function createMeasureLayout(node) {
  return function(relativeTo, callback) {
    return measureLayout$1(node, relativeTo, callback);
  };
}
const UNINITIALIZED = typeof Symbol == "function" && typeof Symbol() == "symbol" ? Symbol() : Object.freeze({});
function useStable(getInitialValue) {
  const ref = React__namespace.useRef(UNINITIALIZED);
  return ref.current === UNINITIALIZED && (ref.current = getInitialValue()), ref.current;
}
function usePlatformMethods({
  pointerEvents,
  style
}) {
  return useStable(() => (hostNode) => {
    hostNode != null && (hostNode.measure = createMeasure(hostNode), hostNode.measureLayout = createMeasureLayout(hostNode), hostNode.measureInWindow = createMeasureInWindow(hostNode));
  });
}
const TextAncestorContext = React.createContext(false);
var keyName = "__reactResponderId", canUseDOM = !!(typeof window < "u" && window.document && window.document.createElement), getBoundingClientRect = function(node) {
  if (node && node.nodeType === 1 && node.getBoundingClientRect) return node.getBoundingClientRect();
};
function getEventPath(domEvent) {
  if (domEvent.type === "selectionchange") {
    var _window_getSelection, target = (_window_getSelection = window.getSelection()) === null || _window_getSelection === void 0 ? void 0 : _window_getSelection.anchorNode;
    return composedPathFallback(target);
  }
  var path = domEvent.composedPath != null ? domEvent.composedPath() : composedPathFallback(domEvent.target);
  return path;
}
function composedPathFallback(target) {
  for (var path = []; target != null && target !== document.body; ) path.push(target), target = target.parentNode;
  return path;
}
function getResponderId(node) {
  return node != null ? node[keyName] : null;
}
function setResponderId(node, id2) {
  node != null && (node[keyName] = id2);
}
function getResponderPaths(domEvent) {
  for (var idPath = [], nodePath = [], eventPath = getEventPath(domEvent), i = 0; i < eventPath.length; i++) {
    var node = eventPath[i], id2 = getResponderId(node);
    id2 != null && (idPath.push(id2), nodePath.push(node));
  }
  return {
    idPath,
    nodePath
  };
}
function getLowestCommonAncestor(pathA, pathB) {
  var pathALength = pathA.length, pathBLength = pathB.length;
  if (
    // If either path is empty
    pathALength === 0 || pathBLength === 0 || // If the last elements aren't the same there can't be a common ancestor
    // that is connected to the responder system
    pathA[pathALength - 1] !== pathB[pathBLength - 1]
  ) return null;
  var itemA = pathA[0], indexA = 0, itemB = pathB[0], indexB = 0;
  pathALength - pathBLength > 0 && (indexA = pathALength - pathBLength, itemA = pathA[indexA], pathALength = pathBLength), pathBLength - pathALength > 0 && (indexB = pathBLength - pathALength, itemB = pathB[indexB], pathBLength = pathALength);
  for (var depth = pathALength; depth--; ) {
    if (itemA === itemB) return itemA;
    itemA = pathA[indexA++], itemB = pathB[indexB++];
  }
  return null;
}
function hasTargetTouches(target, touches) {
  if (!touches || touches.length === 0) return false;
  for (var i = 0; i < touches.length; i++) {
    var node = touches[i].target;
    if (node != null && target.contains(node)) return true;
  }
  return false;
}
function hasValidSelection(domEvent) {
  return domEvent.type === "selectionchange" ? isSelectionValid() : domEvent.type === "select";
}
function isPrimaryPointerDown(domEvent) {
  var {
    altKey,
    button,
    buttons,
    ctrlKey,
    type
  } = domEvent, isTouch = type === "touchstart" || type === "touchmove", isPrimaryMouseDown = type === "mousedown" && (button === 0 || buttons === 1), isPrimaryMouseMove = type === "mousemove" && buttons === 1, noModifiers = altKey === false && ctrlKey === false;
  return !!(isTouch || isPrimaryMouseDown && noModifiers || isPrimaryMouseMove && noModifiers);
}
function isSelectionValid() {
  var selection = window.getSelection();
  if (!selection) return false;
  var string = selection.toString(), anchorNode = selection.anchorNode, focusNode = selection.focusNode, isTextNode = anchorNode && anchorNode.nodeType === window.Node.TEXT_NODE || focusNode && focusNode.nodeType === window.Node.TEXT_NODE;
  return string.length >= 1 && string !== `
` && !!isTextNode;
}
var emptyFunction = function() {
}, emptyObject$6 = {}, emptyArray = [];
function normalizeIdentifier(identifier) {
  return identifier > 20 ? identifier % 20 : identifier;
}
function createResponderEvent(domEvent, responderTouchHistoryStore2) {
  var rect, propagationWasStopped = false, changedTouches, touches, domEventChangedTouches = domEvent.changedTouches, domEventType = domEvent.type, metaKey = domEvent.metaKey === true, shiftKey = domEvent.shiftKey === true, force = (domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].force) || 0, identifier = normalizeIdentifier((domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].identifier) || 0), clientX = (domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].clientX) || domEvent.clientX, clientY = (domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].clientY) || domEvent.clientY, pageX = (domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].pageX) || domEvent.pageX, pageY = (domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].pageY) || domEvent.pageY, preventDefault = typeof domEvent.preventDefault == "function" ? domEvent.preventDefault.bind(domEvent) : emptyFunction, timestamp = domEvent.timeStamp;
  function normalizeTouches(touches2) {
    return Array.prototype.slice.call(touches2).map(function(touch) {
      return {
        force: touch.force,
        identifier: normalizeIdentifier(touch.identifier),
        get locationX() {
          return locationX(touch.clientX);
        },
        get locationY() {
          return locationY(touch.clientY);
        },
        pageX: touch.pageX,
        pageY: touch.pageY,
        target: touch.target,
        timestamp
      };
    });
  }
  if (domEventChangedTouches != null) changedTouches = normalizeTouches(domEventChangedTouches), touches = normalizeTouches(domEvent.touches);
  else {
    var emulatedTouches = [{
      force,
      identifier,
      get locationX() {
        return locationX(clientX);
      },
      get locationY() {
        return locationY(clientY);
      },
      pageX,
      pageY,
      target: domEvent.target,
      timestamp
    }];
    changedTouches = emulatedTouches, touches = domEventType === "mouseup" || domEventType === "dragstart" ? emptyArray : emulatedTouches;
  }
  var responderEvent = {
    bubbles: true,
    cancelable: true,
    // `currentTarget` is set before dispatch
    currentTarget: null,
    defaultPrevented: domEvent.defaultPrevented,
    dispatchConfig: emptyObject$6,
    eventPhase: domEvent.eventPhase,
    isDefaultPrevented() {
      return domEvent.defaultPrevented;
    },
    isPropagationStopped() {
      return propagationWasStopped;
    },
    isTrusted: domEvent.isTrusted,
    nativeEvent: {
      altKey: false,
      ctrlKey: false,
      metaKey,
      shiftKey,
      changedTouches,
      force,
      identifier,
      get locationX() {
        return locationX(clientX);
      },
      get locationY() {
        return locationY(clientY);
      },
      pageX,
      pageY,
      target: domEvent.target,
      timestamp,
      touches,
      type: domEventType
    },
    persist: emptyFunction,
    preventDefault,
    stopPropagation() {
      propagationWasStopped = true;
    },
    target: domEvent.target,
    timeStamp: timestamp,
    touchHistory: responderTouchHistoryStore2.touchHistory
  };
  function locationX(x) {
    if (rect = rect || getBoundingClientRect(responderEvent.currentTarget), rect) return x - rect.left;
  }
  function locationY(y) {
    if (rect = rect || getBoundingClientRect(responderEvent.currentTarget), rect) return y - rect.top;
  }
  return responderEvent;
}
var MOUSE_DOWN = "mousedown", MOUSE_MOVE = "mousemove", MOUSE_UP = "mouseup", MOUSE_CANCEL = "dragstart", TOUCH_START = "touchstart", TOUCH_MOVE = "touchmove", TOUCH_END = "touchend", TOUCH_CANCEL = "touchcancel", SCROLL = "scroll", SELECT = "select", SELECTION_CHANGE = "selectionchange";
function isStartish(eventType) {
  return eventType === TOUCH_START || eventType === MOUSE_DOWN;
}
function isMoveish(eventType) {
  return eventType === TOUCH_MOVE || eventType === MOUSE_MOVE;
}
function isEndish(eventType) {
  return eventType === TOUCH_END || eventType === MOUSE_UP || isCancelish(eventType);
}
function isCancelish(eventType) {
  return eventType === TOUCH_CANCEL || eventType === MOUSE_CANCEL;
}
function isScroll(eventType) {
  return eventType === SCROLL;
}
function isSelectionChange(eventType) {
  return eventType === SELECT || eventType === SELECTION_CHANGE;
}
function _class_call_check$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor && (descriptor.writable = true), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class$1(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties$1(Constructor.prototype, protoProps), Constructor;
}
function _define_property$1(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: true,
    configurable: true,
    writable: true
  }) : obj[key] = value, obj;
}
var ResponderTouchHistoryStore = /* @__PURE__ */ (function() {
  function ResponderTouchHistoryStore2() {
    _class_call_check$1(this, ResponderTouchHistoryStore2), _define_property$1(this, "_touchHistory", {
      touchBank: [],
      //Array<TouchRecord>
      numberActiveTouches: 0,
      // If there is only one active touch, we remember its location. This prevents
      // us having to loop through all of the touches all the time in the most
      // common case.
      indexOfSingleActiveTouch: -1,
      mostRecentTimeStamp: 0
    });
  }
  return _create_class$1(ResponderTouchHistoryStore2, [{
    key: "recordTouchTrack",
    value: function(topLevelType, nativeEvent) {
      var touchHistory = this._touchHistory;
      if (isMoveish(topLevelType)) nativeEvent.changedTouches.forEach(function(touch) {
        return recordTouchMove(touch, touchHistory);
      });
      else if (isStartish(topLevelType)) nativeEvent.changedTouches.forEach(function(touch) {
        return recordTouchStart(touch, touchHistory);
      }), touchHistory.numberActiveTouches = nativeEvent.touches.length, touchHistory.numberActiveTouches === 1 && (touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier);
      else if (isEndish(topLevelType) && (nativeEvent.changedTouches.forEach(function(touch) {
        return recordTouchEnd(touch, touchHistory);
      }), touchHistory.numberActiveTouches = nativeEvent.touches.length, touchHistory.numberActiveTouches === 1)) {
        for (var {
          touchBank
        } = touchHistory, i = 0; i < touchBank.length; i++) {
          var touchTrackToCheck = touchBank[i];
          if (touchTrackToCheck == null ? void 0 : touchTrackToCheck.touchActive) {
            touchHistory.indexOfSingleActiveTouch = i;
            break;
          }
        }
      }
    }
  }, {
    key: "touchHistory",
    get: function() {
      return this._touchHistory;
    }
  }]), ResponderTouchHistoryStore2;
})(), MAX_TOUCH_BANK = 20;
function timestampForTouch(touch) {
  return touch.timeStamp || touch.timestamp;
}
function createTouchRecord(touch) {
  return {
    touchActive: true,
    startPageX: touch.pageX,
    startPageY: touch.pageY,
    startTimeStamp: timestampForTouch(touch),
    currentPageX: touch.pageX,
    currentPageY: touch.pageY,
    currentTimeStamp: timestampForTouch(touch),
    previousPageX: touch.pageX,
    previousPageY: touch.pageY,
    previousTimeStamp: timestampForTouch(touch)
  };
}
function resetTouchRecord(touchRecord, touch) {
  touchRecord.touchActive = true, touchRecord.startPageX = touch.pageX, touchRecord.startPageY = touch.pageY, touchRecord.startTimeStamp = timestampForTouch(touch), touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchRecord.previousPageX = touch.pageX, touchRecord.previousPageY = touch.pageY, touchRecord.previousTimeStamp = timestampForTouch(touch);
}
function getTouchIdentifier(param) {
  var {
    identifier
  } = param;
  return identifier == null && console.error("Touch object is missing identifier."), identifier;
}
function recordTouchStart(touch, touchHistory) {
  var identifier = getTouchIdentifier(touch), touchRecord = touchHistory.touchBank[identifier];
  touchRecord ? resetTouchRecord(touchRecord, touch) : touchHistory.touchBank[identifier] = createTouchRecord(touch), touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
}
function recordTouchMove(touch, touchHistory) {
  var touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];
  touchRecord ? (touchRecord.touchActive = true, touchRecord.previousPageX = touchRecord.currentPageX, touchRecord.previousPageY = touchRecord.currentPageY, touchRecord.previousTimeStamp = touchRecord.currentTimeStamp, touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchHistory.mostRecentTimeStamp = timestampForTouch(touch)) : console.warn(`Cannot record touch move without a touch start.
`, `Touch Move: ${printTouch(touch)}
`, `Touch Bank: ${printTouchBank(touchHistory)}`);
}
function recordTouchEnd(touch, touchHistory) {
  var touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];
  touchRecord ? (touchRecord.touchActive = false, touchRecord.previousPageX = touchRecord.currentPageX, touchRecord.previousPageY = touchRecord.currentPageY, touchRecord.previousTimeStamp = touchRecord.currentTimeStamp, touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchHistory.mostRecentTimeStamp = timestampForTouch(touch)) : console.warn(`Cannot record touch end without a touch start.
`, `Touch End: ${printTouch(touch)}
`, `Touch Bank: ${printTouchBank(touchHistory)}`);
}
function printTouch(touch) {
  return JSON.stringify({
    identifier: touch.identifier,
    pageX: touch.pageX,
    pageY: touch.pageY,
    timestamp: timestampForTouch(touch)
  });
}
function printTouchBank(touchHistory) {
  var {
    touchBank
  } = touchHistory, printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));
  return touchBank.length > MAX_TOUCH_BANK && (printed += ` (original size: ${touchBank.length})`), printed;
}
var emptyObject$5 = {}, startRegistration = ["onStartShouldSetResponderCapture", "onStartShouldSetResponder", {
  bubbles: true
}], moveRegistration = ["onMoveShouldSetResponderCapture", "onMoveShouldSetResponder", {
  bubbles: true
}], scrollRegistration = ["onScrollShouldSetResponderCapture", "onScrollShouldSetResponder", {
  bubbles: false
}], shouldSetResponderEvents = {
  touchstart: startRegistration,
  mousedown: startRegistration,
  touchmove: moveRegistration,
  mousemove: moveRegistration,
  scroll: scrollRegistration
}, emptyResponder = {
  id: null,
  idPath: null,
  node: null
}, responderListenersMap = /* @__PURE__ */ new Map(), isEmulatingMouseEvents = false, trackedTouchCount = 0, currentResponder = {
  id: null,
  node: null,
  idPath: null
}, responderTouchHistoryStore = new ResponderTouchHistoryStore();
function changeCurrentResponder(responder) {
  currentResponder = responder;
}
function getResponderConfig(id2) {
  var config = responderListenersMap.get(id2);
  return config != null ? config : emptyObject$5;
}
function eventListener(domEvent) {
  var eventType = domEvent.type, eventTarget = domEvent.target;
  if (eventType === "touchstart" && (isEmulatingMouseEvents = true), (eventType === "touchmove" || trackedTouchCount > 1) && (isEmulatingMouseEvents = false), // Ignore browser emulated mouse events
  !(eventType === "mousedown" && isEmulatingMouseEvents || eventType === "mousemove" && isEmulatingMouseEvents || // Ignore mousemove if a mousedown didn't occur first
  eventType === "mousemove" && trackedTouchCount < 1)) {
    if (isEmulatingMouseEvents && eventType === "mouseup") {
      trackedTouchCount === 0 && (isEmulatingMouseEvents = false);
      return;
    }
    var isStartEvent = isStartish(eventType) && isPrimaryPointerDown(domEvent), isMoveEvent = isMoveish(eventType), isEndEvent = isEndish(eventType), isScrollEvent = isScroll(eventType), isSelectionChangeEvent = isSelectionChange(eventType), responderEvent = createResponderEvent(domEvent, responderTouchHistoryStore);
    (isStartEvent || isMoveEvent || isEndEvent) && (domEvent.touches ? trackedTouchCount = domEvent.touches.length : isStartEvent ? trackedTouchCount = 1 : isEndEvent && (trackedTouchCount = 0), responderTouchHistoryStore.recordTouchTrack(eventType, responderEvent.nativeEvent));
    var eventPaths = getResponderPaths(domEvent), wasNegotiated = false, wantsResponder;
    if (isStartEvent || isMoveEvent || isScrollEvent && trackedTouchCount > 0) {
      var currentResponderIdPath = currentResponder.idPath, eventIdPath = eventPaths.idPath;
      if (currentResponderIdPath != null && eventIdPath != null) {
        var lowestCommonAncestor = getLowestCommonAncestor(currentResponderIdPath, eventIdPath);
        if (lowestCommonAncestor != null) {
          var indexOfLowestCommonAncestor = eventIdPath.indexOf(lowestCommonAncestor), index2 = indexOfLowestCommonAncestor + (lowestCommonAncestor === currentResponder.id ? 1 : 0);
          eventPaths = {
            idPath: eventIdPath.slice(index2),
            nodePath: eventPaths.nodePath.slice(index2)
          };
        } else eventPaths = null;
      }
      eventPaths != null && (wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent), wantsResponder != null && (attemptTransfer(responderEvent, wantsResponder), wasNegotiated = true));
    }
    if (currentResponder.id != null && currentResponder.node != null) {
      var {
        id: id2,
        node
      } = currentResponder, {
        onResponderStart,
        onResponderMove,
        onResponderEnd,
        onResponderRelease,
        onResponderTerminate,
        onResponderTerminationRequest
      } = getResponderConfig(id2);
      if (responderEvent.bubbles = false, responderEvent.cancelable = false, responderEvent.currentTarget = node, isStartEvent) onResponderStart != null && (responderEvent.dispatchConfig.registrationName = "onResponderStart", onResponderStart(responderEvent));
      else if (isMoveEvent) onResponderMove != null && (responderEvent.dispatchConfig.registrationName = "onResponderMove", onResponderMove(responderEvent));
      else {
        var isTerminateEvent = isCancelish(eventType) || // native context menu
        eventType === "contextmenu" || // window blur
        eventType === "blur" && eventTarget === window || // responder (or ancestors) blur
        eventType === "blur" && eventTarget.contains(node) && domEvent.relatedTarget !== node || // native scroll without using a pointer
        isScrollEvent && trackedTouchCount === 0 || // native scroll on node that is parent of the responder (allow siblings to scroll)
        isScrollEvent && eventTarget.contains(node) && eventTarget !== node || // native select/selectionchange on node
        isSelectionChangeEvent && hasValidSelection(domEvent), isReleaseEvent = isEndEvent && !isTerminateEvent && !hasTargetTouches(node, domEvent.touches);
        if (isEndEvent && onResponderEnd != null && (responderEvent.dispatchConfig.registrationName = "onResponderEnd", onResponderEnd(responderEvent)), isReleaseEvent && (onResponderRelease != null && (responderEvent.dispatchConfig.registrationName = "onResponderRelease", onResponderRelease(responderEvent)), changeCurrentResponder(emptyResponder)), isTerminateEvent) {
          var shouldTerminate = true;
          (eventType === "contextmenu" || eventType === "scroll" || eventType === "selectionchange") && (wasNegotiated ? shouldTerminate = false : onResponderTerminationRequest != null && (responderEvent.dispatchConfig.registrationName = "onResponderTerminationRequest", onResponderTerminationRequest(responderEvent) === false && (shouldTerminate = false))), shouldTerminate && (onResponderTerminate != null && (responderEvent.dispatchConfig.registrationName = "onResponderTerminate", onResponderTerminate(responderEvent)), changeCurrentResponder(emptyResponder), isEmulatingMouseEvents = false, trackedTouchCount = 0);
        }
      }
    }
  }
}
function findWantsResponder(eventPaths, domEvent, responderEvent) {
  var shouldSetCallbacks = shouldSetResponderEvents[domEvent.type];
  if (shouldSetCallbacks != null) {
    for (var {
      idPath,
      nodePath
    } = eventPaths, shouldSetCallbackCaptureName = shouldSetCallbacks[0], shouldSetCallbackBubbleName = shouldSetCallbacks[1], {
      bubbles
    } = shouldSetCallbacks[2], check = function(id3, node3, callbackName) {
      var config = getResponderConfig(id3), shouldSetCallback = config[callbackName];
      if (shouldSetCallback != null && (responderEvent.currentTarget = node3, shouldSetCallback(responderEvent) === true)) {
        var prunedIdPath = idPath.slice(idPath.indexOf(id3));
        return {
          id: id3,
          node: node3,
          idPath: prunedIdPath
        };
      }
    }, i = idPath.length - 1; i >= 0; i--) {
      var id2 = idPath[i], node = nodePath[i], result = check(id2, node, shouldSetCallbackCaptureName);
      if (result != null) return result;
      if (responderEvent.isPropagationStopped() === true) return;
    }
    if (bubbles) for (var i1 = 0; i1 < idPath.length; i1++) {
      var id1 = idPath[i1], node1 = nodePath[i1], result1 = check(id1, node1, shouldSetCallbackBubbleName);
      if (result1 != null) return result1;
      if (responderEvent.isPropagationStopped() === true) return;
    }
    else {
      var id22 = idPath[0], node2 = nodePath[0], target = domEvent.target;
      if (target === node2) return check(id22, node2, shouldSetCallbackBubbleName);
    }
  }
}
function attemptTransfer(responderEvent, wantsResponder) {
  var {
    id: currentId,
    node: currentNode
  } = currentResponder, {
    id: id2,
    node
  } = wantsResponder, {
    onResponderGrant,
    onResponderReject
  } = getResponderConfig(id2);
  if (responderEvent.bubbles = false, responderEvent.cancelable = false, responderEvent.currentTarget = node, currentId == null) onResponderGrant != null && (responderEvent.currentTarget = node, responderEvent.dispatchConfig.registrationName = "onResponderGrant", onResponderGrant(responderEvent)), changeCurrentResponder(wantsResponder);
  else {
    var {
      onResponderTerminate,
      onResponderTerminationRequest
    } = getResponderConfig(currentId), allowTransfer = true;
    onResponderTerminationRequest != null && (responderEvent.currentTarget = currentNode, responderEvent.dispatchConfig.registrationName = "onResponderTerminationRequest", onResponderTerminationRequest(responderEvent) === false && (allowTransfer = false)), allowTransfer ? (onResponderTerminate != null && (responderEvent.currentTarget = currentNode, responderEvent.dispatchConfig.registrationName = "onResponderTerminate", onResponderTerminate(responderEvent)), onResponderGrant != null && (responderEvent.currentTarget = node, responderEvent.dispatchConfig.registrationName = "onResponderGrant", onResponderGrant(responderEvent)), changeCurrentResponder(wantsResponder)) : onResponderReject != null && (responderEvent.currentTarget = node, responderEvent.dispatchConfig.registrationName = "onResponderReject", onResponderReject(responderEvent));
  }
}
var documentEventsCapturePhase = ["blur", "scroll"], documentEventsBubblePhase = [
  // mouse
  "mousedown",
  "mousemove",
  "mouseup",
  "dragstart",
  // touch
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel",
  // other
  "contextmenu",
  "select",
  "selectionchange"
], isTamaguiResponderActive = Symbol();
function attachListeners() {
  canUseDOM && !window[isTamaguiResponderActive] && (window.addEventListener("blur", eventListener), documentEventsBubblePhase.forEach(function(eventType) {
    document.addEventListener(eventType, eventListener);
  }), documentEventsCapturePhase.forEach(function(eventType) {
    document.addEventListener(eventType, eventListener, true);
  }), window[isTamaguiResponderActive] = true);
}
function addNode(id2, node, config) {
  setResponderId(node, id2), responderListenersMap.set(id2, config);
}
function removeNode(id2) {
  currentResponder.id === id2 && terminateResponder(), responderListenersMap.has(id2) && responderListenersMap.delete(id2);
}
function terminateResponder() {
  var {
    id: id2,
    node
  } = currentResponder;
  if (id2 != null && node != null) {
    var {
      onResponderTerminate
    } = getResponderConfig(id2);
    if (onResponderTerminate != null) {
      var event = createResponderEvent({}, responderTouchHistoryStore);
      event.currentTarget = node, onResponderTerminate(event);
    }
    changeCurrentResponder(emptyResponder);
  }
  isEmulatingMouseEvents = false, trackedTouchCount = 0;
}
var emptyObject$4 = {}, Attached = /* @__PURE__ */ new WeakMap(), Ids = /* @__PURE__ */ new WeakMap();
function useResponderEvents(hostRef) {
  var configIn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : emptyObject$4, _hostRef_current, config = getResponderConfigIfDefined(configIn), node = (hostRef == null || (_hostRef_current = hostRef.current) === null || _hostRef_current === void 0 ? void 0 : _hostRef_current.host) || (hostRef == null ? void 0 : hostRef.current);
  React__namespace.useEffect(function() {
    if (config !== emptyObject$4) {
      attachListeners(), Ids.has(hostRef) || Ids.set(hostRef, `${Math.random()}`);
      var id2 = Ids.get(hostRef);
      return addNode(id2, node, config), Attached.set(hostRef, true), function() {
        removeNode(node), Attached.set(hostRef, false);
      };
    }
  }, [config, hostRef]);
}
function getResponderConfigIfDefined(param) {
  var {
    onMoveShouldSetResponder,
    onMoveShouldSetResponderCapture,
    onResponderEnd,
    onResponderGrant,
    onResponderMove,
    onResponderReject,
    onResponderRelease,
    onResponderStart,
    onResponderTerminate,
    onResponderTerminationRequest,
    onScrollShouldSetResponder,
    onScrollShouldSetResponderCapture,
    onSelectionChangeShouldSetResponder,
    onSelectionChangeShouldSetResponderCapture,
    onStartShouldSetResponder,
    onStartShouldSetResponderCapture
  } = param;
  return onMoveShouldSetResponder || onMoveShouldSetResponderCapture || onResponderEnd || onResponderGrant || onResponderMove || onResponderReject || onResponderRelease || onResponderStart || onResponderTerminate || onResponderTerminationRequest || onScrollShouldSetResponder || onScrollShouldSetResponderCapture || onSelectionChangeShouldSetResponder || onSelectionChangeShouldSetResponderCapture || onStartShouldSetResponder || onStartShouldSetResponderCapture ? {
    onMoveShouldSetResponder,
    onMoveShouldSetResponderCapture,
    onResponderEnd,
    onResponderGrant,
    onResponderMove,
    onResponderReject,
    onResponderRelease,
    onResponderStart,
    onResponderTerminate,
    onResponderTerminationRequest,
    onScrollShouldSetResponder,
    onScrollShouldSetResponderCapture,
    onSelectionChangeShouldSetResponder,
    onSelectionChangeShouldSetResponderCapture,
    onStartShouldSetResponder,
    onStartShouldSetResponderCapture
  } : emptyObject$4;
}
const isDisabled$1 = (props) => props.disabled || Array.isArray(props.accessibilityStates) && props.accessibilityStates.indexOf("disabled") > -1;
const accessibilityRoleToWebRole = {
  adjustable: "slider",
  button: "button",
  header: "heading",
  image: "img",
  imagebutton: null,
  keyboardkey: null,
  label: null,
  link: "link",
  none: "presentation",
  search: "search",
  summary: "region",
  text: null
}, propsToAriaRole = ({
  accessibilityRole
}) => {
  if (accessibilityRole) {
    const inferredRole = accessibilityRoleToWebRole[accessibilityRole];
    if (inferredRole !== null) return inferredRole || accessibilityRole;
  }
};
const roleComponents = {
  article: "article",
  banner: "header",
  blockquote: "blockquote",
  code: "code",
  complementary: "aside",
  contentinfo: "footer",
  deletion: "del",
  emphasis: "em",
  figure: "figure",
  insertion: "ins",
  form: "form",
  list: "ul",
  listitem: "li",
  main: "main",
  navigation: "nav",
  region: "section",
  strong: "strong"
}, emptyObject$3 = {}, propsToAccessibilityComponent = (props = emptyObject$3) => {
  if (props.accessibilityRole === "label") return "label";
  const role = propsToAriaRole(props);
  if (role) {
    if (role === "heading") {
      const level = props.accessibilityLevel || props["aria-level"];
      return level != null ? `h${level}` : "h1";
    }
    return roleComponents[role];
  }
};
const AccessibilityUtil = {
  isDisabled: isDisabled$1,
  propsToAccessibilityComponent,
  propsToAriaRole
};
var pseudoDescriptorsBase = {
  // order of keys here important! in priority order
  hoverStyle: {
    name: "hover",
    priority: 2
  },
  pressStyle: {
    name: "active",
    stateKey: "press",
    priority: 3
  },
  focusVisibleStyle: {
    name: "focus-visible",
    priority: 4,
    stateKey: "focusVisible"
  },
  focusStyle: {
    name: "focus",
    priority: 4
  },
  focusWithinStyle: {
    name: "focus-within",
    priority: 4,
    stateKey: "focusWithin"
  },
  disabledStyle: {
    name: "disabled",
    priority: 5,
    stateKey: "disabled"
  }
}, pseudoPriorities = {
  hover: pseudoDescriptorsBase.hoverStyle.priority,
  press: pseudoDescriptorsBase.pressStyle.priority,
  focus: pseudoDescriptorsBase.focusStyle.priority,
  focusVisible: pseudoDescriptorsBase.focusVisibleStyle.priority,
  focusWithin: pseudoDescriptorsBase.focusWithinStyle.priority,
  disabled: pseudoDescriptorsBase.disabledStyle.priority
}, pseudoDescriptors = __spreadProps(__spreadValues({}, pseudoDescriptorsBase), {
  enterStyle: {
    name: "enter",
    selector: ".t_unmounted",
    priority: 4
  },
  exitStyle: {
    name: "exit",
    priority: 5
  }
}), defaultMediaImportance = Object.keys(pseudoDescriptors).length;
function _type_of$c(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var mergeProps = function(defaultProps2, props) {
  var out = {};
  for (var key in defaultProps2) key in props || (out[key] = defaultProps2[key]);
  for (var key1 in props) mergeProp(out, defaultProps2, props, key1);
  return out;
}, mergeComponentProps = function(defaultProps2, contextProps, props) {
  var overriddenContext = null;
  if (!defaultProps2 && !contextProps) return [props, overriddenContext];
  if (defaultProps2 && !contextProps) return [mergeProps(defaultProps2, props), overriddenContext];
  var out = {};
  for (var key in defaultProps2) key in props || (out[key] = defaultProps2[key]);
  for (var key1 in contextProps) if (!(key1 in props)) {
    var contextValue = contextProps[key1];
    contextValue !== void 0 && (out[key1] = contextValue);
  }
  for (var key2 in props) mergeProp(out, defaultProps2, props, key2), contextProps && key2 in contextProps && (overriddenContext || (overriddenContext = {}), overriddenContext[key2] = props[key2]);
  return [out, overriddenContext];
};
function mergeProp(out, defaultProps2, props, key) {
  var val = props[key];
  if (defaultProps2 && key in defaultProps2 && (key in pseudoDescriptors || key[0] === "$") && val && (typeof val > "u" ? "undefined" : _type_of$c(val)) === "object") {
    var defaultVal = defaultProps2[key];
    defaultVal && (typeof defaultVal > "u" ? "undefined" : _type_of$c(defaultVal)) === "object" && (val = mergeProps(defaultVal, val));
  }
  out[key] = val;
}
function _type_of$b(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function objectIdentityKey(obj) {
  var k = "";
  for (var key in obj) {
    k += key;
    var arg = obj[key], type = typeof arg > "u" ? "undefined" : _type_of$b(arg);
    if (!arg || type !== "object" && type !== "function") k += type + arg;
    else if (cache$6.has(arg)) k += cache$6.get(arg);
    else {
      var v = Math.random();
      cache$6.set(arg, v), k += v;
    }
  }
  return k;
}
var cache$6 = /* @__PURE__ */ new WeakMap();
var createReactContext = React["createContext"];
function createStyledContext(defaultValues) {
  var namespace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", OGContext = createReactContext(defaultValues), OGProvider = OGContext.Provider, Context = OGContext, scopedContexts = /* @__PURE__ */ new Map(), LastScopeInNamespace = createReactContext(namespace);
  function getOrCreateScopedContext(scope) {
    var ScopedContext = scopedContexts.get(scope);
    return ScopedContext || (ScopedContext = createReactContext(defaultValues), scopedContexts.set(scope, ScopedContext)), ScopedContext;
  }
  var getNamespacedScope = function(scope) {
    return namespace ? `${namespace}--${scope}` : scope;
  }, Provider = function(param) {
    var _a = param, {
      children,
      scope: scopeIn,
      __disableMergeDefaultValues: __disableMergeDefaultValues
    } = _a, values = __objRest(_a, [
      "children",
      "scope",
      // performance: avoid creating objects
      "__disableMergeDefaultValues"
    ]), scope = getNamespacedScope(scopeIn), next = React.useMemo(function() {
      return __disableMergeDefaultValues ? values : mergeProps(defaultValues, values);
    }, [objectIdentityKey(values)]), ScopedProvider = OGProvider;
    return scope && (ScopedProvider = getOrCreateScopedContext(scope).Provider), /* @__PURE__ */ jsxRuntimeExports.jsx(LastScopeInNamespace.Provider, {
      value: scope,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScopedProvider, {
        value: next,
        children
      })
    });
  }, useStyledContext = function() {
    var scopeIn = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", lastScopeInNamespace = React.useContext(LastScopeInNamespace), scope = namespace ? scopeIn ? getNamespacedScope(scopeIn) : lastScopeInNamespace : scopeIn, context2 = scope ? getOrCreateScopedContext(scope) : OGContext, value = React.useContext(context2);
    return value;
  };
  return Context.Provider = Provider, Context.props = defaultValues, Context.context = OGContext, Context.useStyledContext = useStyledContext, Context;
}
var ComponentContext = createStyledContext({
  disableSSR: void 0,
  inText: false,
  language: null,
  animationDriver: null,
  setParentFocusState: null
}), useConfiguration = function() {
  return React.useContext(ComponentContext);
};
var GroupContext = /* @__PURE__ */ React.createContext(null);
var stackDefaultStyles = {};
({
  position: process.env.TAMAGUI_POSITION_STATIC === "1" ? "static" : "relative"
});
var MISSING_THEME_MESSAGE = "Missing theme.";
var conf$1, getSetting = function(key) {
  var _conf_settings_key;
  return (_conf_settings_key = conf$1.settings[key]) !== null && _conf_settings_key !== void 0 ? _conf_settings_key : (
    // @ts-expect-error
    conf$1[key]
  );
}, setConfig = function(next) {
  conf$1 = next;
}, setConfigFont = function(name, font, fontParsed) {
  conf$1.fonts[name] = font, conf$1.fontsParsed[`$${name}`] = fontParsed;
}, getConfig = function() {
  if (!conf$1) throw new Error("Err0");
  return conf$1;
}, tokensMerged;
function setTokens(_) {
  tokensMerged = _;
}
var getTokens = function() {
  var {
    prefixed
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : (
    /**
    * Force either with $ or without $ prefix
    */
    {}
  );
  var {
    tokens,
    tokensParsed
  } = conf$1;
  return prefixed === false ? tokens : prefixed === true ? tokensParsed : tokensMerged;
}, getTokenObject = function(value, group) {
  var _tokensMerged_group, _tokensMerged_, _conf_specificTokens_value;
  return (_conf_specificTokens_value = conf$1.specificTokens[value]) !== null && _conf_specificTokens_value !== void 0 ? _conf_specificTokens_value : group ? (_tokensMerged_group = tokensMerged[group]) === null || _tokensMerged_group === void 0 ? void 0 : _tokensMerged_group[value] : (_tokensMerged_ = tokensMerged[Object.keys(tokensMerged).find(function(cat) {
    return tokensMerged[cat][value];
  }) || ""]) === null || _tokensMerged_ === void 0 ? void 0 : _tokensMerged_[value];
}, getToken = function(value, group) {
  var useVariable = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : isWeb, token = getTokenObject(value, group);
  return useVariable ? token == null ? void 0 : token.variable : token == null ? void 0 : token.val;
}, getTokenValue = function(value, group) {
  if (!(value === "unset" || value === "auto")) return getToken(value, group, false);
}, getThemes = function() {
  return conf$1.themes;
}, configListeners = /* @__PURE__ */ new Set(), onConfiguredOnce = function(cb) {
  conf$1 ? cb(conf$1) : configListeners.add(cb);
}, updateConfig = function(key, value) {
  Object.assign(conf$1[key], value);
}, getFont = function(name) {
  var _Object_entries_find, conf2 = getConfig(), _conf_fontsParsed_name;
  return (_conf_fontsParsed_name = conf2.fontsParsed[name]) !== null && _conf_fontsParsed_name !== void 0 ? _conf_fontsParsed_name : (_Object_entries_find = Object.entries(conf2.fontsParsed).find(function(param) {
    var [k] = param, _conf_fontsParsed_k_family, _conf_fontsParsed_k;
    return ((_conf_fontsParsed_k = conf2.fontsParsed[k]) === null || _conf_fontsParsed_k === void 0 || (_conf_fontsParsed_k_family = _conf_fontsParsed_k.family) === null || _conf_fontsParsed_k_family === void 0 ? void 0 : _conf_fontsParsed_k_family.val) === name;
  })) === null || _Object_entries_find === void 0 ? void 0 : _Object_entries_find[1];
};
function setupDev(conf2) {
}
var cache$5 = /* @__PURE__ */ new Map(), cacheSize = 0, simpleHash = function(strIn) {
  var hashMin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;
  if (cache$5.has(strIn)) return cache$5.get(strIn);
  var str = strIn;
  str[0] === "v" && str.startsWith("var(") && (str = str.slice(6, str.length - 1));
  for (var hash = 0, valids = "", added = 0, len = str.length, i = 0; i < len; i++) {
    if (hashMin !== "strict" && added <= hashMin) {
      var char = str.charCodeAt(i);
      if (char === 46) {
        valids += "--";
        continue;
      }
      if (isValidCSSCharCode(char)) {
        added++, valids += str[i];
        continue;
      }
    }
    hash = hashChar(hash, str[i]);
  }
  var res = valids + (hash ? Math.abs(hash) : "");
  return cacheSize > 1e4 && (cache$5.clear(), cacheSize = 0), cache$5.set(strIn, res), cacheSize++, res;
}, hashChar = function(hash, c) {
  return Math.imul(31, hash) + c.charCodeAt(0) | 0;
};
function isValidCSSCharCode(code) {
  return (
    // A-Z
    code >= 65 && code <= 90 || // a-z
    code >= 97 && code <= 122 || // _
    code === 95 || // -
    code === 45 || // 0-9
    code >= 48 && code <= 57
  );
}
function clamp$1(value, param) {
  var [min2, max2] = param;
  return Math.min(max2, Math.max(min2, value));
}
function _type_of$a(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function composeEventHandlers(og, next) {
  var {
    checkDefaultPrevented = true
  } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  return !og || !next ? next || og || void 0 : function(event) {
    if (og == null ? void 0 : og(event), !event || !(checkDefaultPrevented && (typeof event > "u" ? "undefined" : _type_of$a(event)) === "object" && "defaultPrevented" in event) || // @ts-ignore
    "defaultPrevented" in event && !event.defaultPrevented) return next == null ? void 0 : next(event);
  };
}
var StyleObjectProperty = 0, StyleObjectValue = 1, StyleObjectIdentifier = 2, StyleObjectPseudo = 3, StyleObjectRules = 4;
var ALL_PLATFORMS = ["web", "android", "ios"];
function shouldRenderNativePlatform(nativeProp) {
  if (!nativeProp) return null;
  var userRequestedPlatforms = resolvePlatformNames(nativeProp), _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
  try {
    for (var _iterator = ALL_PLATFORMS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var platform2 = _step.value;
      if (platform2 === currentPlatform && userRequestedPlatforms.has(platform2)) return platform2;
    }
  } catch (err) {
    _didIteratorError = true, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError) throw _iteratorError;
    }
  }
  return null;
}
function resolvePlatformNames(nativeProp) {
  var platforms2 = nativeProp === true ? (
    // all native platforms
    ALL_PLATFORMS
  ) : nativeProp === false ? (
    // no native platform
    []
  ) : Array.isArray(nativeProp) ? nativeProp : [nativeProp], set = new Set(platforms2);
  return set.has("mobile") && (set.add("android"), set.add("ios"), set.delete("mobile")), set;
}
var textColors = {
  color: true,
  textDecorationColor: true,
  textShadowColor: true
}, tokenCategories = {
  radius: {
    borderRadius: true,
    borderTopLeftRadius: true,
    borderTopRightRadius: true,
    borderBottomLeftRadius: true,
    borderBottomRightRadius: true,
    // logical
    borderStartStartRadius: true,
    borderStartEndRadius: true,
    borderEndStartRadius: true,
    borderEndEndRadius: true
  },
  size: {
    width: true,
    height: true,
    minWidth: true,
    minHeight: true,
    maxWidth: true,
    maxHeight: true,
    blockSize: true,
    minBlockSize: true,
    maxBlockSize: true,
    inlineSize: true,
    minInlineSize: true,
    maxInlineSize: true
  },
  zIndex: {
    zIndex: true
  },
  color: __spreadValues({
    backgroundColor: true,
    borderColor: true,
    borderBlockStartColor: true,
    borderBlockEndColor: true,
    borderBlockColor: true,
    borderBottomColor: true,
    borderInlineColor: true,
    borderInlineStartColor: true,
    borderInlineEndColor: true,
    borderTopColor: true,
    borderLeftColor: true,
    borderRightColor: true,
    borderEndColor: true,
    borderStartColor: true,
    shadowColor: true
  }, textColors)
}, stylePropsUnitless = {
  WebkitLineClamp: true,
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexOrder: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  fontWeight: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowGap: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnGap: true,
  gridColumnStart: true,
  gridTemplateColumns: true,
  gridTemplateAreas: true,
  lineClamp: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  scale: true,
  scaleX: true,
  scaleY: true,
  scaleZ: true,
  shadowOpacity: true
}, stylePropsTransform = {
  x: true,
  y: true,
  scale: true,
  perspective: true,
  scaleX: true,
  scaleY: true,
  skewX: true,
  skewY: true,
  matrix: true,
  rotate: true,
  rotateY: true,
  rotateX: true,
  rotateZ: true
}, stylePropsView = __spreadValues(__spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
  backfaceVisibility: true,
  borderBottomEndRadius: true,
  borderBottomStartRadius: true,
  borderBottomWidth: true,
  borderLeftWidth: true,
  borderRightWidth: true,
  borderBlockWidth: true,
  borderBlockEndWidth: true,
  borderBlockStartWidth: true,
  borderInlineWidth: true,
  borderInlineEndWidth: true,
  borderInlineStartWidth: true,
  borderStyle: true,
  borderBlockStyle: true,
  borderBlockEndStyle: true,
  borderBlockStartStyle: true,
  borderInlineStyle: true,
  borderInlineEndStyle: true,
  borderInlineStartStyle: true,
  borderTopEndRadius: true,
  borderTopStartRadius: true,
  borderTopWidth: true,
  borderWidth: true,
  transform: true,
  transformOrigin: true,
  alignContent: true,
  alignItems: true,
  alignSelf: true,
  borderEndWidth: true,
  borderStartWidth: true,
  bottom: true,
  display: true,
  end: true,
  flexBasis: true,
  flexDirection: true,
  flexWrap: true,
  gap: true,
  columnGap: true,
  rowGap: true,
  justifyContent: true,
  left: true,
  margin: true,
  marginBlock: true,
  marginBlockEnd: true,
  marginBlockStart: true,
  marginInline: true,
  marginInlineStart: true,
  marginInlineEnd: true,
  marginBottom: true,
  marginEnd: true,
  marginHorizontal: true,
  marginLeft: true,
  marginRight: true,
  marginStart: true,
  marginTop: true,
  marginVertical: true,
  overflow: true,
  padding: true,
  paddingBottom: true,
  paddingInline: true,
  paddingBlock: true,
  paddingBlockStart: true,
  paddingInlineEnd: true,
  paddingInlineStart: true,
  paddingEnd: true,
  paddingHorizontal: true,
  paddingLeft: true,
  paddingRight: true,
  paddingStart: true,
  paddingTop: true,
  paddingVertical: true,
  position: true,
  right: true,
  start: true,
  top: true,
  inset: true,
  insetBlock: true,
  insetBlockEnd: true,
  insetBlockStart: true,
  insetInline: true,
  insetInlineEnd: true,
  insetInlineStart: true,
  direction: true,
  shadowOffset: true,
  shadowRadius: true
}, tokenCategories.color), tokenCategories.radius), tokenCategories.size), tokenCategories.radius), stylePropsTransform), stylePropsUnitless), {
  boxShadow: true,
  filter: true
}), isAndroid ? {
  elevationAndroid: true
} : {}), stylePropsFont = {
  fontFamily: true,
  fontSize: true,
  fontStyle: true,
  fontWeight: true,
  fontVariant: true,
  letterSpacing: true,
  lineHeight: true,
  textTransform: true
}, stylePropsTextOnly = __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, stylePropsFont), {
  textAlign: true,
  textDecorationLine: true,
  textDecorationStyle: true
}), textColors), {
  textShadowOffset: true,
  textShadowRadius: true,
  userSelect: true,
  selectable: true,
  verticalAlign: true
}), stylePropsText = __spreadValues(__spreadValues({}, stylePropsView), stylePropsTextOnly), stylePropsAll = stylePropsText, validPseudoKeys = {
  enterStyle: true,
  exitStyle: true,
  hoverStyle: true,
  pressStyle: true,
  focusStyle: true,
  disabledStyle: true,
  focusWithinStyle: true
}, validStyles = stylePropsView;
function _type_of$9(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var Decorated = Symbol(), withStaticProperties = function(component, staticProps) {
  var next = (function() {
    if (component[Decorated]) {
      var _ = /* @__PURE__ */ React.forwardRef(function(props, ref) {
        return /* @__PURE__ */ React.createElement(component, __spreadProps(__spreadValues({}, props), {
          ref
        }));
      });
      for (var key in component) {
        var v = component[key];
        _[key] = v && (typeof v > "u" ? "undefined" : _type_of$9(v)) === "object" ? __spreadValues({}, v) : v;
      }
    }
    return component;
  })();
  return Object.assign(next, staticProps), next[Decorated] = true, next;
};
function _type_of$8(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var createVariable = function(props) {
  var skipHash = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  if (!skipHash && isVariable(props)) return props;
  var {
    key,
    name,
    val
  } = props;
  return {
    isVar: true,
    key,
    name: skipHash ? name : simpleHash(name, 40),
    val,
    variable: ""
  };
};
function variableToString(vrble) {
  return isVariable(vrble) ? `${vrble.val}` : `${vrble || ""}`;
}
function isVariable(v) {
  return v && (typeof v > "u" ? "undefined" : _type_of$8(v)) === "object" && "isVar" in v;
}
function getVariable(nameOrVariable) {
  var group = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "size", _tokens_group;
  if (nameOrVariable == null ? void 0 : nameOrVariable.dynamic) return nameOrVariable;
  if (setDidGetVariableValue(true), isVariable(nameOrVariable)) return variableToString(nameOrVariable);
  var tokens = getConfig().tokensParsed, _tokens_group_nameOrVariable;
  return variableToString((_tokens_group_nameOrVariable = (_tokens_group = tokens[group]) === null || _tokens_group === void 0 ? void 0 : _tokens_group[nameOrVariable]) !== null && _tokens_group_nameOrVariable !== void 0 ? _tokens_group_nameOrVariable : nameOrVariable);
}
var accessed = false, setDidGetVariableValue = function(val) {
  return accessed = val;
}, didGetVariableValue = function() {
  return accessed;
};
function getVariableValue(v, group) {
  if (isVariable(v)) return setDidGetVariableValue(true), v.val;
  if (group) {
    var _tokens_group, tokens = getConfig().tokensParsed, token = (_tokens_group = tokens[group]) === null || _tokens_group === void 0 ? void 0 : _tokens_group[v];
    if (token) return setDidGetVariableValue(true), token.val;
  }
  return v;
}
function getVariableName(v) {
  return isVariable(v) ? v.name : v;
}
function getOppositeScheme(scheme) {
  return scheme === "dark" ? "light" : "dark";
}
function getDynamicVal(param) {
  var {
    scheme,
    val,
    oppositeVal
  } = param, oppositeScheme = getOppositeScheme(scheme);
  return {
    dynamic: {
      [scheme]: val,
      [oppositeScheme]: oppositeVal
    }
  };
}
function extractValueFromDynamic(val, scheme) {
  return (val == null ? void 0 : val.dynamic) ? val.dynamic[scheme] : val;
}
var ThemeStateContext = React.createContext(""), allListeners = /* @__PURE__ */ new Map(), listenersByParent = {}, HasRenderedOnce = /* @__PURE__ */ new WeakMap(), HadTheme = /* @__PURE__ */ new WeakMap(), PendingUpdate = /* @__PURE__ */ new Map(), states = /* @__PURE__ */ new Map(), localStates = /* @__PURE__ */ new Map(), shouldForce = false, forceUpdateThemes = function() {
  shouldForce = true, allListeners.forEach(function(cb) {
    return cb();
  });
}, getThemeState = function(id2) {
  return states.get(id2);
}, themes = null, rootThemeState = null, getRootThemeState = function() {
  return rootThemeState;
}, useThemeState = function(props) {
  var isRoot = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, keys = arguments.length > 2 ? arguments[2] : void 0, {
    disable
  } = props, parentId = React.useContext(ThemeStateContext);
  if (!parentId && !isRoot) throw new Error(MISSING_THEME_MESSAGE);
  if (disable) return states.get(parentId) || {
    id: "",
    name: "light",
    theme: getConfig().themes.light,
    inverses: 0
  };
  var id2 = React.useId(), subscribe2 = React.useCallback(function(cb) {
    var _listenersByParent, _parentId;
    return (_listenersByParent = listenersByParent)[_parentId = parentId] || (_listenersByParent[_parentId] = /* @__PURE__ */ new Set()), listenersByParent[parentId].add(id2), allListeners.set(id2, function() {
      PendingUpdate.set(id2, shouldForce ? "force" : true), cb();
    }), function() {
      allListeners.delete(id2), listenersByParent[parentId].delete(id2), localStates.delete(id2), states.delete(id2), PendingUpdate.delete(id2);
    };
  }, [id2, parentId]), propsKey = getPropsKey(props), getSnapshot = function() {
    var _keys_current, _props_needsUpdate, local = localStates.get(id2), needsUpdate = props.passThrough ? false : isRoot || props.name === "light" || props.name === "dark" || props.name === null ? true : HasRenderedOnce.get(keys) ? !(keys == null || (_keys_current = keys.current) === null || _keys_current === void 0) && _keys_current.size ? true : (_props_needsUpdate = props.needsUpdate) === null || _props_needsUpdate === void 0 ? void 0 : _props_needsUpdate.call(props) : true, [rerender, next] = getNextState(local, props, propsKey, isRoot, id2, parentId, needsUpdate, PendingUpdate.get(id2));
    return PendingUpdate.delete(id2), (!local || rerender) && (local = __spreadValues({}, next), localStates.set(id2, local)), Object.assign(local, next), local.id = id2, states.set(id2, next), local;
  };
  var state = React.useSyncExternalStore(subscribe2, getSnapshot, getSnapshot);
  return useIsomorphicLayoutEffect(function() {
    if (!HasRenderedOnce.get(keys)) {
      HasRenderedOnce.set(keys, true);
      return;
    }
    if (!propsKey) {
      HadTheme.get(keys) && scheduleUpdate(id2), HadTheme.set(keys, false);
      return;
    }
    scheduleUpdate(id2), HadTheme.set(keys, true);
  }, [keys, propsKey]), state;
}, getNextState = function(lastState, props, propsKey) {
  var isRoot = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, id2 = arguments.length > 4 ? arguments[4] : void 0, parentId = arguments.length > 5 ? arguments[5] : void 0, needsUpdate = arguments.length > 6 ? arguments[6] : void 0, pendingUpdate = arguments.length > 7 ? arguments[7] : void 0, {
    debug
  } = props, parentState = states.get(parentId);
  if (props.passThrough) return [false, lastState || parentState || {
    name: ""
  }];
  themes || (themes = getConfig().themes);
  var name = !propsKey && (!lastState || !(lastState == null ? void 0 : lastState.isNew)) ? null : getNewThemeName(parentState == null ? void 0 : parentState.name, props, pendingUpdate === "force" ? true : !!needsUpdate), isSameAsParent = parentState && (!name || name === parentState.name), shouldRerender = !!(needsUpdate && (pendingUpdate || (lastState == null ? void 0 : lastState.name) !== (parentState == null ? void 0 : parentState.name)));
  if (isSameAsParent) return [shouldRerender, __spreadProps(__spreadValues({}, parentState), {
    isNew: false
  })];
  if (!name) {
    var next = lastState != null ? lastState : parentState;
    if (!next) throw new Error(MISSING_THEME_MESSAGE);
    if (shouldRerender) {
      var updated = __spreadValues({}, parentState || lastState);
      return [true, updated];
    }
    return [false, next];
  }
  var scheme = getScheme(name), _parentState_inverses, parentInverses = (_parentState_inverses = parentState == null ? void 0 : parentState.inverses) !== null && _parentState_inverses !== void 0 ? _parentState_inverses : 0, isInverse = parentState && scheme !== parentState.scheme, inverses = parentInverses + (isInverse ? 1 : 0), nextState = {
    id: id2,
    name,
    theme: themes[name],
    scheme,
    parentId,
    parentName: parentState == null ? void 0 : parentState.name,
    inverses,
    isInverse,
    isNew: true
  };
  if (isRoot && (rootThemeState = nextState), pendingUpdate !== "force" && lastState && lastState.name === name) return [false, nextState];
  var shouldAvoidRerender = pendingUpdate !== "force" && lastState && !needsUpdate && nextState.name === lastState.name;
  return shouldAvoidRerender ? [false, nextState] : [true, nextState];
};
function scheduleUpdate(id2) {
  for (var queue = [id2], visited = /* @__PURE__ */ new Set(); queue.length; ) {
    var parent = queue.shift(), children = listenersByParent[parent];
    if (children) {
      var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
      try {
        for (var _iterator = children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var childId = _step.value;
          visited.has(childId) || (visited.add(childId), queue.push(childId));
        }
      } catch (err) {
        _didIteratorError = true, _iteratorError = err;
      } finally {
        try {
          !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError) throw _iteratorError;
        }
      }
    }
  }
  visited.forEach(function(childId2) {
    var cb = allListeners.get(childId2);
    cb == null ? void 0 : cb();
  });
}
var validSchemes = {
  light: "light",
  dark: "dark"
};
function getScheme(name) {
  return validSchemes[name.split("_")[0]];
}
function getNewThemeName() {
  var parentName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", {
    name,
    reset,
    componentName,
    inverse,
    debug
  } = arguments.length > 1 ? arguments[1] : void 0, forceUpdate = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (name && reset) throw new Error("004");
  var {
    themes: themes2
  } = getConfig();
  if (reset) {
    var isSchemeOnly = parentName === "light" || parentName === "dark";
    if (isSchemeOnly) return parentName === "light" ? "dark" : "light";
    var lastPartIndex = parentName.lastIndexOf("_"), name1 = lastPartIndex <= 0 ? parentName : parentName.slice(lastPartIndex), scheme = parentName.slice(0, lastPartIndex), result = themes2[name1] ? name1 : scheme;
    return result;
  }
  var parentParts = parentName.split("_"), lastName = parentParts[parentParts.length - 1];
  lastName && lastName[0].toLowerCase() !== lastName[0] && parentParts.pop();
  var subNames = [name && componentName ? `${name}_${componentName}` : void 0, name, componentName].filter(Boolean), found = null;
  if (name) {
    var nameHasScheme = getScheme(name);
    if (nameHasScheme) {
      var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
      try {
        for (var _iterator = subNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var subName = _step.value;
          if (subName in themes2) {
            found = subName;
            break;
          }
        }
      } catch (err) {
        _didIteratorError = true, _iteratorError = err;
      } finally {
        try {
          !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError) throw _iteratorError;
        }
      }
    }
    if (!found && !nameHasScheme) {
      var parentScheme = getScheme(parentName);
      if (parentScheme) {
        var parentBase = parentParts.join("_"), withScheme = [componentName ? `${parentBase}_${name}_${componentName}` : void 0, `${parentBase}_${name}`, componentName ? `${parentScheme}_${name}_${componentName}` : void 0, `${parentScheme}_${name}`].filter(Boolean), _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = void 0;
        try {
          for (var _iterator1 = withScheme[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
            var potential = _step1.value;
            if (potential in themes2) {
              found = potential;
              break;
            }
          }
        } catch (err) {
          _didIteratorError1 = true, _iteratorError1 = err;
        } finally {
          try {
            !_iteratorNormalCompletion1 && _iterator1.return != null && _iterator1.return();
          } finally {
            if (_didIteratorError1) throw _iteratorError1;
          }
        }
      }
    }
  }
  if (!found) if (!name && componentName) {
    var potential1 = `${parentParts.join("_")}_${componentName}`;
    potential1 in themes2 && (found = potential1);
  } else for (var max2 = parentParts.length, i = 0; i <= max2; i++) {
    var base = (i === 0 ? parentParts : parentParts.slice(0, -i)).join("_"), _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = void 0;
    try {
      for (var _iterator2 = subNames[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var subName1 = _step2.value, potential2 = base ? `${base}_${subName1}` : subName1;
        if (potential2 in themes2) {
          found = potential2;
          break;
        }
      }
    } catch (err) {
      _didIteratorError2 = true, _iteratorError2 = err;
    } finally {
      try {
        !_iteratorNormalCompletion2 && _iterator2.return != null && _iterator2.return();
      } finally {
        if (_didIteratorError2) throw _iteratorError2;
      }
    }
    if (found) break;
  }
  if (inverse) {
    found || (found = parentName);
    var scheme1 = found.split("_")[0];
    found = found.replace(new RegExp(`^${scheme1}`), scheme1 === "light" ? "dark" : "light");
  }
  return !forceUpdate && found === parentName && // if its a scheme only sub-theme, we always consider it "new" because it likely inverses
  // and we want to avoid reparenting
  !validSchemes[found] ? null : found;
}
var getPropsKey = function(param) {
  var {
    name,
    reset,
    inverse,
    forceClassName,
    componentName
  } = param;
  return `${name || ""}${inverse || ""}${reset || ""}${forceClassName || ""}${componentName || ""}`;
}, hasThemeUpdatingProps = function(props) {
  return "inverse" in props || "name" in props || "reset" in props || "forceClassName" in props;
};
function doesRootSchemeMatchSystem() {
  var _getRootThemeState;
  return ((_getRootThemeState = getRootThemeState()) === null || _getRootThemeState === void 0 ? void 0 : _getRootThemeState.scheme) === Appearance.getColorScheme();
}
var cache$4 = /* @__PURE__ */ new Map(), curKeys, curProps, curState, emptyObject$2 = {};
function getThemeProxied(_props, _state, _keys) {
  if (!(_state == null ? void 0 : _state.theme)) return emptyObject$2;
  if (curKeys = _keys, curProps = _props, curState = _state, cache$4.has(curState.theme)) {
    var proxied = cache$4.get(curState.theme);
    return proxied;
  }
  var config = getConfig();
  function track(key) {
    curKeys && (curKeys.current || (curKeys.current = /* @__PURE__ */ new Set()), curKeys.current.add(key), false);
  }
  var proxied1 = Object.fromEntries(Object.entries(_state.theme).flatMap(function(param) {
    var [key, value] = param, proxied2 = __spreadProps(__spreadValues({}, value), {
      get val() {
        return globalThis.tamaguiAvoidTracking || track(key), value.val;
      },
      get(platform2) {
        if (curState) {
          var outVal = getVariable(value), {
            name,
            scheme,
            inverses
          } = curState, shouldOptimize = scheme && platform2 !== "web" && isIos && !curProps.deopt && getSetting("fastSchemeChange") && inverses === 0 && doesRootSchemeMatchSystem();
          if (shouldOptimize) {
            var _config_themes_name, _config_themes_oppositeName, oppositeScheme = scheme === "dark" ? "light" : "dark", oppositeName = name.replace(scheme, oppositeScheme), color = getVariable((_config_themes_name = config.themes[name]) === null || _config_themes_name === void 0 ? void 0 : _config_themes_name[key]), oppositeColor = getVariable((_config_themes_oppositeName = config.themes[oppositeName]) === null || _config_themes_oppositeName === void 0 ? void 0 : _config_themes_oppositeName[key]), dynamicVal = getDynamicVal({
              scheme,
              val: color,
              oppositeVal: oppositeColor
            });
            return dynamicVal;
          }
          return track(key), outVal;
        }
      }
    });
    return [[key, proxied2], [`$${key}`, proxied2]];
  }));
  return cache$4.set(_state.theme, proxied1), proxied1;
}
var useTheme = function() {
  var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, [theme] = useThemeWithState(props), res = theme;
  return res;
}, useThemeWithState = function(props) {
  var isRoot = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, keys = React.useRef(null), themeState = useThemeState(props, isRoot, keys);
  var themeProxied = props.passThrough ? {} : getThemeProxied(props, themeState, keys);
  return [themeProxied, themeState];
};
function setRef(ref, value) {
  typeof ref == "function" ? ref(value) : ref && (ref.current = value);
}
function composeRefs() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) refs[_key] = arguments[_key];
  return function(node) {
    return refs.forEach(function(ref) {
      return setRef(ref, node);
    });
  };
}
function useComposedRefs() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) refs[_key] = arguments[_key];
  return React__namespace.useCallback(composeRefs(...refs), refs);
}
var defaultComponentState = {
  hover: false,
  press: false,
  pressIn: false,
  focus: false,
  focusVisible: false,
  focusWithin: false,
  unmounted: true,
  disabled: false
}, defaultComponentStateMounted = __spreadProps(__spreadValues({}, defaultComponentState), {
  unmounted: false
}), defaultComponentStateShouldEnter = __spreadProps(__spreadValues({}, defaultComponentState), {
  unmounted: "should-enter"
});
var matchMediaImpl = matchMediaFallback, matchMedia$1 = function() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
  return matchMediaImpl(...args);
};
function matchMediaFallback(query2) {
  return !process.env.IS_STATIC && false, {
    match: function(a, b2) {
      return false;
    },
    addListener: function() {
    },
    removeListener: function() {
    },
    matches: false
  };
}
function setupMatchMedia(_) {
  matchMediaImpl = _, globalThis.matchMedia = _;
}
exports.mediaState = // development only safeguard
{};
var mediaQueryConfig = {}, getMedia = function() {
  return exports.mediaState;
}, mediaKeys = /* @__PURE__ */ new Set(), mediaKeyRegex = /\$(platform|theme|group)-/, getMediaKey = function(key) {
  if (key[0] !== "$") return false;
  if (mediaKeys.has(key)) return true;
  var match = key.match(mediaKeyRegex);
  return match ? match[1] : false;
}, initState, mediaKeysOrdered, getMediaKeyImportance = function(key) {
  var conf2 = getConfig();
  return conf2.settings.mediaPropOrder ? defaultMediaImportance : mediaKeysOrdered.indexOf(key) + 100;
}, dispose = /* @__PURE__ */ new Set(), mediaVersion = 0, configureMedia = function(config) {
  var {
    media
  } = config, mediaQueryDefaultActive = getSetting("mediaQueryDefaultActive");
  if (media) {
    mediaVersion++;
    for (var key in media) exports.mediaState[key] = (mediaQueryDefaultActive == null ? void 0 : mediaQueryDefaultActive[key]) || false, mediaKeys.add(`$${key}`);
    Object.assign(mediaQueryConfig, media), initState = __spreadValues({}, exports.mediaState), mediaKeysOrdered = Object.keys(media), setupMediaListeners();
  }
};
function unlisten() {
  dispose.forEach(function(cb) {
    return cb();
  }), dispose.clear();
}
var setupVersion = -1;
function setupMediaListeners() {
  var _loop2 = function(key2) {
    var str = mediaObjectToString(mediaQueryConfig[key2]), getMatch = function() {
      return matchMedia$1(str);
    }, match = getMatch();
    if (!match) throw new Error(" No match");
    match.addListener(update2), dispose.add(function() {
      match.removeListener(update2);
    });
    function update2() {
      var next = !!getMatch().matches;
      next !== exports.mediaState[key2] && (exports.mediaState = __spreadProps(__spreadValues({}, exports.mediaState), {
        [key2]: next
      }), updateMediaListeners());
    }
    update2();
  };
  if (!process.env.IS_STATIC && setupVersion !== mediaVersion) {
    setupVersion = mediaVersion, unlisten();
    for (var key in mediaQueryConfig) _loop2(key);
  }
}
var listeners$1 = /* @__PURE__ */ new Set();
function updateMediaListeners() {
  listeners$1.forEach(function(cb) {
    return cb(exports.mediaState);
  });
}
var States = /* @__PURE__ */ new WeakMap();
function setMediaShouldUpdate(ref, enabled, keys) {
  var cur = States.get(ref);
  (!cur || cur.enabled !== enabled || keys) && States.set(ref, __spreadProps(__spreadValues({}, cur), {
    enabled,
    keys
  }));
}
function subscribe$1(subscriber) {
  return listeners$1.add(subscriber), function() {
    listeners$1.delete(subscriber);
  };
}
function useMedia(componentContext, debug) {
  var componentState = componentContext ? States.get(componentContext) : null, internalRef = React.useRef(null);
  internalRef.current || (internalRef.current = {
    keys: /* @__PURE__ */ new Set(),
    lastState: exports.mediaState
  }), internalRef.current.pendingState && (internalRef.current.lastState = internalRef.current.pendingState, internalRef.current.pendingState = void 0);
  var {
    keys
  } = internalRef.current;
  keys.size && keys.clear();
  var state = React.useSyncExternalStore(subscribe$1, function() {
    var curKeys2 = (componentState == null ? void 0 : componentState.keys) || keys, {
      lastState,
      pendingState
    } = internalRef.current;
    if (!curKeys2.size) return lastState;
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
    try {
      for (var _iterator = curKeys2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var key = _step.value;
        if (exports.mediaState[key] !== (pendingState || lastState)[key]) return false, (componentContext == null ? void 0 : componentContext.mediaEmit) ? (componentContext.mediaEmit(exports.mediaState), internalRef.current.pendingState = exports.mediaState, lastState) : (internalRef.current.lastState = exports.mediaState, exports.mediaState);
      }
    } catch (err) {
      _didIteratorError = true, _iteratorError = err;
    } finally {
      try {
        !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
      } finally {
        if (_didIteratorError) throw _iteratorError;
      }
    }
    return lastState;
  }, getServerSnapshot);
  return new Proxy(state, {
    get(_, key) {
      return !disableMediaTouch && typeof key == "string" && keys.add(key), Reflect.get(state, key);
    }
  });
}
var getServerSnapshot = function() {
  return initState;
}, disableMediaTouch = false;
function getMediaState(mediaGroups, layout) {
  disableMediaTouch = true;
  var res;
  try {
    res = Object.fromEntries([...mediaGroups].map(function(mediaKey) {
      return [mediaKey, mediaKeyMatch(mediaKey, layout)];
    }));
  } finally {
    disableMediaTouch = false;
  }
  return res;
}
var getMediaImportanceIfMoreImportant = function(mediaKey, key, styleState, isSizeMedia) {
  var importance = isSizeMedia && !getSetting("mediaPropOrder") ? getMediaKeyImportance(mediaKey) : defaultMediaImportance, usedKeys = styleState.usedKeys;
  return !usedKeys[key] || importance > usedKeys[key] ? importance : null;
};
function camelToHyphen(str) {
  return str.replace(/[A-Z]/g, function(m) {
    return `-${m.toLowerCase()}`;
  }).toLowerCase();
}
var cache$3 = /* @__PURE__ */ new WeakMap();
function mediaObjectToString(query2, key) {
  if (typeof query2 == "string") return query2;
  if (cache$3.has(query2)) return cache$3.get(query2);
  var res = Object.entries(query2).map(function(param) {
    var [feature, value] = param;
    return feature = camelToHyphen(feature), typeof value == "string" ? `(${feature}: ${value})` : (typeof value == "number" && /[height|width]$/.test(feature) && (value = `${value}px`), `(${feature}: ${value})`);
  }).join(" and ");
  return cache$3.set(query2, res), res;
}
function mediaKeyMatch(key, dimensions2) {
  var mediaQueries = mediaQueryConfig[key], result = Object.keys(mediaQueries).every(function(query2) {
    var expectedVal = +mediaQueries[query2], isMax = query2.startsWith("max"), isWidth = query2.endsWith("Width"), givenVal = dimensions2[isWidth ? "width" : "height"];
    return isMax ? givenVal < expectedVal : givenVal > expectedVal;
  });
  return result;
}
function getGroupPropParts(groupProp) {
  var mediaQueries = getMedia(), [_, name, part3, part4] = groupProp.split("-"), pseudo, media = part3 in mediaQueries ? part3 : void 0;
  return media ? pseudo = part4 : pseudo = part3, {
    name,
    pseudo,
    media
  };
}
var defaultOffset$1 = {
  height: 0,
  width: 0
};
var normalizeColor_1;
var hasRequiredNormalizeColor;
function requireNormalizeColor() {
  if (hasRequiredNormalizeColor) return normalizeColor_1;
  hasRequiredNormalizeColor = 1;
  function normalizeColor2(color) {
    if (typeof color === "number") {
      if (color >>> 0 === color && color >= 0 && color <= 4294967295) {
        return color;
      }
      return null;
    }
    if (typeof color !== "string") {
      return null;
    }
    const matchers = getMatchers();
    let match;
    if (match = matchers.hex6.exec(color)) {
      return parseInt(match[1] + "ff", 16) >>> 0;
    }
    const colorFromKeyword = normalizeKeyword(color);
    if (colorFromKeyword != null) {
      return colorFromKeyword;
    }
    if (match = matchers.rgb.exec(color)) {
      return (parse255(match[1]) << 24 | // r
      parse255(match[2]) << 16 | // g
      parse255(match[3]) << 8 | // b
      255) >>> // a
      0;
    }
    if (match = matchers.rgba.exec(color)) {
      if (match[6] !== void 0) {
        return (parse255(match[6]) << 24 | // r
        parse255(match[7]) << 16 | // g
        parse255(match[8]) << 8 | // b
        parse1(match[9])) >>> // a
        0;
      }
      return (parse255(match[2]) << 24 | // r
      parse255(match[3]) << 16 | // g
      parse255(match[4]) << 8 | // b
      parse1(match[5])) >>> // a
      0;
    }
    if (match = matchers.hex3.exec(color)) {
      return parseInt(
        match[1] + match[1] + // r
        match[2] + match[2] + // g
        match[3] + match[3] + // b
        "ff",
        // a
        16
      ) >>> 0;
    }
    if (match = matchers.hex8.exec(color)) {
      return parseInt(match[1], 16) >>> 0;
    }
    if (match = matchers.hex4.exec(color)) {
      return parseInt(
        match[1] + match[1] + // r
        match[2] + match[2] + // g
        match[3] + match[3] + // b
        match[4] + match[4],
        // a
        16
      ) >>> 0;
    }
    if (match = matchers.hsl.exec(color)) {
      return (hslToRgb(
        parse360(match[1]),
        // h
        parsePercentage(match[2]),
        // s
        parsePercentage(match[3])
        // l
      ) | 255) >>> // a
      0;
    }
    if (match = matchers.hsla.exec(color)) {
      if (match[6] !== void 0) {
        return (hslToRgb(
          parse360(match[6]),
          // h
          parsePercentage(match[7]),
          // s
          parsePercentage(match[8])
          // l
        ) | parse1(match[9])) >>> // a
        0;
      }
      return (hslToRgb(
        parse360(match[2]),
        // h
        parsePercentage(match[3]),
        // s
        parsePercentage(match[4])
        // l
      ) | parse1(match[5])) >>> // a
      0;
    }
    if (match = matchers.hwb.exec(color)) {
      return (hwbToRgb(
        parse360(match[1]),
        // h
        parsePercentage(match[2]),
        // w
        parsePercentage(match[3])
        // b
      ) | 255) >>> // a
      0;
    }
    return null;
  }
  function hue2rgb(p, q, t2) {
    if (t2 < 0) {
      t2 += 1;
    }
    if (t2 > 1) {
      t2 -= 1;
    }
    if (t2 < 1 / 6) {
      return p + (q - p) * 6 * t2;
    }
    if (t2 < 1 / 2) {
      return q;
    }
    if (t2 < 2 / 3) {
      return p + (q - p) * (2 / 3 - t2) * 6;
    }
    return p;
  }
  function hslToRgb(h2, s2, l) {
    const q = l < 0.5 ? l * (1 + s2) : l + s2 - l * s2;
    const p = 2 * l - q;
    const r = hue2rgb(p, q, h2 + 1 / 3);
    const g = hue2rgb(p, q, h2);
    const b2 = hue2rgb(p, q, h2 - 1 / 3);
    return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b2 * 255) << 8;
  }
  function hwbToRgb(h2, w2, b2) {
    if (w2 + b2 >= 1) {
      const gray = Math.round(w2 * 255 / (w2 + b2));
      return gray << 24 | gray << 16 | gray << 8;
    }
    const red = hue2rgb(0, 1, h2 + 1 / 3) * (1 - w2 - b2) + w2;
    const green = hue2rgb(0, 1, h2) * (1 - w2 - b2) + w2;
    const blue = hue2rgb(0, 1, h2 - 1 / 3) * (1 - w2 - b2) + w2;
    return Math.round(red * 255) << 24 | Math.round(green * 255) << 16 | Math.round(blue * 255) << 8;
  }
  const NUMBER = "[-+]?\\d*\\.?\\d+";
  const PERCENTAGE = NUMBER + "%";
  function call(...args) {
    return "\\(\\s*(" + args.join(")\\s*,?\\s*(") + ")\\s*\\)";
  }
  function callWithSlashSeparator(...args) {
    return "\\(\\s*(" + args.slice(0, args.length - 1).join(")\\s*,?\\s*(") + ")\\s*/\\s*(" + args[args.length - 1] + ")\\s*\\)";
  }
  function commaSeparatedCall(...args) {
    return "\\(\\s*(" + args.join(")\\s*,\\s*(") + ")\\s*\\)";
  }
  let cachedMatchers;
  function getMatchers() {
    if (cachedMatchers === void 0) {
      cachedMatchers = {
        rgb: new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER)),
        rgba: new RegExp(
          "rgba(" + commaSeparatedCall(NUMBER, NUMBER, NUMBER, NUMBER) + "|" + callWithSlashSeparator(NUMBER, NUMBER, NUMBER, NUMBER) + ")"
        ),
        hsl: new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE)),
        hsla: new RegExp(
          "hsla(" + commaSeparatedCall(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER) + "|" + callWithSlashSeparator(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER) + ")"
        ),
        hwb: new RegExp("hwb" + call(NUMBER, PERCENTAGE, PERCENTAGE)),
        hex3: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex4: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#([0-9a-fA-F]{6})$/,
        hex8: /^#([0-9a-fA-F]{8})$/
      };
    }
    return cachedMatchers;
  }
  function parse255(str) {
    const int = parseInt(str, 10);
    if (int < 0) {
      return 0;
    }
    if (int > 255) {
      return 255;
    }
    return int;
  }
  function parse360(str) {
    const int = parseFloat(str);
    return (int % 360 + 360) % 360 / 360;
  }
  function parse1(str) {
    const num = parseFloat(str);
    if (num < 0) {
      return 0;
    }
    if (num > 1) {
      return 255;
    }
    return Math.round(num * 255);
  }
  function parsePercentage(str) {
    const int = parseFloat(str);
    if (int < 0) {
      return 0;
    }
    if (int > 100) {
      return 1;
    }
    return int / 100;
  }
  function normalizeKeyword(name) {
    switch (name) {
      case "transparent":
        return 0;
      // http://www.w3.org/TR/css3-color/#svg-color
      case "aliceblue":
        return 4042850303;
      case "antiquewhite":
        return 4209760255;
      case "aqua":
        return 16777215;
      case "aquamarine":
        return 2147472639;
      case "azure":
        return 4043309055;
      case "beige":
        return 4126530815;
      case "bisque":
        return 4293182719;
      case "black":
        return 255;
      case "blanchedalmond":
        return 4293643775;
      case "blue":
        return 65535;
      case "blueviolet":
        return 2318131967;
      case "brown":
        return 2771004159;
      case "burlywood":
        return 3736635391;
      case "burntsienna":
        return 3934150143;
      case "cadetblue":
        return 1604231423;
      case "chartreuse":
        return 2147418367;
      case "chocolate":
        return 3530104575;
      case "coral":
        return 4286533887;
      case "cornflowerblue":
        return 1687547391;
      case "cornsilk":
        return 4294499583;
      case "crimson":
        return 3692313855;
      case "cyan":
        return 16777215;
      case "darkblue":
        return 35839;
      case "darkcyan":
        return 9145343;
      case "darkgoldenrod":
        return 3095792639;
      case "darkgray":
        return 2846468607;
      case "darkgreen":
        return 6553855;
      case "darkgrey":
        return 2846468607;
      case "darkkhaki":
        return 3182914559;
      case "darkmagenta":
        return 2332068863;
      case "darkolivegreen":
        return 1433087999;
      case "darkorange":
        return 4287365375;
      case "darkorchid":
        return 2570243327;
      case "darkred":
        return 2332033279;
      case "darksalmon":
        return 3918953215;
      case "darkseagreen":
        return 2411499519;
      case "darkslateblue":
        return 1211993087;
      case "darkslategray":
        return 793726975;
      case "darkslategrey":
        return 793726975;
      case "darkturquoise":
        return 13554175;
      case "darkviolet":
        return 2483082239;
      case "deeppink":
        return 4279538687;
      case "deepskyblue":
        return 12582911;
      case "dimgray":
        return 1768516095;
      case "dimgrey":
        return 1768516095;
      case "dodgerblue":
        return 512819199;
      case "firebrick":
        return 2988581631;
      case "floralwhite":
        return 4294635775;
      case "forestgreen":
        return 579543807;
      case "fuchsia":
        return 4278255615;
      case "gainsboro":
        return 3705462015;
      case "ghostwhite":
        return 4177068031;
      case "gold":
        return 4292280575;
      case "goldenrod":
        return 3668254975;
      case "gray":
        return 2155905279;
      case "green":
        return 8388863;
      case "greenyellow":
        return 2919182335;
      case "grey":
        return 2155905279;
      case "honeydew":
        return 4043305215;
      case "hotpink":
        return 4285117695;
      case "indianred":
        return 3445382399;
      case "indigo":
        return 1258324735;
      case "ivory":
        return 4294963455;
      case "khaki":
        return 4041641215;
      case "lavender":
        return 3873897215;
      case "lavenderblush":
        return 4293981695;
      case "lawngreen":
        return 2096890111;
      case "lemonchiffon":
        return 4294626815;
      case "lightblue":
        return 2916673279;
      case "lightcoral":
        return 4034953471;
      case "lightcyan":
        return 3774873599;
      case "lightgoldenrodyellow":
        return 4210742015;
      case "lightgray":
        return 3553874943;
      case "lightgreen":
        return 2431553791;
      case "lightgrey":
        return 3553874943;
      case "lightpink":
        return 4290167295;
      case "lightsalmon":
        return 4288707327;
      case "lightseagreen":
        return 548580095;
      case "lightskyblue":
        return 2278488831;
      case "lightslategray":
        return 2005441023;
      case "lightslategrey":
        return 2005441023;
      case "lightsteelblue":
        return 2965692159;
      case "lightyellow":
        return 4294959359;
      case "lime":
        return 16711935;
      case "limegreen":
        return 852308735;
      case "linen":
        return 4210091775;
      case "magenta":
        return 4278255615;
      case "maroon":
        return 2147483903;
      case "mediumaquamarine":
        return 1724754687;
      case "mediumblue":
        return 52735;
      case "mediumorchid":
        return 3126187007;
      case "mediumpurple":
        return 2473647103;
      case "mediumseagreen":
        return 1018393087;
      case "mediumslateblue":
        return 2070474495;
      case "mediumspringgreen":
        return 16423679;
      case "mediumturquoise":
        return 1221709055;
      case "mediumvioletred":
        return 3340076543;
      case "midnightblue":
        return 421097727;
      case "mintcream":
        return 4127193855;
      case "mistyrose":
        return 4293190143;
      case "moccasin":
        return 4293178879;
      case "navajowhite":
        return 4292783615;
      case "navy":
        return 33023;
      case "oldlace":
        return 4260751103;
      case "olive":
        return 2155872511;
      case "olivedrab":
        return 1804477439;
      case "orange":
        return 4289003775;
      case "orangered":
        return 4282712319;
      case "orchid":
        return 3664828159;
      case "palegoldenrod":
        return 4008225535;
      case "palegreen":
        return 2566625535;
      case "paleturquoise":
        return 2951671551;
      case "palevioletred":
        return 3681588223;
      case "papayawhip":
        return 4293907967;
      case "peachpuff":
        return 4292524543;
      case "peru":
        return 3448061951;
      case "pink":
        return 4290825215;
      case "plum":
        return 3718307327;
      case "powderblue":
        return 2967529215;
      case "purple":
        return 2147516671;
      case "rebeccapurple":
        return 1714657791;
      case "red":
        return 4278190335;
      case "rosybrown":
        return 3163525119;
      case "royalblue":
        return 1097458175;
      case "saddlebrown":
        return 2336560127;
      case "salmon":
        return 4202722047;
      case "sandybrown":
        return 4104413439;
      case "seagreen":
        return 780883967;
      case "seashell":
        return 4294307583;
      case "sienna":
        return 2689740287;
      case "silver":
        return 3233857791;
      case "skyblue":
        return 2278484991;
      case "slateblue":
        return 1784335871;
      case "slategray":
        return 1887473919;
      case "slategrey":
        return 1887473919;
      case "snow":
        return 4294638335;
      case "springgreen":
        return 16744447;
      case "steelblue":
        return 1182971135;
      case "tan":
        return 3535047935;
      case "teal":
        return 8421631;
      case "thistle":
        return 3636451583;
      case "tomato":
        return 4284696575;
      case "turquoise":
        return 1088475391;
      case "violet":
        return 4001558271;
      case "wheat":
        return 4125012991;
      case "white":
        return 4294967295;
      case "whitesmoke":
        return 4126537215;
      case "yellow":
        return 4294902015;
      case "yellowgreen":
        return 2597139199;
    }
    return null;
  }
  normalizeColor_1 = normalizeColor2;
  return normalizeColor_1;
}
var normalizeColorExports = requireNormalizeColor();
const index = /* @__PURE__ */ getDefaultExportFromCjs(normalizeColorExports);
const normalizeColor$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index
}, [normalizeColorExports]);
var norm = index || normalizeColor$2, normalizeCSSColor = norm;
function rgba(colorInt) {
  var r = Math.round((colorInt & 4278190080) >>> 24), g = Math.round((colorInt & 16711680) >>> 16), b2 = Math.round((colorInt & 65280) >>> 8), a = ((colorInt & 255) >>> 0) / 255;
  return {
    r,
    g,
    b: b2,
    a
  };
}
var index_default = normalizeCSSColor;
var normalizeColor$1 = function(color, opacity) {
  if (color) {
    if (color[0] === "$") return color;
    if (color.startsWith("var(")) ;
    else {
      var rgba3 = getRgba(color);
      if (rgba3) {
        var colors = `${rgba3.r},${rgba3.g},${rgba3.b}`, _ref;
        return opacity === 1 ? `rgb(${colors})` : `rgba(${colors},${(_ref = opacity) !== null && _ref !== void 0 ? _ref : 1})`;
      }
    }
    return color;
  }
}, getRgba = function(color) {
  var colorNum = normalizeCSSColor(color);
  if (colorNum != null) return rgba(colorNum);
};
function normalizeShadow(param) {
  var {
    shadowColor,
    shadowOffset,
    shadowOpacity,
    shadowRadius
  } = param, _getRgba, {
    height,
    width
  } = shadowOffset || defaultOffset$1;
  return {
    shadowOffset: {
      width: width || 0,
      height: height || 0
    },
    shadowRadius: shadowRadius || 0,
    shadowColor: normalizeColor$1(shadowColor, 1),
    shadowOpacity: shadowOpacity != null ? shadowOpacity : shadowColor ? (_getRgba = getRgba(shadowColor)) === null || _getRgba === void 0 ? void 0 : _getRgba.a : 1
  };
}
function fixStyles(style) {
  "elevationAndroid" in style && (style.elevation = style.elevationAndroid, delete style.elevationAndroid), (style.shadowRadius != null || style.shadowColor || style.shadowOpacity != null || style.shadowOffset) && Object.assign(style, normalizeShadow(style));
  for (var key in borderDefaults) if (key in style) {
    var _style, _borderDefaults_key;
    (_style = style)[_borderDefaults_key = borderDefaults[key]] || (_style[_borderDefaults_key] = "solid");
  }
}
var nativeStyle = "borderStyle", borderDefaults = {
  borderWidth: "borderStyle",
  borderBottomWidth: nativeStyle,
  borderTopWidth: nativeStyle,
  borderLeftWidth: nativeStyle,
  borderRightWidth: nativeStyle
};
var empty = function() {
  console.warn("no-op native");
}, getCSSStylesAtomic = empty;
function scanAllSheets() {
}
process.env.TAMAGUI_BAIL_AFTER_SCANNING_X_CSS_RULES;
process.env.TAMAGUI_INSERT_SELECTOR_TRIES ? +process.env.TAMAGUI_INSERT_SELECTOR_TRIES : 1;
function isActivePlatform(key) {
  if (!key.startsWith("$platform")) return true;
  var platform2 = key.slice(10);
  return (
    // web, ios, android
    platform2 === currentPlatform || // web, native
    platform2 === "native"
  );
}
function isActiveTheme(key, activeThemeName) {
  if (key.startsWith("$theme-")) return key.slice(7).startsWith(activeThemeName);
}
__spreadValues({}, stylePropsAll);
function normalizeValueWithProperty$1(value) {
  return value;
}
var _loop$1 = function(parent) {
  var _exec, _exec_index, prefix = parent.slice(0, (_exec_index = (_exec = /[A-Z]/.exec(parent)) === null || _exec === void 0 ? void 0 : _exec.index) !== null && _exec_index !== void 0 ? _exec_index : parent.length);
  expansionsNoPrefix[parent] = expansionsNoPrefix[parent].map(function(k) {
    return `${prefix}${k}`;
  });
}, resizeModeMap = {
  fill: "stretch",
  none: "center",
  "scale-down": "contain",
  contain: "contain",
  cover: "cover"
}, verticalAlignMap = {
  top: "top",
  middle: "center",
  bottom: "bottom",
  auto: "auto"
}, webToNativeDynamicExpansion = {
  objectFit: function(val) {
    var resizeMode = resizeModeMap[val] || "cover";
    return [["resizeMode", resizeMode]];
  },
  verticalAlign: function(val) {
    return [["textAlignVertical", verticalAlignMap[val] || "auto"]];
  }
}, vert$1 = ["Top", "Bottom"], es = ["End", "Start"], t = ["Top"], b = ["Bottom"], s = ["Start"], e = ["End"], h = ["Height"], w = ["Width"], expansionsNoPrefix = {
  borderBlockColor: ["TopColor", "BottomColor"],
  borderInlineColor: ["EndColor", "StartColor"],
  borderBlockWidth: ["TopWidth", "BottomWidth"],
  borderInlineWidth: ["EndWidth", "StartWidth"],
  borderBlockStyle: ["TopStyle", "BottomStyle"],
  borderInlineStyle: ["EndStyle", "StartStyle"],
  marginBlock: vert$1,
  marginInline: es,
  paddingBlock: vert$1,
  paddingInline: es,
  borderBlockStartColor: ["TopColor"],
  borderBlockEndColor: ["BottomColor"],
  borderInlineStartColor: ["StartColor"],
  borderInlineEndColor: ["EndColor"],
  borderBlockStartWidth: ["TopWidth"],
  borderBlockEndWidth: ["BottomWidth"],
  borderInlineStartWidth: ["StartWidth"],
  borderInlineEndWidth: ["EndWidth"],
  borderBlockStartStyle: ["TopStyle"],
  borderBlockEndStyle: ["BottomStyle"],
  borderInlineStartStyle: ["StartStyle"],
  borderInlineEndStyle: ["EndStyle"],
  marginBlockStart: t,
  marginBlockEnd: b,
  marginInlineStart: s,
  marginInlineEnd: e,
  paddingBlockStart: t,
  paddingBlockEnd: b,
  paddingInlineStart: s,
  paddingInlineEnd: e,
  minBlockSize: h,
  maxBlockSize: h,
  minInlineSize: w,
  maxInlineSize: w
};
for (var parent$1 in expansionsNoPrefix) _loop$1(parent$1);
var expansions = {
  inset: ["top", "right", "bottom", "left"],
  insetBlock: ["top", "bottom"],
  insetBlockStart: ["top"],
  insetBlockEnd: ["bottom"],
  insetInlineStart: ["left"],
  insetInlineEnd: ["right"],
  blockSize: ["height"],
  inlineSize: ["width"]
}, webToNativeExpansion = Object.assign(expansionsNoPrefix, expansions);
var _loop = function(parent) {
  var _exec, _exec_index, prefix = parent.slice(0, (_exec_index = (_exec = /[A-Z]/.exec(parent)) === null || _exec === void 0 ? void 0 : _exec.index) !== null && _exec_index !== void 0 ? _exec_index : parent.length);
  EXPANSIONS[parent] = EXPANSIONS[parent].map(function(k) {
    return `${prefix}${k}`;
  });
};
function expandStyle(key, value) {
  if (isAndroid && key === "elevationAndroid") return [["elevation", value]];
  if (key in EXPANSIONS) return EXPANSIONS[key].map(function(key2) {
    return [key2, value];
  });
  if (key in webToNativeExpansion) return webToNativeExpansion[key].map(function(key2) {
    return [key2, value];
  });
  if (key in webToNativeDynamicExpansion) return webToNativeDynamicExpansion[key](value);
}
var all = ["Top", "Right", "Bottom", "Left"], horiz = ["Right", "Left"], vert = ["Top", "Bottom"], xy = ["X", "Y"], EXPANSIONS = __spreadValues({
  borderColor: ["TopColor", "RightColor", "BottomColor", "LeftColor"],
  borderRadius: ["TopLeftRadius", "TopRightRadius", "BottomRightRadius", "BottomLeftRadius"],
  borderWidth: ["TopWidth", "RightWidth", "BottomWidth", "LeftWidth"],
  margin: all,
  marginHorizontal: horiz,
  marginVertical: vert,
  overscrollBehavior: xy,
  padding: all,
  paddingHorizontal: horiz,
  paddingVertical: vert
}, isWeb);
for (var parent in EXPANSIONS) _loop(parent);
var cache$2 = /* @__PURE__ */ new WeakMap(), getVariantExtras = function(styleState) {
  if (cache$2.has(styleState)) return cache$2.get(styleState);
  var {
    props,
    conf: conf2,
    context: context2,
    theme
  } = styleState, fonts = conf2.fontsParsed;
  (context2 == null ? void 0 : context2.language) && (fonts = getFontsForLanguage(conf2.fontsParsed, context2.language));
  var next = {
    fonts,
    tokens: conf2.tokensParsed,
    theme,
    get fontFamily() {
      return getVariableValue(styleState.fontFamily || styleState.props.fontFamily) || props.fontFamily || getVariableValue(styleState.conf.defaultFont);
    },
    get font() {
      return fonts[this.fontFamily] || (!props.fontFamily || props.fontFamily[0] === "$" ? fonts[styleState.conf.defaultFont] : void 0);
    },
    props
  };
  return cache$2.set(styleState, next), next;
}, fontLanguageCache = /* @__PURE__ */ new WeakMap();
function getFontsForLanguage(fonts, language) {
  if (fontLanguageCache.has(language)) return fontLanguageCache.get(language);
  var next = __spreadValues(__spreadValues({}, fonts), Object.fromEntries(Object.entries(language).map(function(param) {
    var [name, lang] = param;
    if (lang === "default") return [];
    var langKey = `$${name}_${lang}`;
    return [`$${name}`, fonts[langKey]];
  })));
  return fontLanguageCache.set(language, next), next;
}
function _type_of$7(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var isObj = function(x) {
  return x && !Array.isArray(x) && (typeof x > "u" ? "undefined" : _type_of$7(x)) === "object";
};
function normalizeStyle$1(style) {
  var disableNormalize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, res = {};
  for (var key in style) {
    var prop = style[key];
    if (prop != null) {
      if (key in pseudoDescriptors || // this should capture all parent-based styles like media, group, etc
      key[0] === "$" && isObj(prop)) {
        res[key] = normalizeStyle$1(prop, disableNormalize);
        continue;
      }
      var value = disableNormalize ? prop : normalizeValueWithProperty$1(prop), out = expandStyle(key, value);
      out ? Object.assign(res, Object.fromEntries(out)) : res[key] = value;
    }
  }
  return fixStyles(res), res;
}
var webPropsToSkip = {
  whiteSpace: 1,
  wordWrap: 1,
  textOverflow: 1,
  textDecorationDistance: 1,
  cursor: 1,
  contain: 1,
  boxSizing: 1,
  touchAction: 1,
  outlineStyle: 1,
  outlineOffset: 1,
  outlineWidth: 1,
  outlineColor: 1,
  backdropFilter: 1,
  backgroundImage: 1,
  mixBlendMode: 1,
  scrollbarWidth: 1,
  backgroundOrigin: 1,
  backgroundPosition: 1,
  backgroundRepeat: 1,
  backgroundSize: 1,
  backgroundClip: 1,
  backgroundBlendMode: 1,
  backgroundAttachment: 1,
  background: 1,
  clipPath: 1,
  caretColor: 1,
  transformStyle: 1,
  mask: 1,
  maskImage: 1,
  textEmphasis: 1,
  borderImage: 1,
  float: 1,
  content: 1,
  overflowBlock: 1,
  overflowInline: 1,
  maskBorder: 1,
  maskBorderMode: 1,
  maskBorderOutset: 1,
  maskBorderRepeat: 1,
  maskBorderSlice: 1,
  maskBorderSource: 1,
  maskBorderWidth: 1,
  maskClip: 1,
  maskComposite: 1,
  maskMode: 1,
  maskOrigin: 1,
  maskPosition: 1,
  maskRepeat: 1,
  maskSize: 1,
  maskType: 1
};
var skipProps = {
  untilMeasured: 1,
  animation: 1,
  space: 1,
  animateOnly: 1,
  disableClassName: 1,
  debug: 1,
  componentName: 1,
  disableOptimization: 1,
  tag: 1,
  style: 1,
  // handled after loop so pseudos set usedKeys and override it if necessary
  group: 1,
  themeInverse: 1,
  animatePresence: 1
};
Object.assign(skipProps, webPropsToSkip);
function _type_of$6(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var propMapper = function(key, value, styleState, disabled, map) {
  if (disabled) return map(key, value);
  if (lastFontFamilyToken = null, !(!isAndroid && key === "elevationAndroid")) {
    var {
      conf: conf2,
      styleProps: styleProps2,
      staticConfig
    } = styleState;
    if (value === "unset") {
      var _conf_unset, unsetVal = (_conf_unset = conf2.unset) === null || _conf_unset === void 0 ? void 0 : _conf_unset[key];
      if (unsetVal != null) value = unsetVal;
      else return;
    }
    var {
      variants: variants2
    } = staticConfig;
    if (!styleProps2.noExpand && variants2 && key in variants2) {
      var variantValue = resolveVariants(key, value, styleProps2, styleState, "");
      if (variantValue) {
        variantValue.forEach(function(param) {
          var [_$key, _$value] = param;
          return map(_$key, _$value);
        });
        return;
      }
    }
    if (styleProps2.disableExpandShorthands || key in conf2.shorthands && (key = conf2.shorthands[key]), value != null && (value[0] === "$" ? value = getTokenForKey(key, value, styleProps2, styleState) : isVariable(value) && (value = resolveVariableValue(key, value, styleProps2.resolveValues))), value != null) {
      key === "fontFamily" && lastFontFamilyToken && (styleState.fontFamily = lastFontFamilyToken);
      var expanded = styleProps2.noExpand ? null : expandStyle(key, value);
      if (expanded) for (var max2 = expanded.length, i = 0; i < max2; i++) {
        var [nkey, nvalue] = expanded[i];
        map(nkey, nvalue);
      }
      else map(key, value);
    }
  }
}, resolveVariants = function(key, value, styleProps2, styleState, parentVariantKey) {
  var {
    staticConfig,
    conf: conf2,
    debug
  } = styleState, {
    variants: variants2
  } = staticConfig;
  if (variants2) {
    var variantValue = getVariantDefinition(variants2[key], value, conf2);
    if (!variantValue) {
      if (process.env.TAMAGUI_WARN_ON_MISSING_VARIANT === "1" && typeof value != "boolean") {
        var name = staticConfig.componentName || "[UnnamedComponent]";
        console.warn(`No variant found: ${name} has variant "${key}", but no matching value "${value}"`);
      }
      return;
    }
    if (typeof variantValue == "function") {
      var fn = variantValue, extras = getVariantExtras(styleState);
      variantValue = fn(value, extras);
    }
    var fontFamilyResult;
    if (isObj(variantValue)) {
      var fontFamilyUpdate = variantValue.fontFamily || variantValue[conf2.inverseShorthands.fontFamily];
      fontFamilyUpdate && (fontFamilyResult = getFontFamilyFromNameOrVariable(fontFamilyUpdate, conf2), styleState.fontFamily = fontFamilyResult, false), variantValue = resolveTokensAndVariants(key, variantValue, styleProps2, styleState, parentVariantKey);
    }
    if (variantValue) {
      var expanded = normalizeStyle$1(variantValue, !!styleProps2.noNormalize);
      var next = Object.entries(expanded);
      return fontFamilyResult && fontFamilyResult[0] === "$" && (lastFontFamilyToken = getVariableValue(fontFamilyResult)), next;
    }
  }
};
function getFontFamilyFromNameOrVariable(input, conf2) {
  if (isVariable(input)) {
    var val = variableToFontNameCache.get(input);
    if (val) return val;
    for (var key in conf2.fontsParsed) {
      var familyVariable = conf2.fontsParsed[key].family;
      if (isVariable(familyVariable) && (variableToFontNameCache.set(familyVariable, key), familyVariable === input)) return key;
    }
  } else if (typeof input == "string" && input[0] === "$") return input;
}
var variableToFontNameCache = /* @__PURE__ */ new WeakMap(), resolveTokensAndVariants = function(key, value, styleProps2, styleState, parentVariantKey) {
  var {
    conf: conf2,
    staticConfig,
    debug,
    theme
  } = styleState, {
    variants: variants2
  } = staticConfig, res = {};
  for (var _key in value) {
    var subKey = conf2.shorthands[_key] || _key, val = value[_key];
    if (!(!styleProps2.noSkip && subKey in skipProps)) {
      if (styleProps2.noExpand) res[subKey] = val;
      else if (variants2 && subKey in variants2) {
        if (parentVariantKey && parentVariantKey === key) res[subKey] = // SYNC WITH *1
        val[0] === "$" ? getTokenForKey(subKey, val, styleProps2, styleState) : val;
        else {
          var variantOut = resolveVariants(subKey, val, styleProps2, styleState, key);
          if (variantOut) {
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
            try {
              for (var _iterator = variantOut[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var [_$key, val1] = _step.value;
                if (val1 != null) if (_$key in pseudoDescriptors) {
                  var _res, _key1, _;
                  (_ = (_res = res)[_key1 = _$key]) !== null && _ !== void 0 || (_res[_key1] = {}), Object.assign(res[_$key], val1);
                } else res[_$key] = val1;
              }
            } catch (err) {
              _didIteratorError = true, _iteratorError = err;
            } finally {
              try {
                !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
              } finally {
                if (_didIteratorError) throw _iteratorError;
              }
            }
          }
        }
        continue;
      }
      if (isVariable(val)) {
        res[subKey] = resolveVariableValue(subKey, val, styleProps2.resolveValues);
        continue;
      }
      if (typeof val == "string") {
        var fVal = (
          // SYNC WITH *1
          val[0] === "$" ? getTokenForKey(subKey, val, styleProps2, styleState) : val
        );
        res[subKey] = fVal;
        continue;
      }
      if (isObj(val)) {
        var _res1, _subKey, subObject = resolveTokensAndVariants(subKey, val, styleProps2, styleState, key);
        var _1;
        (_1 = (_res1 = res)[_subKey = subKey]) !== null && _1 !== void 0 || (_res1[_subKey] = {}), Object.assign(res[subKey], subObject);
      } else res[subKey] = val;
    }
  }
  return res;
}, tokenCats = ["size", "color", "radius", "space", "zIndex"].map(function(name) {
  return {
    name,
    spreadName: `...${name}`
  };
});
function getVariantDefinition(variant, value, conf2) {
  if (variant) {
    if (typeof variant == "function") return variant;
    var exact = variant[value];
    if (exact) return exact;
    if (value != null) {
      var {
        tokensParsed
      } = conf2, _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
      try {
        for (var _iterator = tokenCats[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var {
            name,
            spreadName
          } = _step.value;
          if (spreadName in variant && name in tokensParsed && value in tokensParsed[name]) return variant[spreadName];
        }
      } catch (err) {
        _didIteratorError = true, _iteratorError = err;
      } finally {
        try {
          !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError) throw _iteratorError;
        }
      }
      var fontSizeVariant = variant["...fontSize"];
      if (fontSizeVariant && conf2.fontSizeTokens.has(value)) return fontSizeVariant;
    }
    return variant[`:${typeof value > "u" ? "undefined" : _type_of$6(value)}`] || variant["..."];
  }
}
var fontShorthand = {
  fontSize: "size",
  fontWeight: "weight"
}, lastFontFamilyToken = null, getTokenForKey = function(key, value, styleProps2, styleState) {
  var _staticConfig_accept, resolveAs = styleProps2.resolveValues || "none";
  if (resolveAs === "none") return value;
  var {
    theme,
    conf: conf2 = getConfig(),
    context: context2,
    fontFamily,
    staticConfig
  } = styleState, themeValue = theme ? theme[value] || theme[value.slice(1)] : void 0, tokensParsed = conf2.tokensParsed, valOrVar, hasSet = false, customTokenAccept = staticConfig == null || (_staticConfig_accept = staticConfig.accept) === null || _staticConfig_accept === void 0 ? void 0 : _staticConfig_accept[key];
  if (customTokenAccept) {
    var val = themeValue != null ? themeValue : tokensParsed[customTokenAccept][value];
    val != null && (resolveAs = "value", valOrVar = val, hasSet = true);
  }
  if (themeValue) {
    if (resolveAs === "except-theme") return value;
    valOrVar = themeValue, hasSet = true;
  } else {
    if (value in conf2.specificTokens) hasSet = true, valOrVar = conf2.specificTokens[value];
    else {
      switch (key) {
        case "fontFamily": {
          var _fontsParsed_value, fontsParsed = (context2 == null ? void 0 : context2.language) ? getFontsForLanguage(conf2.fontsParsed, context2.language) : conf2.fontsParsed;
          valOrVar = ((_fontsParsed_value = fontsParsed[value]) === null || _fontsParsed_value === void 0 ? void 0 : _fontsParsed_value.family) || value, lastFontFamilyToken = value, hasSet = true;
          break;
        }
        case "fontSize":
        case "lineHeight":
        case "letterSpacing":
        case "fontWeight": {
          var fam = fontFamily || conf2.defaultFontToken;
          if (fam) {
            var _font_, fontsParsed1 = (context2 == null ? void 0 : context2.language) ? getFontsForLanguage(conf2.fontsParsed, context2.language) : conf2.fontsParsed, font = fontsParsed1[fam] || fontsParsed1[conf2.defaultFontToken];
            valOrVar = (font == null || (_font_ = font[fontShorthand[key] || key]) === null || _font_ === void 0 ? void 0 : _font_[value]) || value, hasSet = true;
          }
          break;
        }
      }
      for (var cat in tokenCategories) if (key in tokenCategories[cat]) {
        var _tokensParsed_cat, res = (_tokensParsed_cat = tokensParsed[cat]) === null || _tokensParsed_cat === void 0 ? void 0 : _tokensParsed_cat[value];
        res != null ? (valOrVar = res, hasSet = true) : false;
      }
    }
    if (!hasSet) {
      var spaceVar = tokensParsed.space[value];
      spaceVar != null && (valOrVar = spaceVar, hasSet = true);
    }
  }
  if (hasSet) {
    var out = resolveVariableValue(key, valOrVar, resolveAs);
    return out;
  }
};
function resolveVariableValue(key, valOrVar, resolveValues) {
  if (resolveValues === "none") return valOrVar;
  if (isVariable(valOrVar)) {
    if (resolveValues === "value") return valOrVar.val;
    var get = valOrVar == null ? void 0 : valOrVar.get;
    if (key !== "shadowColor" && typeof get == "function") {
      var resolveDynamicFor = resolveValues === "web" ? "web" : void 0;
      return get(resolveDynamicFor);
    }
    return valOrVar.val;
  }
  return valOrVar;
}
var sortString = function(a, b2) {
  return a < b2 ? -1 : a > b2 ? 1 : 0;
};
function _type_of$5(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var conf;
function isValidStyleKey(key, validStyles2, accept) {
  return key in validStyles2 ? true : accept && key in accept;
}
var getSplitStyles = function(props, staticConfig, theme, themeName, componentState, styleProps2, parentSplitStyles, componentContext, groupContext, elementType, startedUnhydrated, debug) {
  var _loop2 = function(keyOg2) {
    var keyInit = keyOg2, valInit = props[keyInit];
    if (keyInit === "children") return viewProps[keyInit] = valInit, "continue";
    if (accept) {
      var accepted = accept[keyInit];
      if ((accepted === "style" || accepted === "textStyle") && valInit && (typeof valInit > "u" ? "undefined" : _type_of$5(valInit)) === "object") return viewProps[keyInit] = getSubStyle(styleState, keyInit, valInit, styleProps2.noClass), "continue";
    }
    if (disableExpandShorthands || keyInit in shorthands && (keyInit = shorthands[keyInit]), keyInit === "className") return "continue";
    if (keyInit in skipProps && !noSkip && !isHOC) {
      return "continue";
    }
    var isValidStyleKeyInit = isValidStyleKey(keyInit, validStyles$1, accept);
    if (!isValidStyleKeyInit) {
      if (!isAndroid && keyInit === "elevationAndroid") return "continue";
      if (keyInit === "userSelect") keyInit = "selectable", valInit = valInit !== "none";
      else if (keyInit.startsWith("data-")) return "continue";
    }
    if (keyInit === "dataSet") {
      for (var keyInit1 in valInit) viewProps[`data-${hyphenate(keyInit1)}`] = valInit[keyInit1];
      return "continue";
    }
    var isVariant = !isValidStyleKeyInit && variants2 && keyInit in variants2, isStyleLikeKey = isValidStyleKeyInit || isVariant, isPseudo = keyInit in validPseudoKeys, isMedia = !isStyleLikeKey && !isPseudo ? getMediaKey(keyInit) : false, isMediaOrPseudo = !!(isMedia || isPseudo);
    if (isMediaOrPseudo && isMedia === "group") {
      var parts = keyInit.split("-"), plen = parts.length;
      if (
        // check if its actually a simple group selector to avoid breaking selectors
        plen === 2 || plen === 3 && pseudoPriorities[parts[parts.length - 1]]
      ) {
        var name2 = parts[1];
        groupContext && !(groupContext == null ? void 0 : groupContext[name2]) && (keyInit = keyInit.replace("$group-", "$group-true-"));
      }
    }
    var isStyleProp = isValidStyleKeyInit || isMediaOrPseudo || isVariant && !noExpand;
    if (isStyleProp && (asChild === "except-style" || asChild === "except-style-web")) return "continue";
    var shouldPassProp = !isStyleProp && isHOC || // is in parent variants
    isHOC && parentVariants && keyInit in parentVariants || (inlineProps == null ? void 0 : inlineProps.has(keyInit)), parentVariant = parentVariants == null ? void 0 : parentVariants[keyInit], isHOCShouldPassThrough = !!(isHOC && (isValidStyleKeyInit || isMediaOrPseudo || parentVariant || keyInit in skipProps)), shouldPassThrough = shouldPassProp || isHOCShouldPassThrough;
    if (shouldPassThrough && (passDownProp(viewProps, keyInit, valInit, isMediaOrPseudo), !isVariant)) return "continue";
    if (!noSkip && keyInit in skipProps) return "continue";
    (isText || isInput) && valInit && (keyInit === "fontFamily" || keyInit === shorthands.fontFamily) && valInit in conf.fontsParsed && (styleState.fontFamily = valInit);
    var disablePropMap = isMediaOrPseudo || !isStyleLikeKey;
    if (propMapper(keyInit, valInit, styleState, disablePropMap, function(key4, val2) {
      var _parentStaticConfig_variants, isStyledContextProp = styledContext && key4 in styledContext;
      if (!isHOC && disablePropMap && !isStyledContextProp && !isMediaOrPseudo) {
        viewProps[key4] = val2;
        return;
      }
      if (val2 != null) {
        if (key4 === "pointerEvents") {
          viewProps[key4] = val2;
          return;
        }
        if (!isHOC && isValidStyleKey(key4, validStyles$1, accept) || isAndroid && key4 === "elevation") {
          mergeStyle(styleState, key4, val2, 1);
          return;
        }
        if (isPseudo = key4 in validPseudoKeys, isMedia = isPseudo ? false : getMediaKey(key4), isMediaOrPseudo = !!(isMedia || isPseudo), isVariant = variants2 && key4 in variants2, (inlineProps == null ? void 0 : inlineProps.has(key4)) || process.env.IS_STATIC === "is_static" && (inlineWhenUnflattened == null ? void 0 : inlineWhenUnflattened.has(key4))) {
          var _props_key;
          viewProps[key4] = (_props_key = props[key4]) !== null && _props_key !== void 0 ? _props_key : val2;
        }
        var shouldPassThrough2 = styleProps2.noExpand && isPseudo || isHOC && (isMediaOrPseudo || (parentStaticConfig == null || (_parentStaticConfig_variants = parentStaticConfig.variants) === null || _parentStaticConfig_variants === void 0 ? void 0 : _parentStaticConfig_variants[keyInit]));
        if (shouldPassThrough2) {
          passDownProp(viewProps, key4, val2, isMediaOrPseudo);
          return;
        }
        if (isPseudo) {
          if (!val2) return;
          var pseudoStyleObject = getSubStyle(styleState, key4, val2, styleProps2.noClass && process.env.IS_STATIC !== "is_static");
          {
            var _pseudos, _key;
            if (pseudos || (pseudos = {}), (_pseudos = pseudos)[_key = key4] || (_pseudos[_key] = {}), process.env.IS_STATIC === "is_static") {
              Object.assign(pseudos[key4], pseudoStyleObject);
              return;
            }
          }
          var descriptor = pseudoDescriptors[key4], isEnter = key4 === "enterStyle", isExit = key4 === "exitStyle";
          if (!descriptor) return;
          {
            var descriptorKey = descriptor.stateKey || descriptor.name, isDisabled2 = componentState[descriptorKey] === false;
            isExit && (isDisabled2 = !styleProps2.isExiting), isEnter && componentState.unmounted === false && (isDisabled2 = true);
            var importance = descriptor.priority;
            for (var pkey in pseudoStyleObject) {
              var _$val = pseudoStyleObject[pkey];
              if (isDisabled2) applyDefaultStyle(pkey, styleState);
              else {
                var curImportance = styleState.usedKeys[pkey] || 0, shouldMerge = importance >= curImportance;
                if (shouldMerge) {
                  if (process.env.IS_STATIC === "is_static") {
                    var _pseudos1, _key1;
                    pseudos || (pseudos = {}), (_pseudos1 = pseudos)[_key1 = key4] || (_pseudos1[_key1] = {}), pseudos[key4][pkey] = _$val;
                  }
                  mergeStyle(styleState, pkey, _$val, importance);
                }
              }
            }
            if (!isDisabled2) for (var _$key in val2) {
              var k = shorthands[_$key] || _$key;
              styleState.usedKeys[k] = Math.max(importance, styleState.usedKeys[k] || 0);
            }
          }
          return;
        }
        if (isMedia) {
          if (!val2) return;
          val2.space;
          var mediaKeyShort = key4.slice(isMedia == "theme" ? 7 : 1);
          if (hasMedia || (hasMedia = true), (!hasMedia || typeof hasMedia == "boolean") && (hasMedia = /* @__PURE__ */ new Set()), hasMedia.add(mediaKeyShort), isMedia === "platform" && !isActivePlatform(key4)) return;
          var priority = mediaStylesSeen;
          if (mediaStylesSeen += 1, shouldDoClasses) ;
          else {
            let mergeMediaStyle2 = function(key5, val3) {
              var _styleState4;
              (_styleState4 = styleState).style || (_styleState4.style = {});
              var didMerge = mergeMediaByImportance(styleState, mediaKeyShort, key5, val3, mediaState[mediaKeyShort], importanceBump);
              didMerge && key5 === "fontFamily" && (styleState.fontFamily = mediaStyle1.fontFamily);
            };
            var isThemeMedia = isMedia === "theme", isGroupMedia = isMedia === "group", isPlatformMedia = isMedia === "platform";
            if (!isThemeMedia && !isPlatformMedia && !isGroupMedia) {
              if (!mediaState[mediaKeyShort]) {
                return;
              }
            }
            var mediaStyle1 = getSubStyle(styleState, key4, val2, true), importanceBump = 0;
            if (isThemeMedia) {
              if (dynamicThemeAccess = true, isIos && getSetting("fastSchemeChange")) {
                var _styleState3;
                (_styleState3 = styleState).style || (_styleState3.style = {});
                var scheme = mediaKeyShort, oppositeScheme = getOppositeScheme(mediaKeyShort);
                for (var subKey1 in mediaStyle1) {
                  var _$val1 = extractValueFromDynamic(mediaStyle1[subKey1], scheme), oppositeVal = extractValueFromDynamic(styleState.style[subKey1], oppositeScheme);
                  mediaStyle1[subKey1] = getDynamicVal({
                    scheme,
                    val: _$val1,
                    oppositeVal
                  }), mergeStyle(styleState, subKey1, mediaStyle1[subKey1], priority);
                }
              } else if (!(themeName === mediaKeyShort || themeName.startsWith(mediaKeyShort))) return;
            } else if (isGroupMedia) {
              var _groupContext_groupName, _componentState_group, groupInfo = getGroupPropParts(mediaKeyShort), groupName = groupInfo.name, groupState = groupContext == null || (_groupContext_groupName = groupContext[groupName]) === null || _groupContext_groupName === void 0 ? void 0 : _groupContext_groupName.state, groupPseudoKey = groupInfo.pseudo, groupMediaKey = groupInfo.media;
              if (!groupState) {
                pseudoGroups || (pseudoGroups = /* @__PURE__ */ new Set());
                return;
              }
              var componentGroupState = (_componentState_group = componentState.group) === null || _componentState_group === void 0 ? void 0 : _componentState_group[groupName];
              if (groupMediaKey) {
                mediaGroups || (mediaGroups = /* @__PURE__ */ new Set()), mediaGroups.add(groupMediaKey);
                var mediaState1 = componentGroupState == null ? void 0 : componentGroupState.media, isActive = mediaState1 == null ? void 0 : mediaState1[groupMediaKey];
                if (!mediaState1 && groupState.layout && (isActive = mediaKeyMatch(groupMediaKey, groupState.layout)), !isActive) {
                  for (var pkey1 in mediaStyle1) applyDefaultStyle(pkey1, styleState);
                  return;
                }
                importanceBump = 2;
              }
              if (groupPseudoKey) {
                var _this;
                pseudoGroups || (pseudoGroups = /* @__PURE__ */ new Set()), pseudoGroups.add(groupName);
                var componentGroupPseudoState = (_this = componentGroupState || (groupContext == null ? void 0 : groupContext[groupName].state)) === null || _this === void 0 ? void 0 : _this.pseudo, isActive1 = componentGroupPseudoState == null ? void 0 : componentGroupPseudoState[groupPseudoKey], priority1 = pseudoPriorities[groupPseudoKey];
                if (!isActive1) {
                  for (var pkey2 in mediaStyle1) applyDefaultStyle(pkey2, styleState);
                  return;
                }
                importanceBump = priority1;
              }
            }
            for (var subKey2 in mediaStyle1) {
              if (subKey2 === "space") {
                space = valInit.space;
                continue;
              }
              if (subKey2[0] === "$") {
                if (!isActivePlatform(subKey2) || !isActiveTheme(subKey2, themeName)) continue;
                for (var subSubKey in mediaStyle1[subKey2]) mergeMediaStyle2(subSubKey, mediaStyle1[subKey2][subSubKey]);
              } else mergeMediaStyle2(subKey2, mediaStyle1[subKey2]);
            }
          }
          return;
        }
        if (!isVariant) {
          if (isStyledContextProp) return;
          viewProps[key4] = val2;
        }
      }
    }), false) ;
  };
  conf = conf || getConfig();
  (componentContext == null ? void 0 : componentContext.animationDriver) || conf.animations;
  if (props.passThrough) return null;
  var {
    shorthands
  } = conf, {
    isHOC,
    isText,
    isInput,
    variants: variants2,
    isReactNative,
    inlineProps,
    inlineWhenUnflattened,
    parentStaticConfig,
    acceptsClassName
  } = staticConfig, viewProps = {}, mediaState = styleProps2.mediaState || exports.mediaState, shouldDoClasses = acceptsClassName && isWeb, rulesToInsert = void 0, classNames = {}, pseudos = null, space = props.space, hasMedia = false, dynamicThemeAccess, pseudoGroups, mediaGroups;
  props.className || "";
  var mediaStylesSeen = 0, validStyles$1 = staticConfig.validStyles || (staticConfig.isText || staticConfig.isInput ? stylePropsText : validStyles);
  var styleState = {
    classNames,
    conf,
    props,
    styleProps: styleProps2,
    componentState,
    staticConfig,
    style: null,
    theme,
    usedKeys: {},
    viewProps,
    context: componentContext,
    debug
  };
  if (process.env.IS_STATIC === "is_static") {
    var {
      fallbackProps
    } = styleProps2;
    fallbackProps && (styleState.props = new Proxy(props, {
      get(_, key4, val2) {
        return Reflect.has(props, key4) ? Reflect.get(props, key4) : Reflect.get(fallbackProps, key4);
      }
    }));
  }
  var {
    asChild
  } = props, {
    accept
  } = staticConfig, {
    noSkip,
    disableExpandShorthands,
    noExpand,
    styledContext
  } = styleProps2, {
    webContainerType
  } = conf.settings, parentVariants = parentStaticConfig == null ? void 0 : parentStaticConfig.variants;
  for (var keyOg in props) _loop2(keyOg);
  var avoidNormalize = styleProps2.noNormalize === false;
  if (!avoidNormalize) {
    if (styleState.style && (fixStyles(styleState.style), !styleProps2.noExpand && !styleProps2.noMergeStyle && isWeb), styleState.flatTransforms) {
      var _styleState;
      (_styleState = styleState).style || (_styleState.style = {}), mergeFlatTransforms(styleState.style, styleState.flatTransforms);
    }
  }
  var styleProp = props.style;
  if (!styleProps2.noMergeStyle && styleProp) if (isHOC) viewProps.style = normalizeStyle(styleProp);
  else for (var isArray2 = Array.isArray(styleProp), len = isArray2 ? styleProp.length : 1, i = 0; i < len; i++) {
    var style = isArray2 ? styleProp[i] : styleProp;
    if (style) if (style.$$css) Object.assign(styleState.classNames, style);
    else {
      var _styleState2;
      (_styleState2 = styleState).style || (_styleState2.style = {}), Object.assign(styleState.style, normalizeStyle(style));
    }
  }
  var style1 = styleState.style;
  if (style1 == null ? void 0 : style1.fontFamily) {
    var _getFont, faceInfo = (_getFont = getFont(style1.fontFamily)) === null || _getFont === void 0 ? void 0 : _getFont.face;
    if (faceInfo) {
      var _faceInfo_style_fontWeight_, _faceInfo_style_fontWeight, overrideFace = (_faceInfo_style_fontWeight = faceInfo[style1.fontWeight]) === null || _faceInfo_style_fontWeight === void 0 || (_faceInfo_style_fontWeight_ = _faceInfo_style_fontWeight[style1.fontStyle || "normal"]) === null || _faceInfo_style_fontWeight_ === void 0 ? void 0 : _faceInfo_style_fontWeight_.val;
      overrideFace && (style1.fontFamily = overrideFace, styleState.fontFamily = overrideFace, delete style1.fontWeight, delete style1.fontStyle);
    }
  }
  var result = {
    space,
    hasMedia,
    fontFamily: styleState.fontFamily,
    viewProps,
    style: styleState.style,
    pseudos,
    classNames,
    rulesToInsert,
    dynamicThemeAccess,
    pseudoGroups,
    mediaGroups
  }, asChildExceptStyleLike = asChild === "except-style" || asChild === "except-style-web";
  if (!styleProps2.noMergeStyle && !asChildExceptStyleLike) {
    var style2 = styleState.style;
    style2 && (viewProps.style = style2);
  }
  return result;
};
function mergeFlatTransforms(target, flatTransforms) {
  Object.entries(flatTransforms).sort(function(param, param1) {
    var [a] = param, [b2] = param1;
    return sortString(a, b2);
  }).forEach(function(param) {
    var [key, val] = param;
    mergeTransform(target, key, val, true);
  });
}
function mergeStyle(styleState, key, val, importance) {
  var {
    viewProps,
    styleProps: styleProps2,
    staticConfig,
    usedKeys
  } = styleState, existingImportance = usedKeys[key] || 0;
  if (!(existingImportance > importance)) if (key in stylePropsTransform) {
    var _styleState;
    (_styleState = styleState).flatTransforms || (_styleState.flatTransforms = {}), usedKeys[key] = importance, styleState.flatTransforms[key] = val;
  } else {
    var shouldNormalize = isWeb, out = shouldNormalize ? normalizeValueWithProperty$1(val) : val;
    if (
      // accept is for props not styles
      staticConfig.accept && key in staticConfig.accept
    ) viewProps[key] = out;
    else {
      var _styleState1;
      (_styleState1 = styleState).style || (_styleState1.style = {}), usedKeys[key] = importance, styleState.style[key] = // if you dont do this you'll be passing props.transform arrays directly here and then mutating them
      // if theres any flatTransforms later, causing issues (mutating props is bad, in strict mode styles get borked)
      key === "transform" && Array.isArray(out) ? [...out] : out;
    }
  }
}
var getSubStyle = function(styleState, subKey, styleIn, avoidMergeTransform) {
  var _loop2 = function(key1) {
    var val = styleIn[key1];
    key1 = conf2.shorthands[key1] || key1;
    var shouldSkip = !staticConfig.isHOC && key1 in skipProps && !styleProps2.noSkip;
    if (shouldSkip) return key = key1, "continue";
    propMapper(key1, val, styleState, false, function(skey, sval) {
      skey in validPseudoKeys && (sval = getSubStyle(styleState, skey, sval, avoidMergeTransform)), !avoidMergeTransform && skey in stylePropsTransform ? mergeTransform(styleOut, skey, sval) : styleOut[skey] = styleProps2.noNormalize ? sval : normalizeValueWithProperty$1(sval);
    }), key = key1;
  }, {
    staticConfig,
    conf: conf2,
    styleProps: styleProps2
  } = styleState, styleOut = {};
  for (var key in styleIn) _loop2(key);
  if (!avoidMergeTransform) {
    if (Array.isArray(styleOut.transform)) {
      var _styleState_style, parentTransform = (_styleState_style = styleState.style) === null || _styleState_style === void 0 ? void 0 : _styleState_style.transform;
      parentTransform && (styleOut.transform = [...parentTransform, ...styleOut.transform]);
    }
    styleState.flatTransforms && mergeFlatTransforms(styleOut, styleState.flatTransforms);
  }
  return styleProps2.noNormalize || fixStyles(styleOut), styleOut;
}, useSplitStyles = function(a, b2, c, d, e2, f, g, h2, i, j, k, l) {
  var res = getSplitStyles(a, b2, c, d, e2, f, g, h2, i, j, k, l);
  return res;
};
var defaultColor = process.env.TAMAGUI_DEFAULT_COLOR || "rgba(0,0,0,0)", animatableDefaults = __spreadProps(__spreadValues({}, Object.fromEntries(Object.entries(tokenCategories.color).map(function(param) {
  var [k, v] = param;
  return [k, defaultColor];
}))), {
  opacity: 1,
  scale: 1,
  rotate: "0deg",
  rotateY: "0deg",
  rotateX: "0deg",
  x: 0,
  y: 0,
  borderRadius: 0
}), lowercaseHyphenate = function(match) {
  return `-${match.toLowerCase()}`;
}, hyphenate = function(str) {
  return str.replace(/[A-Z]/g, lowercaseHyphenate);
}, mergeTransform = function(obj, key, val) {
  var backwards = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, _obj;
  typeof obj.transform != "string" && ((_obj = obj).transform || (_obj.transform = []), obj.transform[backwards ? "unshift" : "push"]({
    [mapTransformKeys[key] || key]: val
  }));
}, mapTransformKeys = {
  x: "translateX",
  y: "translateY"
};
function passDownProp(viewProps, key, val) {
  var shouldMergeObject = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (shouldMergeObject) {
    var next = __spreadValues(__spreadValues({}, viewProps[key]), val);
    delete viewProps[key], viewProps[key] = next;
  } else viewProps[key] = val;
}
function mergeMediaByImportance(styleState, mediaKey, key, value, isSizeMedia, importanceBump, debugProp) {
  styleState.usedKeys;
  var importance = getMediaImportanceIfMoreImportant(mediaKey, key, styleState, isSizeMedia);
  if (importanceBump && (importance = (importance || 0) + importanceBump), importance === null) return false;
  if (key in pseudoDescriptors) {
    var descriptor = pseudoDescriptors[key], descriptorKey = descriptor.stateKey || descriptor.name, isDisabled2 = styleState.componentState[descriptorKey] === false;
    if (isDisabled2) return false;
    for (var subKey in value) mergeStyle(styleState, subKey, value[subKey], importance);
  } else mergeStyle(styleState, key, value, importance);
  return true;
}
function normalizeStyle(style) {
  var out = {};
  for (var key in style) {
    var val = style[key];
    key in stylePropsTransform ? mergeTransform(out, key, val) : out[key] = normalizeValueWithProperty$1(val);
  }
  return fixStyles(out), out;
}
function applyDefaultStyle(pkey, styleState) {
  var defaultValues = animatableDefaults[pkey];
  defaultValues != null && !(pkey in styleState.usedKeys) && (!styleState.style || !(pkey in styleState.style)) && mergeStyle(styleState, pkey, defaultValues, 1);
}
function setElementProps(element) {
  element && !element.getBoundingClientRect && (element.getBoundingClientRect = function() {
    if (element.unstable_getBoundingClientRect != null) return element.unstable_getBoundingClientRect();
  });
}
var subscribeToContextGroup = function(props) {
  var {
    pseudoGroups,
    mediaGroups,
    groupContext
  } = props;
  if (pseudoGroups || mediaGroups) {
    var disposables = /* @__PURE__ */ new Set();
    if (pseudoGroups) for (var _i = 0, _iter = [...pseudoGroups]; _i < _iter.length; _i++) {
      var name = _iter[_i];
      disposables.add(createGroupListener(name, props));
    }
    if (mediaGroups) for (var _i1 = 0, _iter1 = [...mediaGroups]; _i1 < _iter1.length; _i1++) {
      var name1 = _iter1[_i1];
      disposables.add(createGroupListener(name1, props));
    }
    return function() {
      disposables.forEach(function(d) {
        return d();
      });
    };
  }
}, createGroupListener = function(name, param) {
  var {
    setStateShallow,
    pseudoGroups,
    mediaGroups,
    groupContext
  } = param, parent = groupContext == null ? void 0 : groupContext[name];
  if (!parent) return function() {
  };
  var dispose2 = parent.subscribe(function(param2) {
    var {
      layout,
      pseudo
    } = param2;
    setStateShallow(function(prev) {
      var _prev_group, didChange = false, group = ((_prev_group = prev.group) === null || _prev_group === void 0 ? void 0 : _prev_group[name]) || {
        pseudo: {},
        media: {}
      };
      if (pseudo && (pseudoGroups == null ? void 0 : pseudoGroups.has(name))) {
        var _group;
        (_group = group).pseudo || (_group.pseudo = {});
        var next = mergeIfNotShallowEqual(group.pseudo, pseudo);
        next !== group.pseudo && (Object.assign(group.pseudo, pseudo), didChange = true);
      } else if (layout && mediaGroups) {
        var _group1;
        (_group1 = group).media || (_group1.media = {});
        var mediaState = getMediaState(mediaGroups, layout), next1 = mergeIfNotShallowEqual(group.media, mediaState);
        next1 !== group.media && (Object.assign(group.media, next1), didChange = true);
      }
      return didChange ? {
        group: __spreadProps(__spreadValues({}, prev.group), {
          [name]: group
        })
      } : prev;
    });
  });
  return function() {
    dispose2(), setStateShallow({
      group: {}
    });
  };
};
var Theme = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  if (props.disable) return props.children;
  var {
    passThrough
  } = props, isRoot = !!props._isRoot, [_, themeState] = useThemeWithState(props, isRoot), disableDirectChildTheme = props["disable-child-theme"], finalChildren = disableDirectChildTheme ? React.Children.map(props.children, function(child) {
    return passThrough ? child : /* @__PURE__ */ React.cloneElement(child, {
      "data-disable-theme": true
    });
  }) : props.children;
  if (ref) try {
    React.Children.only(finalChildren), finalChildren = /* @__PURE__ */ React.cloneElement(finalChildren, {
      ref
    });
  } catch (e2) {
  }
  var stateRef = React.useRef({
    hasEverThemed: false
  });
  return getThemedChildren(themeState, finalChildren, props, isRoot, stateRef, passThrough);
});
Theme.avoidForwardRef = true;
function getThemedChildren(themeState, children, props) {
  var isRoot = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, stateRef = arguments.length > 4 ? arguments[4] : void 0, passThrough = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false, {
    shallow,
    forceClassName
  } = props, state = stateRef.current, hasEverThemed = state.hasEverThemed, shouldRenderChildrenWithTheme = hasEverThemed || themeState.isNew || isRoot || hasThemeUpdatingProps(props);
  if (!shouldRenderChildrenWithTheme) return children;
  children = /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeStateContext.Provider, {
    value: themeState.id,
    children
  });
  var {
    isInverse,
    name
  } = themeState, requiresExtraWrapper = isInverse || forceClassName;
  if (state.hasEverThemed || (state.hasEverThemed = true), (requiresExtraWrapper || // if the theme is exactly dark or light, its likely to change between dark/light
  // and that would require wrapping which would re-parent, so to avoid re-parenting do this
  themeState.name === "dark" || themeState.name === "light") && (state.hasEverThemed = "wrapped"), shallow && themeState.parentId) {
    var parentState = getThemeState(themeState.isNew ? themeState.id : themeState.parentId);
    if (!parentState) throw new Error("010");
    children = React.Children.toArray(children).map(function(child) {
      return /* @__PURE__ */ React.isValidElement(child) ? passThrough ? child : /* @__PURE__ */ React.cloneElement(child, void 0, /* @__PURE__ */ jsxRuntimeExports.jsx(Theme, {
        name: parentState.name,
        children: child.props.children
      })) : child;
    });
  }
  if (forceClassName === false) return children;
  return children;
}
function themeable(Component, staticConfig) {
  var optimize = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, withThemeComponent = /* @__PURE__ */ React.forwardRef(function(props, ref) {
    var _a = props, {
      themeInverse,
      theme,
      componentName,
      themeReset
    } = _a, rest = __objRest(_a, [
      "themeInverse",
      "theme",
      "componentName",
      "themeReset"
    ]), overriddenContextProps, context2 = staticConfig == null ? void 0 : staticConfig.context;
    if (context2) for (var key in context2.props) {
      var val = props[key];
      val !== void 0 && (overriddenContextProps || (overriddenContextProps = {}), overriddenContextProps[key] = val);
    }
    var element = (
      // @ts-expect-error its ok
      /* @__PURE__ */ jsxRuntimeExports.jsx(Component, __spreadProps(__spreadValues({
        ref
      }, rest), {
        "data-disable-theme": true
      }))
    ), filteredProps = null, compName = componentName || (staticConfig == null ? void 0 : staticConfig.componentName);
    if (compName && (filteredProps || (filteredProps = {}), filteredProps.componentName = compName), "debug" in props && (filteredProps || (filteredProps = {}), filteredProps.debug = props.debug), "theme" in props && (filteredProps || (filteredProps = {}), filteredProps.name = props.theme), "themeInverse" in props && (filteredProps || (filteredProps = {}), filteredProps.inverse = props.themeInverse), "themeReset" in props && (filteredProps || (filteredProps = {}), filteredProps.reset = themeReset), optimize && !filteredProps) return element;
    var contents = /* @__PURE__ */ jsxRuntimeExports.jsx(Theme, __spreadProps(__spreadValues({
      "disable-child-theme": true
    }, filteredProps), {
      children: element
    }));
    if (context2) {
      var Provider = context2.Provider, contextValue = React.useContext(context2);
      contents = /* @__PURE__ */ jsxRuntimeExports.jsx(Provider, __spreadProps(__spreadValues(__spreadValues({}, contextValue), overriddenContextProps), {
        children: contents
      }));
    }
    return contents;
  }), withTheme = withThemeComponent;
  return withTheme.displayName = `Themed(${(Component == null ? void 0 : Component.displayName) || (Component == null ? void 0 : Component.name) || "Anonymous"})`, withTheme;
}
function getStyleTags(styles2) {
}
var ClientOnlyContext = /* @__PURE__ */ React.createContext(false), ClientOnly = function(param) {
  var {
    children,
    enabled
  } = param, existingValue = React.useContext(ClientOnlyContext);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ClientOnlyContext.Provider, {
    value: enabled != null ? enabled : existingValue,
    children
  });
};
var useIsClientOnly = function() {
  return React__namespace.useContext(ClientOnlyContext);
};
function useDidFinishSSR() {
  React__namespace.useContext(ClientOnlyContext);
  return true;
}
function _type_of$4(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var useComponentState = function(props, animationDriver, staticConfig, config) {
  var _animationDriver_usePresence, isHydrated = useDidFinishSSR(), needsHydration = !useIsClientOnly(), useAnimations = animationDriver == null ? void 0 : animationDriver.useAnimations, {
    isHOC
  } = staticConfig, stateRef = React.useRef(
    // performance: avoid creating object every render
    void 0
  );
  stateRef.current || (stateRef.current = {
    startedUnhydrated: needsHydration && !isHydrated
  });
  var hasAnimationProp = !!(!isHOC && "animation" in props || props.style && hasAnimatedStyleValue(props.style)), supportsCSS = animationDriver == null ? void 0 : animationDriver.supportsCSS, curStateRef = stateRef.current;
  !needsHydration && hasAnimationProp && (curStateRef.hasAnimated = true);
  var willBeAnimatedClient = (function() {
    var next = !!(hasAnimationProp && !isHOC && useAnimations);
    return !!(next || curStateRef.hasAnimated);
  })(), willBeAnimated = willBeAnimatedClient;
  willBeAnimated && !curStateRef.hasAnimated && (curStateRef.hasAnimated = true);
  var {
    disableClassName
  } = props, presence = !isHOC && willBeAnimated && props.animatePresence !== false && (animationDriver == null || (_animationDriver_usePresence = animationDriver.usePresence) === null || _animationDriver_usePresence === void 0 ? void 0 : _animationDriver_usePresence.call(animationDriver)) || null, presenceState = presence == null ? void 0 : presence[2], isExiting = (presenceState == null ? void 0 : presenceState.isPresent) === false, isEntering = (presenceState == null ? void 0 : presenceState.isPresent) === true && presenceState.initial !== false, hasEnterStyle = !!props.enterStyle, hasAnimationThatNeedsHydrate = hasAnimationProp && !isHydrated, canImmediatelyEnter = hasEnterStyle || isEntering, shouldEnter = !isHOC && (hasEnterStyle || isEntering || hasAnimationThatNeedsHydrate || // disableClassName doesnt work server side, only client, so needs hydrate
  // this is just for a better ux, supports css variables for light/dark, media queries, etc
  disableClassName), initialState = shouldEnter ? (
    // on the very first render we switch all spring animation drivers to css rendering
    // this is because we need to use css variables, which they don't support to do proper SSR
    // without flickers of the wrong colors.
    // but once we do that initial hydration and we are in client side rendering mode,
    // we can avoid the extra re-render on mount
    canImmediatelyEnter ? defaultComponentStateShouldEnter : defaultComponentState
  ) : defaultComponentStateMounted, disabled = isDisabled(props);
  disabled != null && (initialState.disabled = disabled);
  var states2 = React.useState(initialState), state = props.forceStyle ? __spreadProps(__spreadValues({}, states2[0]), {
    [props.forceStyle]: true
  }) : states2[0], setState = states2[1], isAnimated = willBeAnimated;
  disabled !== state.disabled && (disabled && Object.assign(state, defaultComponentStateMounted), state.disabled = disabled, setState(function(_) {
    return __spreadValues({}, state);
  }));
  var groupName = props.group, setStateShallow = useCreateShallowSetState(setState, props.debug);
  if (presenceState && isAnimated && isHydrated && staticConfig.variants) {
    var {
      enterVariant,
      exitVariant,
      enterExitVariant,
      custom
    } = presenceState;
    isObj(custom) && Object.assign(props, custom);
    var exv = exitVariant != null ? exitVariant : enterExitVariant, env = enterVariant != null ? enterVariant : enterExitVariant;
    state.unmounted && env && staticConfig.variants[env] ? props[env] = true : isExiting && exv && (props[exv] = exitVariant !== enterExitVariant);
  }
  var noClass = !isWeb;
  return {
    startedUnhydrated: curStateRef.startedUnhydrated,
    curStateRef,
    disabled,
    groupName,
    hasAnimationProp,
    hasEnterStyle,
    isAnimated,
    isExiting,
    isHydrated,
    presence,
    presenceState,
    setState,
    setStateShallow,
    noClass,
    state,
    stateRef,
    supportsCSS,
    willBeAnimated,
    willBeAnimatedClient
  };
};
function hasAnimatedStyleValue(style) {
  return Object.keys(style).some(function(k) {
    var val = style[k];
    return val && (typeof val > "u" ? "undefined" : _type_of$4(val)) === "object" && "_animation" in val;
  });
}
var isDisabled = function(props) {
  var _props_accessibilityState;
  return props.disabled || props.passThrough || ((_props_accessibilityState = props.accessibilityState) === null || _props_accessibilityState === void 0 ? void 0 : _props_accessibilityState.disabled) || props["aria-disabled"] || props.accessibilityDisabled || false;
};
var hooks = {};
function setupHooks(next) {
  Object.assign(hooks, next);
}
var is19 = React.version.startsWith("19."), Slot = /* @__PURE__ */ React.memo(/* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    children
  } = _a, slotProps = __objRest(_a, [
    "children"
  ]);
  if (/* @__PURE__ */ React.isValidElement(children)) {
    var mergedProps = mergeSlotProps(children, slotProps);
    return /* @__PURE__ */ React.cloneElement(children, children.type.avoidForwardRef ? mergedProps : __spreadProps(__spreadValues({}, mergedProps), {
      ref: composeRefs(forwardedRef, is19 ? children.props.ref : children.ref)
    }));
  }
  return React.Children.count(children) > 1 ? React.Children.only(null) : null;
})), Slottable = function(param) {
  var {
    children
  } = param;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children
  });
};
Slottable.displayName = "Slottable";
var pressMap = {};
function mergeSlotProps(child, slotProps) {
  var childProps = child.props, overrideProps = __spreadValues({}, childProps), isHTMLChild = typeof child.type == "string";
  if (isHTMLChild) for (var key in pressMap) key in slotProps && (slotProps[pressMap[key]] = slotProps[key], delete slotProps[key]);
  for (var propName in childProps) {
    var slotPropValue = slotProps[propName], childPropValue = childProps[propName];
    isHTMLChild && propName in pressMap && (propName = pressMap[propName], delete overrideProps[propName]);
    var isHandler = handleRegex.test(propName);
    isHandler ? overrideProps[propName] = composeEventHandlers(childPropValue, slotPropValue) : propName === "style" ? overrideProps[propName] = __spreadValues(__spreadValues({}, slotPropValue), childPropValue) : propName === "className" && (overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" "));
  }
  return __spreadValues(__spreadValues({}, slotProps), overrideProps);
}
var handleRegex = /^on[A-Z]/;
var componentSetStates = /* @__PURE__ */ new Set(), avoidReRenderKeys = /* @__PURE__ */ new Set(["hover", "press", "pressIn", "group", "focus", "focusWithin", "media", "group"]);
var BaseText, BaseView, hasSetupBaseViews = false, lastInteractionWasKeyboard = {
  value: false
};
function createComponent(staticConfig) {
  var {
    componentName
  } = staticConfig, config = null, defaultProps2 = staticConfig.defaultProps;
  onConfiguredOnce(function(conf2) {
    if (config = conf2, componentName) {
      var _conf_defaultProps, defaultForComponent = (_conf_defaultProps = conf2.defaultProps) === null || _conf_defaultProps === void 0 ? void 0 : _conf_defaultProps[componentName];
      defaultForComponent && (defaultProps2 = __spreadValues(__spreadValues({}, defaultForComponent), defaultProps2));
    }
  });
  var {
    Component,
    isText,
    isZStack,
    isHOC
  } = staticConfig;
  var component = /* @__PURE__ */ React.forwardRef(function(propsIn, forwardedRef) {
    var _hooks_usePropsTransform, _hooks_useEvents, _config_animations;
    if (!hasSetupBaseViews) {
      var _hooks_getBaseViews;
      hasSetupBaseViews = true;
      var baseViews2 = (_hooks_getBaseViews = hooks.getBaseViews) === null || _hooks_getBaseViews === void 0 ? void 0 : _hooks_getBaseViews.call(hooks);
      baseViews2 && (BaseText = baseViews2.Text, BaseView = baseViews2.View);
    }
    var {
      context: context2,
      isReactNative
    } = staticConfig, debugProp = propsIn.debug, styledContextValue = context2 ? React.useContext(context2) : void 0, overriddenContextProps = null;
    var props = propsIn;
    if (styledContextValue || defaultProps2) {
      var [nextProps, overrides] = mergeComponentProps(defaultProps2, styledContextValue, propsIn);
      nextProps && (props = nextProps), overriddenContextProps = overrides;
    }
    var componentName2 = props.componentName || staticConfig.componentName;
    var componentContext = React.useContext(ComponentContext), groupContextParent = React.useContext(GroupContext), animationDriver = componentContext.animationDriver, useAnimations = animationDriver == null ? void 0 : animationDriver.useAnimations, componentState = useComponentState(props, animationDriver, staticConfig), {
      disabled,
      groupName,
      hasAnimationProp,
      hasEnterStyle,
      isAnimated,
      isExiting,
      isHydrated,
      presence,
      presenceState,
      setState,
      noClass,
      state,
      stateRef,
      supportsCSS,
      willBeAnimated,
      willBeAnimatedClient,
      startedUnhydrated
    } = componentState;
    hasAnimationProp && (animationDriver == null ? void 0 : animationDriver.avoidReRenders) && useIsomorphicLayoutEffect(function() {
      var pendingState = stateRef.current.nextState;
      pendingState && (stateRef.current.nextState = void 0, componentState.setStateShallow(pendingState));
    });
    var allGroupContexts = React.useMemo(function() {
      var _stateRef_current_group_listeners, _stateRef_current_group;
      if (!groupName || props.passThrough) return groupContextParent;
      var listeners2 = /* @__PURE__ */ new Set();
      return (_stateRef_current_group = stateRef.current.group) === null || _stateRef_current_group === void 0 || (_stateRef_current_group_listeners = _stateRef_current_group.listeners) === null || _stateRef_current_group_listeners === void 0 || _stateRef_current_group_listeners.clear(), stateRef.current.group = {
        listeners: listeners2,
        emit(state2) {
          listeners2.forEach(function(l) {
            return l(state2);
          });
        },
        subscribe(cb) {
          return listeners2.add(cb), listeners2.size === 1 && setStateShallow({
            hasDynGroupChildren: true
          }), function() {
            listeners2.delete(cb), listeners2.size === 0 && setStateShallow({
              hasDynGroupChildren: false
            });
          };
        }
      }, __spreadProps(__spreadValues({}, groupContextParent), {
        [groupName]: {
          state: {
            pseudo: defaultComponentStateMounted
          },
          subscribe: function(listener) {
            var _stateRef_current_group2, dispose2 = (_stateRef_current_group2 = stateRef.current.group) === null || _stateRef_current_group2 === void 0 ? void 0 : _stateRef_current_group2.subscribe(listener);
            return function() {
              dispose2 == null ? void 0 : dispose2();
            };
          }
        }
      });
    }, [stateRef, groupName, groupContextParent]), setStateShallow = componentState.setStateShallow;
    var isTaggable = !Component || typeof Component == "string", tagProp = props.tag, element = Component, BaseTextComponent = BaseText || element || "span", BaseViewComponent = BaseView || element || "div", elementType = isText ? BaseTextComponent : BaseViewComponent;
    animationDriver && isAnimated && // this should really be behind another prop as it's not really related to
    // "needsWebStyles" basically with motion we just animate a plain div, but
    // we still have animated.View/Text for Sheet which wants to control
    // things declaratively
    !animationDriver.needsWebStyles && (elementType = animationDriver[isText ? "Text" : "View"] || elementType);
    var disableTheme = isHOC;
    props.themeShallow && (stateRef.current.themeShallow = true);
    var themeStateProps = {
      componentName: componentName2,
      disable: disableTheme,
      shallow: stateRef.current.themeShallow,
      debug: debugProp
    };
    if ("themeInverse" in props && (themeStateProps.inverse = props.themeInverse), "theme" in props && (themeStateProps.name = props.theme), typeof stateRef.current.isListeningToTheme == "boolean" && (themeStateProps.needsUpdate = function() {
      return !!stateRef.current.isListeningToTheme;
    }), themeStateProps.deopt = willBeAnimated, false) ;
    var [theme, themeState] = useThemeWithState(themeStateProps);
    elementType = Component || elementType;
    var mediaState = useMedia(componentContext);
    setDidGetVariableValue(false);
    var resolveValues = (
      // if HOC + mounted + has animation prop, resolve as value so it passes non-variable to child
      isAnimated && !supportsCSS || isHOC && state.unmounted == false && hasAnimationProp ? "value" : "auto"
    ), styleProps2 = {
      mediaState,
      noClass,
      resolveValues,
      isExiting,
      isAnimated,
      willBeAnimated,
      styledContext: styledContextValue
    }, themeName = (themeState == null ? void 0 : themeState.name) || "";
    var splitStyles = useSplitStyles(props, staticConfig, theme, themeName, state, styleProps2, null, componentContext, allGroupContexts, elementType, startedUnhydrated, debugProp), isPassthrough = !splitStyles, groupContext = groupName && (allGroupContexts == null ? void 0 : allGroupContexts[groupName]) || null;
    if (!isPassthrough && groupContext && // avoids onLayout if we don't need it
    props.containerType !== "normal") {
      var groupState = groupContext == null ? void 0 : groupContext.state;
      if (groupState && groupState.layout === void 0) {
        var _splitStyles_style, _splitStyles_style1;
        (!((_splitStyles_style = splitStyles.style) === null || _splitStyles_style === void 0) && _splitStyles_style.width || !((_splitStyles_style1 = splitStyles.style) === null || _splitStyles_style1 === void 0) && _splitStyles_style1.height) && (groupState.layout = {
          width: fromPx(splitStyles.style.width),
          height: fromPx(splitStyles.style.height)
        });
      }
    }
    if (!isPassthrough && (hasAnimationProp || groupName) && (animationDriver == null ? void 0 : animationDriver.avoidReRenders)) {
      let updateGroupListeners2 = function() {
        var updatedState = stateRef.current.nextState;
        if (groupContext) {
          var _a2 = updatedState, {
            group,
            hasDynGroupChildren,
            unmounted,
            animation
          } = _a2, childrenGroupState = __objRest(_a2, [
            "group",
            "hasDynGroupChildren",
            "unmounted",
            "animation"
          ]);
          notifyGroupSubscribers(groupContext, stateRef.current.group || null, childrenGroupState);
        }
      };
      var _componentContext, ogSetStateShallow = setStateShallow;
      stateRef.current.updateStyleListener = function() {
        var updatedState = stateRef.current.nextState || state, mediaState2 = stateRef.current.nextMedia, nextStyles = getSplitStyles(props, staticConfig, theme, themeName, updatedState, mediaState2 ? __spreadProps(__spreadValues({}, styleProps2), {
          mediaState: mediaState2
        }) : styleProps2, null, componentContext, allGroupContexts, elementType, startedUnhydrated, debugProp), useStyleListener = stateRef.current.useStyleListener;
        useStyleListener == null ? void 0 : useStyleListener((nextStyles == null ? void 0 : nextStyles.style) || {});
      }, (_componentContext = componentContext).mediaEmit || (_componentContext.mediaEmit = function(next) {
        var _stateRef_current_updateStyleListener, _stateRef_current;
        stateRef.current.nextMedia = next, (_stateRef_current_updateStyleListener = (_stateRef_current = stateRef.current).updateStyleListener) === null || _stateRef_current_updateStyleListener === void 0 || _stateRef_current_updateStyleListener.call(_stateRef_current);
      }), stateRef.current.setStateShallow = function(nextOrGetNext) {
        var prev = stateRef.current.nextState || state, next = typeof nextOrGetNext == "function" ? nextOrGetNext(prev) : nextOrGetNext;
        if (!(next === prev || isEqualShallow(prev, next))) {
          var canAvoidReRender = Object.keys(next).every(function(key2) {
            return avoidReRenderKeys.has(key2);
          }), updatedState = __spreadValues(__spreadValues({}, prev), next);
          if (stateRef.current.nextState = updatedState, canAvoidReRender) {
            var _stateRef_current_updateStyleListener, _stateRef_current;
            updateGroupListeners2(), (_stateRef_current_updateStyleListener = (_stateRef_current = stateRef.current).updateStyleListener) === null || _stateRef_current_updateStyleListener === void 0 || _stateRef_current_updateStyleListener.call(_stateRef_current);
          } else ogSetStateShallow(next);
        }
      }, setStateShallow = function(state2) {
        var _stateRef_current_setStateShallow, _stateRef_current;
        (_stateRef_current_setStateShallow = (_stateRef_current = stateRef.current).setStateShallow) === null || _stateRef_current_setStateShallow === void 0 || _stateRef_current_setStateShallow.call(_stateRef_current, state2);
      };
    }
    if (splitStyles) {
      if (props.group && props.untilMeasured === "hide" && !stateRef.current.hasMeasured) {
        var _splitStyles;
        (_splitStyles = splitStyles).style || (_splitStyles.style = {}), splitStyles.style.opacity = 0;
      }
      splitStyles.dynamicThemeAccess != null && (stateRef.current.isListeningToTheme = splitStyles.dynamicThemeAccess);
    }
    var hasRuntimeMediaKeys = (splitStyles == null ? void 0 : splitStyles.hasMedia) && splitStyles.hasMedia !== true, shouldListenForMedia = didGetVariableValue() || hasRuntimeMediaKeys || noClass && (splitStyles == null ? void 0 : splitStyles.hasMedia) === true, mediaListeningKeys = hasRuntimeMediaKeys ? splitStyles.hasMedia : null;
    setMediaShouldUpdate(componentContext, shouldListenForMedia, mediaListeningKeys);
    var {
      viewProps: viewPropsIn,
      pseudos,
      style: splitStylesStyle,
      classNames,
      space,
      pseudoGroups,
      mediaGroups
    } = splitStyles || {}, propsWithAnimation = props, _a = viewPropsIn || {}, {
      asChild,
      children,
      themeShallow,
      spaceDirection: _spaceDirection,
      onPress,
      onLongPress,
      onPressIn,
      onPressOut,
      onHoverIn,
      onHoverOut,
      onMouseUp,
      onMouseDown,
      onMouseEnter,
      onMouseLeave,
      onFocus,
      onBlur,
      separator,
      passThrough: passThrough,
      forceStyle: _forceStyle,
      onClick: onClick,
      theme: _themeProp
    } = _a, nonTamaguiProps = __objRest(_a, [
      "asChild",
      "children",
      "themeShallow",
      "spaceDirection",
      "onPress",
      "onLongPress",
      "onPressIn",
      "onPressOut",
      "onHoverIn",
      "onHoverOut",
      "onMouseUp",
      "onMouseDown",
      "onMouseEnter",
      "onMouseLeave",
      "onFocus",
      "onBlur",
      "separator",
      // ignore from here on out
      "passThrough",
      "forceStyle",
      // @ts-ignore  for next/link compat etc
      "onClick",
      "theme"
    ]), viewProps = nonTamaguiProps;
    !isTaggable && props.forceStyle && (viewProps.forceStyle = props.forceStyle), isHOC && (typeof _themeProp < "u" && (viewProps.theme = _themeProp), typeof passThrough < "u" && (viewProps.passThrough = passThrough)), tagProp && elementType.acceptTagProp && (viewProps.tag = tagProp);
    var animationStyles, shouldUseAnimation = (
      // if it supports css vars we run it on server too to get matching initial style
      (supportsCSS ? willBeAnimatedClient : willBeAnimated) && useAnimations && !isHOC
    ), animatedRef;
    if (shouldUseAnimation) {
      var useStyleEmitter = (animationDriver == null ? void 0 : animationDriver.avoidReRenders) ? function(listener) {
        stateRef.current.useStyleListener = listener;
      } : void 0, animations = useAnimations({
        props: propsWithAnimation,
        // if hydrating, send empty style
        style: splitStylesStyle || {},
        // @ts-ignore
        styleState: splitStyles,
        useStyleEmitter,
        presence,
        componentState: state,
        styleProps: styleProps2,
        theme,
        pseudos: pseudos || null,
        staticConfig,
        stateRef
      });
      animations && (animations.ref && (animatedRef = animations.ref), isHydrated && animations && (animationStyles = animations.style, viewProps.style = animationStyles, animations.className && (viewProps.className = `${state.unmounted === "should-enter" ? "t_unmounted " : ""}${viewProps.className || ""} ${animations.className}`)));
    }
    !isPassthrough && groupContext && // avoids onLayout if we don't need it
    props.containerType !== "normal" && (nonTamaguiProps.onLayout = composeEventHandlers(nonTamaguiProps.onLayout, function(e2) {
      var _stateRef_current_group, layout = e2.nativeEvent.layout;
      groupContext.state.layout = layout, (_stateRef_current_group = stateRef.current.group) === null || _stateRef_current_group === void 0 || _stateRef_current_group.emit({
        layout
      }), !stateRef.current.hasMeasured && props.untilMeasured === "hide" && setState(function(prev) {
        return __spreadValues({}, prev);
      }), stateRef.current.hasMeasured = true;
    })), viewProps = ((_hooks_usePropsTransform = hooks.usePropsTransform) === null || _hooks_usePropsTransform === void 0 ? void 0 : _hooks_usePropsTransform.call(hooks, elementType, nonTamaguiProps, stateRef, stateRef.current.willHydrate)) || nonTamaguiProps, stateRef.current.composedRef || (stateRef.current.composedRef = composeRefs(function(x) {
      return stateRef.current.host = x;
    }, forwardedRef, setElementProps, animatedRef)), viewProps.ref = stateRef.current.composedRef;
    var unPress = function() {
      setStateShallow({
        press: false,
        pressIn: false
      });
    };
    useIsomorphicLayoutEffect(function() {
      if (state.unmounted === true && hasEnterStyle) {
        setStateShallow({
          unmounted: "should-enter"
        });
        return;
      }
      var tm;
      if (state.unmounted) {
        if ((animationDriver == null ? void 0 : animationDriver.supportsCSS) || isAndroid) return tm = setTimeout(function() {
          setStateShallow({
            unmounted: false
          });
        }), function() {
          return clearTimeout(tm);
        };
        setStateShallow({
          unmounted: false
        });
        return;
      }
      return function() {
        componentSetStates.delete(setState);
      };
    }, [state.unmounted, disabled]), useIsomorphicLayoutEffect(function() {
      if (!disabled && !(!pseudoGroups && !mediaGroups) && allGroupContexts) return subscribeToContextGroup({
        groupContext: allGroupContexts,
        setStateShallow,
        mediaGroups,
        pseudoGroups
      });
    }, [allGroupContexts, disabled, pseudoGroups ? objectIdentityKey(pseudoGroups) : 0, mediaGroups ? objectIdentityKey(mediaGroups) : 0]);
    var groupEmitter = stateRef.current.group;
    useIsomorphicLayoutEffect(function() {
      !groupContext || !groupEmitter || notifyGroupSubscribers(groupContext, groupEmitter, state);
    }, [groupContext, groupEmitter, state]);
    var runtimePressStyle = !disabled && noClass && (pseudos == null ? void 0 : pseudos.pressStyle), runtimeFocusStyle = !disabled && noClass && (pseudos == null ? void 0 : pseudos.focusStyle), runtimeFocusVisibleStyle = !disabled && noClass && (pseudos == null ? void 0 : pseudos.focusVisibleStyle), attachFocus = !!(runtimePressStyle || runtimeFocusStyle || runtimeFocusVisibleStyle || onFocus || onBlur || componentContext.setParentFocusState), hasDynamicGroupChildren = !!(groupName && state.hasDynGroupChildren), attachPress = !!(hasDynamicGroupChildren || runtimePressStyle || onPress || onPressOut || onPressIn || onMouseDown || onMouseUp || onLongPress || onClick || (pseudos == null ? void 0 : pseudos.focusVisibleStyle)), runtimeHoverStyle = !disabled && noClass && (pseudos == null ? void 0 : pseudos.hoverStyle), needsHoverState = !!(hasDynamicGroupChildren || runtimeHoverStyle), attachHover = isWeb, shouldAttach = !disabled && !props.asChild && !!(attachFocus || attachPress || attachHover || runtimePressStyle || runtimeHoverStyle || runtimeFocusStyle), needsPressState = !!(hasDynamicGroupChildren || runtimePressStyle);
    var events = shouldAttach ? __spreadValues(__spreadValues(__spreadProps(__spreadValues({
      onPressOut: attachPress ? function(e2) {
        unPress(), onPressOut == null ? void 0 : onPressOut(e2), onMouseUp == null ? void 0 : onMouseUp(e2);
      } : void 0
    }, attachPress && {
      onMouseEnter: function(e2) {
        var next = {};
        needsHoverState && (next.hover = true), needsPressState && state.pressIn && (next.press = true), setStateShallow(next), onHoverIn == null ? void 0 : onHoverIn(e2), onMouseEnter == null ? void 0 : onMouseEnter(e2);
      },
      onMouseLeave: function(e2) {
        var next = {};
        needsHoverState && (next.hover = false), needsPressState && (next.press = false, next.pressIn = false), setStateShallow(next), onHoverOut == null ? void 0 : onHoverOut(e2), onMouseLeave == null ? void 0 : onMouseLeave(e2);
      }
    }), {
      onPressIn: attachPress ? function(e2) {
        needsPressState && setStateShallow({
          press: true,
          pressIn: true
        }), onPressIn == null ? void 0 : onPressIn(e2), onMouseDown == null ? void 0 : onMouseDown(e2);
      } : void 0,
      onPress: attachPress ? function(e2) {
        unPress(), onPress == null ? void 0 : onPress(e2);
      } : void 0
    }), attachPress && onLongPress && {
      onLongPress: function(e2) {
        unPress(), onLongPress == null ? void 0 : onLongPress(e2);
      }
    }), attachFocus && {
      onFocus: function(e2) {
        var next = {};
        componentContext.setParentFocusState && (next.focusWithin = true), (pseudos == null ? void 0 : pseudos.focusVisibleStyle) && lastInteractionWasKeyboard.value ? next.focusVisible = true : next.focus = true, setStateShallow(next), onFocus == null ? void 0 : onFocus(e2);
      },
      onBlur: function(e2) {
        componentContext.setParentFocusState && componentContext.setParentFocusState({
          focusWithin: false
        }), setStateShallow({
          focus: false,
          focusVisible: false,
          focusWithin: false
        }), onBlur == null ? void 0 : onBlur(e2);
      }
    }) : null;
    if (events && !asChild) {
      var _viewProps_focusable;
      Object.assign(events, {
        cancelable: !viewProps.rejectResponderTermination,
        disabled,
        hitSlop: viewProps.hitSlop,
        delayLongPress: viewProps.delayLongPress,
        delayPressIn: viewProps.delayPressIn,
        delayPressOut: viewProps.delayPressOut,
        focusable: (_viewProps_focusable = viewProps.focusable) !== null && _viewProps_focusable !== void 0 ? _viewProps_focusable : true,
        minPressDuration: 0
      });
    }
    (_hooks_useEvents = hooks.useEvents) === null || _hooks_useEvents === void 0 || _hooks_useEvents.call(hooks, viewProps, events, splitStyles, setStateShallow, staticConfig);
    var direction = props.spaceDirection || "both";
    var content = !children || asChild || !splitStyles ? children : spacedChildren({
      separator,
      children,
      space,
      direction,
      isZStack
    });
    if (asChild) if (elementType = Slot, 0) ;
    else Object.assign(viewProps, {
      onPress,
      onLongPress
    });
    isPassthrough && (content = propsIn.children, elementType = BaseViewComponent, viewProps = {
      style: {
        display: "contents"
      }
    });
    var useChildrenResult;
    hooks.useChildren && (useChildrenResult = hooks.useChildren(elementType, content, viewProps)), useChildrenResult ? content = useChildrenResult : content = /* @__PURE__ */ React.createElement(elementType, viewProps, content);
    var ResetPresence2 = config == null || (_config_animations = config.animations) === null || _config_animations === void 0 ? void 0 : _config_animations.ResetPresence, needsReset = !!// not when passing down to child
    (!asChild && // not when passThrough
    splitStyles && // not when HOC
    !isHOC && ResetPresence2 && willBeAnimated && (hasEnterStyle || presenceState)), hasEverReset = stateRef.current.hasEverResetPresence;
    needsReset && !hasEverReset && (stateRef.current.hasEverResetPresence = true);
    var renderReset = needsReset || hasEverReset;
    if (renderReset && ResetPresence2 && (content = /* @__PURE__ */ jsxRuntimeExports.jsx(ResetPresence2, {
      disabled: !needsReset,
      children: content
    })), "focusWithinStyle" in propsIn && (content = /* @__PURE__ */ jsxRuntimeExports.jsx(ComponentContext.Provider, __spreadProps(__spreadValues({}, componentContext), {
      setParentFocusState: setStateShallow,
      children: content
    }))), "group" in props && (content = /* @__PURE__ */ jsxRuntimeExports.jsx(GroupContext.Provider, {
      value: allGroupContexts,
      children: content
    })), content = disableTheme || !splitStyles ? content : getThemedChildren(themeState, content, themeStateProps, false, stateRef), overriddenContextProps) {
      var Provider = staticConfig.context.Provider;
      for (var key in styledContextValue) key in overriddenContextProps || (overriddenContextProps[key] = styledContextValue[key]);
      debugProp && console.info("overriddenContextProps", overriddenContextProps), content = /* @__PURE__ */ jsxRuntimeExports.jsx(Provider, __spreadProps(__spreadValues({
        __disableMergeDefaultValues: true
      }, overriddenContextProps), {
        children: content
      }));
    }
    return content;
  });
  function notifyGroupSubscribers(groupContext, groupEmitter, pseudo) {
    if (!(!groupContext || !groupEmitter)) {
      var nextState = __spreadProps(__spreadValues({}, groupContext.state), {
        pseudo
      });
      groupEmitter.emit(nextState), groupContext.state = nextState;
    }
  }
  staticConfig.componentName && (component.displayName = staticConfig.componentName);
  var res = component;
  (process.env.TAMAGUI_FORCE_MEMO || staticConfig.memo) && (res = /* @__PURE__ */ React.memo(res)), res.staticConfig = staticConfig;
  function extendStyledConfig(extended) {
    return __spreadProps(__spreadValues(__spreadValues({}, staticConfig), extended), {
      neverFlatten: true,
      isHOC: true,
      isStyledHOC: false
    });
  }
  function extractable(Component2, extended) {
    return Component2.staticConfig = extendStyledConfig(extended), Component2.styleable = styleable, Component2;
  }
  function styleable(Component2, options) {
    var _Component_render, skipForwardRef = IS_REACT_19 && typeof Component2 == "function" && Component2.length === 1 || ((_Component_render = Component2.render) === null || _Component_render === void 0 ? void 0 : _Component_render.length) === 2, out = skipForwardRef ? Component2 : /* @__PURE__ */ React.forwardRef(Component2), extendedConfig = extendStyledConfig(options == null ? void 0 : options.staticConfig);
    return out = (options == null ? void 0 : options.disableTheme) ? out : themeable(out, extendedConfig, true), (extendedConfig.memo || process.env.TAMAGUI_MEMOIZE_STYLEABLE) && (out = /* @__PURE__ */ React.memo(out)), out.staticConfig = extendedConfig, out.styleable = styleable, out;
  }
  return res.extractable = extractable, res.styleable = styleable, res;
}
function Unspaced(props) {
  return props.children;
}
Unspaced.isUnspaced = true;
var getSpacerSize = function(size, param) {
  var {
    tokens
  } = param;
  size = size === false ? 0 : size === true ? "$true" : size;
  var _tokens_space_size, sizePx = (_tokens_space_size = tokens.space[size]) !== null && _tokens_space_size !== void 0 ? _tokens_space_size : size;
  return {
    width: sizePx,
    height: sizePx,
    minWidth: sizePx,
    minHeight: sizePx
  };
}, Spacer = createComponent({
  acceptsClassName: true,
  memo: true,
  componentName: "Spacer",
  validStyles,
  defaultProps: __spreadProps(__spreadValues({}, stackDefaultStyles), {
    // avoid nesting issues
    tag: "span",
    size: true,
    pointerEvents: "none"
  }),
  variants: {
    size: {
      "...": getSpacerSize
    },
    flex: {
      true: {
        flexGrow: 1
      }
    },
    direction: {
      horizontal: {
        height: 0,
        minHeight: 0
      },
      vertical: {
        width: 0,
        minWidth: 0
      },
      both: {}
    }
  }
});
function spacedChildren(props) {
  var _childrenList__type, _childrenList_, {
    isZStack,
    children,
    space,
    direction,
    spaceFlex,
    separator,
    ensureKeys
  } = props, hasSpace = !!(space || spaceFlex), hasSeparator = separator != null, areChildrenArray = Array.isArray(children);
  if (!ensureKeys && !(hasSpace || hasSeparator || isZStack)) return children;
  var childrenList = areChildrenArray ? children : React.Children.toArray(children), len = childrenList.length;
  if (len <= 1 && !isZStack && !(!((_childrenList_ = childrenList[0]) === null || _childrenList_ === void 0 || (_childrenList__type = _childrenList_.type) === null || _childrenList__type === void 0) && _childrenList__type.shouldForwardSpace)) return children;
  var final = [], _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
  try {
    for (var _iterator = childrenList.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var [index2, child] = _step.value, _child_type, isEmpty = child == null || Array.isArray(child) && child.length === 0;
      if (!isEmpty && /* @__PURE__ */ React.isValidElement(child) && !((_child_type = child.type) === null || _child_type === void 0) && _child_type.shouldForwardSpace && (child = /* @__PURE__ */ React.cloneElement(child, {
        // @ts-expect-error we explicitly know with shouldForwardSpace
        space,
        spaceFlex,
        separator,
        key: child.key
      })), isEmpty || !child || child.key && !isZStack ? final.push(child) : final.push(/* @__PURE__ */ jsxRuntimeExports.jsx(React.Fragment, {
        children: isZStack ? /* @__PURE__ */ jsxRuntimeExports.jsx(AbsoluteFill, {
          children: child
        }) : child
      }, `${index2}0t`)), !(isUnspaced(child) && index2 === 0) && !isZStack) {
        var next = childrenList[index2 + 1];
        next && !isEmpty && !isUnspaced(next) && (separator ? (hasSpace && final.push(createSpacer({
          key: `_${index2}_00t`,
          direction,
          space,
          spaceFlex
        })), final.push(/* @__PURE__ */ jsxRuntimeExports.jsx(React.Fragment, {
          children: separator
        }, `${index2}03t`)), hasSpace && final.push(createSpacer({
          key: `_${index2}01t`,
          direction,
          space,
          spaceFlex
        }))) : final.push(createSpacer({
          key: `_${index2}02t`,
          direction,
          space,
          spaceFlex
        })));
      }
    }
  } catch (err) {
    _didIteratorError = true, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError) throw _iteratorError;
    }
  }
  return final;
}
function createSpacer(param) {
  var {
    key,
    direction,
    space,
    spaceFlex
  } = param;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, __spreadValues({
    size: space,
    direction
  }, typeof spaceFlex < "u" && {
    flex: spaceFlex === true ? 1 : spaceFlex === false ? 0 : spaceFlex
  }), key);
}
function isUnspaced(child) {
  var t2 = child == null ? void 0 : child.type;
  return (t2 == null ? void 0 : t2.isVisuallyHidden) || (t2 == null ? void 0 : t2.isUnspaced);
}
var AbsoluteFill = createComponent({
  defaultProps: __spreadProps(__spreadValues({}, stackDefaultStyles), {
    flexDirection: "column",
    position: "absolute",
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    pointerEvents: "box-none"
  })
}), fromPx = function(val) {
  return typeof val == "number" ? val : typeof val == "string" ? +val.replace("px", "") : 0;
};
function getExpandedShorthand(propKey, props) {
  var shorthands = getConfig().inverseShorthands, _props_propKey;
  return (_props_propKey = props[propKey]) !== null && _props_propKey !== void 0 ? _props_propKey : props[shorthands[propKey]];
}
var inverseShorthands = null, getShorthandValue = function(props, key) {
  inverseShorthands || (inverseShorthands = getConfig().inverseShorthands);
  var _props_key;
  return (_props_key = props[key]) !== null && _props_key !== void 0 ? _props_key : inverseShorthands ? props[inverseShorthands[key]] : void 0;
};
function isTamaguiComponent(comp, name) {
  var config = comp == null ? void 0 : comp.staticConfig;
  return !!(config && (!name || name === config.componentName));
}
var isTamaguiElement = function(child, name) {
  return /* @__PURE__ */ React.isValidElement(child) && isTamaguiComponent(child.type, name);
};
var themesRaw = {};
function proxyThemesToParents(dedupedThemes) {
  var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
  try {
    for (var _iterator = dedupedThemes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var {
        names,
        theme
      } = _step.value, _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = void 0;
      try {
        for (var _iterator1 = names[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
          var name = _step1.value;
          themesRaw[name] = theme;
        }
      } catch (err) {
        _didIteratorError1 = true, _iteratorError1 = err;
      } finally {
        try {
          !_iteratorNormalCompletion1 && _iterator1.return != null && _iterator1.return();
        } finally {
          if (_didIteratorError1) throw _iteratorError1;
        }
      }
    }
  } catch (err) {
    _didIteratorError = true, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError) throw _iteratorError;
    }
  }
  var themes2 = {}, _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = void 0;
  try {
    for (var _iterator2 = dedupedThemes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var {
        names: names1,
        theme: theme1
      } = _step2.value, _iteratorNormalCompletion3 = true, _didIteratorError3 = false, _iteratorError3 = void 0;
      try {
        for (var _iterator3 = names1[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var themeName = _step3.value, proxiedTheme = proxyThemeToParents(themeName, theme1);
          themes2[themeName] = proxiedTheme;
        }
      } catch (err) {
        _didIteratorError3 = true, _iteratorError3 = err;
      } finally {
        try {
          !_iteratorNormalCompletion3 && _iterator3.return != null && _iterator3.return();
        } finally {
          if (_didIteratorError3) throw _iteratorError3;
        }
      }
    }
  } catch (err) {
    _didIteratorError2 = true, _iteratorError2 = err;
  } finally {
    try {
      !_iteratorNormalCompletion2 && _iterator2.return != null && _iterator2.return();
    } finally {
      if (_didIteratorError2) throw _iteratorError2;
    }
  }
  return themes2;
}
function proxyThemeToParents(themeName, theme) {
  var out = {}, cur = [], parents = themeName.split("_").slice(0, -1).map(function(part) {
    return cur.push(part), cur.join("_");
  }), _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
  try {
    for (var _iterator = parents[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var parent = _step.value;
      Object.assign(out, themesRaw[parent]);
    }
  } catch (err) {
    _didIteratorError = true, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError) throw _iteratorError;
    }
  }
  return Object.assign(out, theme), out;
}
function ensureThemeVariable(theme, key) {
  var val = theme[key];
  isVariable(val) ? val.name !== key && (theme[key] = createVariable({
    key: val.name,
    name: key,
    val: val.val
  })) : theme[key] = createVariable({
    key,
    name: key,
    val
  });
}
var fontWeights = ["100", "200", "300", "400", "500", "600", "700", "800", "900"], processSection = function(section, keys, defaultValue2) {
  if (typeof section == "string") return section;
  var sectionKeys = Object.keys(section), fillValue = section[sectionKeys[0]];
  return Object.fromEntries([.../* @__PURE__ */ new Set([...keys, ...sectionKeys])].map(function(key) {
    var _section_key, _ref, value = (_ref = (_section_key = section[key]) !== null && _section_key !== void 0 ? _section_key : defaultValue2) !== null && _ref !== void 0 ? _ref : fillValue;
    return fillValue = value, defaultValue2 = value, [key, value];
  }));
}, createFont = function(font) {
  var sizeKeys = Object.keys(font.size || {}), processedFont = Object.fromEntries(Object.entries(font).map(function(param) {
    var [key, section] = param;
    return [key, processSection(section, key === "face" ? fontWeights : sizeKeys, key === "face" ? {
      normal: font.family
    } : void 0)];
  }));
  return Object.freeze(processedFont);
};
function createShorthands(shorthands) {
  return Object.freeze(shorthands);
}
function _type_of$3(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var cache$1 = /* @__PURE__ */ new WeakMap(), createVariables = function(tokens) {
  var parentPath = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  if (cache$1.has(tokens)) return tokens;
  var res = {};
  for (var keyIn in tokens) {
    var val = tokens[keyIn], isPrefixed = keyIn[0] === "$", keyWithPrefix = isPrefixed ? keyIn : `$${keyIn}`, key = isPrefixed ? keyWithPrefix.slice(1) : keyIn;
    if (isVariable(val)) {
      res[key] = val;
      continue;
    }
    var niceKey = simpleHash(key, 1e3), name = parentPath && parentPath !== "t-color" ? `${parentPath}-${niceKey}` : `c-${niceKey}`;
    if (val && (typeof val > "u" ? "undefined" : _type_of$3(val)) === "object" && "needsPx" in val && "val" in val) {
      var finalValue = createVariable({
        val: val.val,
        name,
        key: keyWithPrefix
      });
      res[key] = finalValue;
      continue;
    }
    if (val && (typeof val > "u" ? "undefined" : _type_of$3(val)) === "object") {
      res[key] = createVariables(tokens[key], name, false);
      continue;
    }
    var finalValue1 = isVariable(val) ? val : createVariable({
      val,
      name,
      key: keyWithPrefix
    });
    res[key] = finalValue1;
  }
  return cache$1.set(res, true), res;
};
function insertFont(name, fontIn) {
  var font = createFont(fontIn), tokened = createVariables(font, name), parsed = parseFont(tokened);
  return setConfigFont(name, tokened, parsed), parsed;
}
function parseFont(definition) {
  var parsed = {};
  for (var attrKey in definition) {
    var attr = definition[attrKey];
    if (attrKey === "family" || attrKey === "face") parsed[attrKey] = attr;
    else {
      parsed[attrKey] = {};
      for (var key in attr) {
        var _val_val, val = attr[key];
        ((_val_val = val.val) === null || _val_val === void 0 ? void 0 : _val_val[0]) === "$" && (val = val.val), parsed[attrKey][`$${key}`] = val;
      }
    }
  }
  return parsed;
}
function createTamagui$2(configIn) {
  var _configIn_settings;
  var tokensParsed = {}, tokens = createVariables(configIn.tokens || {});
  if (configIn.tokens) {
    var tokensMerged2 = {};
    for (var cat in tokens) {
      tokensParsed[cat] = {}, tokensMerged2[cat] = {};
      var tokenCat = tokens[cat];
      for (var key in tokenCat) {
        var val = tokenCat[key], prefixedKey = `$${key}`;
        tokensParsed[cat][prefixedKey] = val, tokensMerged2[cat][prefixedKey] = val, tokensMerged2[cat][key] = val;
      }
    }
    setTokens(tokensMerged2);
  }
  var foundThemes;
  if (configIn.themes) {
    var noThemes = Object.keys(configIn.themes).length === 0;
    noThemes && (foundThemes = scanAllSheets());
  }
  var fontSizeTokens = null, fontsParsed;
  if (configIn.fonts) {
    var fontTokens = Object.fromEntries(Object.entries(configIn.fonts).map(function(param) {
      var [k, v] = param;
      return [k, createVariables(v, "f", true)];
    }));
    fontsParsed = (function() {
      var res = {};
      for (var familyName in fontTokens) {
        var font = fontTokens[familyName], fontParsed = parseFont(font);
        res[`$${familyName}`] = fontParsed, !fontSizeTokens && fontParsed.size && (fontSizeTokens = new Set(Object.keys(fontParsed.size)));
      }
      return res;
    })();
  }
  var specificTokens = {}, themeConfig = (function() {
    var cssRuleSets = [];
    for (var key2 in tokens) for (var skey in tokens[key2]) {
      var variable = tokens[key2][skey];
      if (specificTokens[`$${key2}.${skey}`] = variable, false) ;
    }
    var themesIn = configIn.themes, dedupedThemes = foundThemes != null ? foundThemes : getThemesDeduped(themesIn, tokens.color), themes2 = proxyThemesToParents(dedupedThemes);
    return {
      themes: themes2,
      cssRuleSets,
      getThemeRulesSets() {
        var themeRuleSets = [];
        return themeRuleSets;
      }
    };
  })(), userShorthands = configIn.shorthands || {}, shorthands = __spreadValues(__spreadValues({}, builtinShorthands), userShorthands), getCSS = function() {
    return "";
  }, getNewCSS = function(opts) {
    return getCSS(__spreadValues({}, opts));
  }, _configIn_settings_defaultFont, defaultFontSetting = (_configIn_settings_defaultFont = (_configIn_settings = configIn.settings) === null || _configIn_settings === void 0 ? void 0 : _configIn_settings.defaultFont) !== null && _configIn_settings_defaultFont !== void 0 ? _configIn_settings_defaultFont : configIn.defaultFont, defaultFont = (function() {
    var val2 = defaultFontSetting;
    return (val2 == null ? void 0 : val2[0]) === "$" && (val2 = val2.slice(1)), val2;
  })(), defaultFontToken = defaultFont ? `$${defaultFont}` : "", unset = __spreadValues({}, configIn.unset);
  !unset.fontFamily && defaultFont && (unset.fontFamily = defaultFontToken);
  var config = __spreadProps(__spreadValues({
    fonts: {},
    onlyAllowShorthands: false,
    fontLanguages: [],
    animations: {},
    media: {}
  }, configIn), {
    unset,
    settings: __spreadValues({
      // move deprecated settings here so we can reference them all using `getSetting`
      // TODO remove this on v2
      disableSSR: configIn.disableSSR,
      defaultFont: configIn.defaultFont,
      disableRootThemeClass: configIn.disableRootThemeClass,
      onlyAllowShorthands: configIn.onlyAllowShorthands,
      mediaQueryDefaultActive: configIn.mediaQueryDefaultActive,
      themeClassNameOnRoot: configIn.themeClassNameOnRoot,
      cssStyleSeparator: configIn.cssStyleSeparator,
      webContainerType: "inline-size"
    }, configIn.settings),
    tokens,
    // vite made this into a function if it wasn't set
    shorthands,
    userShorthands,
    inverseShorthands: shorthands ? Object.fromEntries(Object.entries(shorthands).map(function(param) {
      var [k, v] = param;
      return [v, k];
    })) : {},
    themes: themeConfig.themes,
    fontsParsed: fontsParsed || {},
    themeConfig,
    tokensParsed,
    parsed: true,
    getNewCSS,
    getCSS,
    defaultFont,
    fontSizeTokens: fontSizeTokens || /* @__PURE__ */ new Set(),
    specificTokens,
    defaultFontToken
  });
  if (setConfig(config), configureMedia(config), configListeners.size && (configListeners.forEach(function(cb) {
    return cb(config);
  }), configListeners.clear()), false) ;
  return config;
}
function getThemesDeduped(themes2, colorTokens) {
  var dedupedThemes = [], existing = /* @__PURE__ */ new Map();
  for (var themeName in themes2) {
    var darkOrLightSpecificPrefix = themeName.startsWith("dark") ? "dark" : themeName.startsWith("light") ? "light" : "", rawTheme = themes2[themeName], key = darkOrLightSpecificPrefix + JSON.stringify(rawTheme);
    if (existing.has(key)) {
      var e2 = existing.get(key);
      e2.names.push(themeName);
      continue;
    }
    var theme = __spreadValues({}, rawTheme);
    colorTokens && Object.assign(theme, colorTokens);
    for (var key1 in theme) ensureThemeVariable(theme, key1);
    var deduped = {
      names: [themeName],
      theme
    };
    dedupedThemes.push(deduped), existing.set(key, deduped);
  }
  return dedupedThemes;
}
var builtinShorthands = {
  fd: "flexDirection",
  fb: "flexBasis",
  bblr: "borderBottomLeftRadius",
  bbrr: "borderBottomRightRadius",
  fwr: "flexWrap",
  col: "color",
  ff: "fontFamily",
  fst: "fontStyle",
  tr: "transform",
  tt: "textTransform",
  td: "textDecorationLine",
  va: "verticalAlign",
  ws: "whiteSpace",
  wb: "wordBreak",
  ww: "wordWrap",
  brc: "borderRightColor",
  brw: "borderRightWidth",
  bs: "borderStyle",
  btc: "borderTopColor",
  btlr: "borderTopLeftRadius",
  btrr: "borderTopRightRadius",
  btw: "borderTopWidth",
  bw: "borderWidth",
  o: "opacity",
  cur: "cursor",
  pe: "pointerEvents",
  ov: "overflow",
  pos: "position",
  dsp: "display",
  fw: "fontWeight",
  fs: "fontSize",
  ls: "letterSpacing",
  lh: "lineHeight",
  bxs: "boxSizing",
  bxsh: "boxShadow",
  ox: "overflowX",
  oy: "overflowY"
};
var createTheme = function(theme) {
  return theme;
};
function createTokens(tokens) {
  var _process_env_TAMAGUI_TOKEN_PREFIX;
  return createVariables(tokens, (_process_env_TAMAGUI_TOKEN_PREFIX = process.env.TAMAGUI_TOKEN_PREFIX) !== null && _process_env_TAMAGUI_TOKEN_PREFIX !== void 0 ? _process_env_TAMAGUI_TOKEN_PREFIX : "t");
}
function getReactNativeConfig(Component) {
  if (Component) {
    var _Component_propTypes, _Component_propTypes1, _Component_propTypes2;
    return !((_Component_propTypes = Component.propTypes) === null || _Component_propTypes === void 0) && _Component_propTypes.onTextInput || !((_Component_propTypes1 = Component.propTypes) === null || _Component_propTypes1 === void 0) && _Component_propTypes1.onChangeText ? RNConfigs.TextInput : Component.getSizeWithHeaders ? RNConfigs.Image : !((_Component_propTypes2 = Component.propTypes) === null || _Component_propTypes2 === void 0) && _Component_propTypes2.textBreakStrategy ? RNConfigs.Text : RNConfigs.default;
  }
}
var RNConfigs = {
  Image: {
    isReactNative: true,
    inlineProps: /* @__PURE__ */ new Set(["src", "width", "height"])
  },
  Text: {
    isReactNative: true,
    isText: true
  },
  TextInput: {
    isReactNative: true,
    isInput: true,
    isText: true
  },
  default: {
    isReactNative: true
  }
};
function setupReactNative(rnExports) {
}
var mergeVariants = function(parentVariants, ourVariants) {
  var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, variants2 = {};
  for (var key in ourVariants) {
    var parentVariant = parentVariants == null ? void 0 : parentVariants[key], ourVariant = ourVariants[key];
    !parentVariant || typeof ourVariant == "function" ? variants2[key] = ourVariant : parentVariant && !ourVariant ? variants2[key] = parentVariant[key] : level === 0 ? variants2[key] = mergeVariants(parentVariant, ourVariant, level + 1) : variants2[key] = __spreadValues(__spreadValues({}, parentVariant), ourVariant);
  }
  return __spreadValues(__spreadValues({}, parentVariants), variants2);
};
function styled(ComponentIn, options, config) {
  var parentStaticConfig = ComponentIn.staticConfig, isPlainStyledComponent = !!parentStaticConfig && !(parentStaticConfig.isReactNative || parentStaticConfig.isHOC), isNonStyledHOC = (parentStaticConfig == null ? void 0 : parentStaticConfig.isHOC) && !(parentStaticConfig == null ? void 0 : parentStaticConfig.isStyledHOC), Component = isNonStyledHOC || isPlainStyledComponent ? ComponentIn : (parentStaticConfig == null ? void 0 : parentStaticConfig.Component) || ComponentIn, reactNativeConfig = parentStaticConfig ? void 0 : getReactNativeConfig(Component), isReactNative = !!(reactNativeConfig || (config == null ? void 0 : config.isReactNative) || (parentStaticConfig == null ? void 0 : parentStaticConfig.isReactNative)), staticConfigProps = (function() {
    var _a = options || {}, {
      variants: variants2,
      name,
      defaultVariants,
      acceptsClassName: acceptsClassNameProp,
      context: context2
    } = _a, defaultProps2 = __objRest(_a, [
      "variants",
      "name",
      "defaultVariants",
      "acceptsClassName",
      "context"
    ]), parentDefaultVariants, parentDefaultProps;
    if (parentStaticConfig) {
      var avoid = parentStaticConfig.isHOC && !parentStaticConfig.isStyledHOC;
      if (!avoid) {
        var pdp = parentStaticConfig.defaultProps;
        for (var key2 in pdp) {
          var val = pdp[key2];
          parentStaticConfig.defaultVariants && key2 in parentStaticConfig.defaultVariants && (!defaultVariants || !(key2 in defaultVariants)) && (parentDefaultVariants || (parentDefaultVariants = {}), parentDefaultVariants[key2] = val), !(key2 in defaultProps2) && (!defaultVariants || !(key2 in defaultVariants)) && (parentDefaultProps || (parentDefaultProps = {}), parentDefaultProps[key2] = pdp[key2]);
        }
        parentStaticConfig.variants && (variants2 = mergeVariants(parentStaticConfig.variants, variants2));
      }
    }
    (parentDefaultProps || defaultVariants || parentDefaultVariants) && (defaultProps2 = __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, parentDefaultProps), parentDefaultVariants), defaultProps2), defaultVariants)), (parentStaticConfig == null ? void 0 : parentStaticConfig.isHOC) && name && (defaultProps2.componentName = name);
    var isText = !!((config == null ? void 0 : config.isText) || (parentStaticConfig == null ? void 0 : parentStaticConfig.isText)), _config_acceptsClassName, _ref, acceptsClassName = (_ref = (_config_acceptsClassName = config == null ? void 0 : config.acceptsClassName) !== null && _config_acceptsClassName !== void 0 ? _config_acceptsClassName : acceptsClassNameProp) !== null && _ref !== void 0 ? _ref : isPlainStyledComponent || isReactNative || (parentStaticConfig == null ? void 0 : parentStaticConfig.isHOC) && (parentStaticConfig == null ? void 0 : parentStaticConfig.acceptsClassName), conf2 = __spreadProps(__spreadValues(__spreadProps(__spreadValues(__spreadValues(__spreadValues({}, parentStaticConfig), config), !isPlainStyledComponent && {
      Component
    }), {
      // @ts-expect-error
      variants: variants2,
      defaultProps: defaultProps2,
      defaultVariants,
      componentName: name || (parentStaticConfig == null ? void 0 : parentStaticConfig.componentName),
      isReactNative,
      isText,
      acceptsClassName,
      context: context2
    }), reactNativeConfig), {
      isStyledHOC: !!(parentStaticConfig == null ? void 0 : parentStaticConfig.isHOC),
      parentStaticConfig
    });
    return (defaultProps2.children || !acceptsClassName || context2) && (conf2.neverFlatten = true), conf2;
  })(), component = createComponent(staticConfigProps || {});
  for (var key in ComponentIn) key !== "propTypes" && (key in component || (component[key] = ComponentIn[key]));
  return component;
}
var useIsTouchDevice = function() {
  return true;
};
var Stack$1 = createComponent({
  acceptsClassName: true,
  defaultProps: stackDefaultStyles,
  validStyles
});
Stack$1.displayName = "Stack";
function useProps(props, opts) {
  var [propsOut, styleOut] = usePropsAndStyle(props, __spreadProps(__spreadValues({}, opts), {
    noExpand: true,
    noNormalize: true,
    resolveValues: "none"
  }));
  return __spreadValues(__spreadValues({}, propsOut), styleOut);
}
function useStyle(props, opts) {
  return usePropsAndStyle(props, opts)[1] || {};
}
function usePropsAndStyle(props, opts) {
  var _opts_forComponent, _opts_forComponent_staticConfig, staticConfig = (_opts_forComponent_staticConfig = opts == null || (_opts_forComponent = opts.forComponent) === null || _opts_forComponent === void 0 ? void 0 : _opts_forComponent.staticConfig) !== null && _opts_forComponent_staticConfig !== void 0 ? _opts_forComponent_staticConfig : Stack$1.staticConfig, [theme, themeState] = useThemeWithState({
    componentName: staticConfig.componentName,
    name: "theme" in props ? props.theme : void 0,
    inverse: "themeInverse" in props ? props.themeInverse : void 0,
    needsUpdate() {
      return true;
    }
  }), componentContext = React.useContext(ComponentContext), groupContext = React.useContext(GroupContext), {
    state,
    disabled,
    setStateShallow
  } = useComponentState(props, componentContext.animationDriver, staticConfig, getConfig()), mediaStateNow = (opts == null ? void 0 : opts.noMedia) ? (
    // not safe to use mediaState but really marginal to hit this
    exports.mediaState
  ) : useMedia(), splitStyles = useSplitStyles(props, staticConfig, theme, (themeState == null ? void 0 : themeState.name) || "", state, __spreadValues({
    isAnimated: false,
    mediaState: mediaStateNow,
    noSkip: true,
    noMergeStyle: true,
    noClass: true,
    resolveValues: "auto"
  }, opts), null, componentContext, groupContext), {
    mediaGroups,
    pseudoGroups
  } = splitStyles || {};
  return useIsomorphicLayoutEffect(function() {
    if (!disabled) {
      if (state.unmounted) {
        setStateShallow({
          unmounted: false
        });
        return;
      }
      if (groupContext) return subscribeToContextGroup({
        groupContext,
        setStateShallow,
        mediaGroups,
        pseudoGroups
      });
    }
  }, [disabled, groupContext, pseudoGroups ? Object.keys([...pseudoGroups]).join("") : 0, mediaGroups ? Object.keys([...mediaGroups]).join("") : 0]), [(splitStyles == null ? void 0 : splitStyles.viewProps) || {}, (splitStyles == null ? void 0 : splitStyles.style) || {}, theme, exports.mediaState];
}
var forceUpdateState = {
  forceClassName: true,
  deopt: true,
  needsUpdate: function() {
    return true;
  }
}, forceKeys = {
  current: /* @__PURE__ */ new Set([""])
};
function useThemeName() {
  var _useThemeState;
  return ((_useThemeState = useThemeState(forceUpdateState, false, forceKeys)) === null || _useThemeState === void 0 ? void 0 : _useThemeState.name) || "";
}
var Configuration = function(props) {
  var current = React.useContext(ComponentContext), _props_disableSSR;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ClientOnly, {
    enabled: (_props_disableSSR = props.disableSSR) !== null && _props_disableSSR !== void 0 ? _props_disableSSR : current.disableSSR,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ComponentContext.Provider, __spreadValues(__spreadValues({}, current), props))
  });
};
function FontLanguage(param) {
  var _a = param, {
    children
  } = _a, props = __objRest(_a, [
    "children"
  ]), parentProps = React.useContext(ComponentContext), language = React.useMemo(function() {
    return props;
  }, [JSON.stringify(props)]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ComponentContext.Provider, __spreadProps(__spreadValues({}, parentProps), {
    language,
    children
  }));
}
var ThemeProvider = function(props) {
  var _props_disableRootThemeClass, disableRootThemeClass = (_props_disableRootThemeClass = props.disableRootThemeClass) !== null && _props_disableRootThemeClass !== void 0 ? _props_disableRootThemeClass : getSetting("disableRootThemeClass"), _props_themeClassNameOnRoot, themeClassNameOnRoot = (_props_themeClassNameOnRoot = props.themeClassNameOnRoot) !== null && _props_themeClassNameOnRoot !== void 0 ? _props_themeClassNameOnRoot : getSetting("themeClassNameOnRoot");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Theme, {
    className: props.className,
    name: props.defaultTheme,
    // if root class disabled, force class here
    forceClassName: !disableRootThemeClass && !themeClassNameOnRoot,
    // @ts-expect-error
    _isRoot: React.useId,
    children: props.children
  });
};
function TamaguiProvider$2(param) {
  var {
    children,
    disableInjectCSS,
    config,
    className,
    defaultTheme,
    disableRootThemeClass,
    reset,
    themeClassNameOnRoot
  } = param;
  useIsomorphicLayoutEffect(function() {
    updateMediaListeners();
  }, []);
  var contents = /* @__PURE__ */ jsxRuntimeExports.jsx(UnmountedClassName, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ComponentContext.Provider, {
      animationDriver: config == null ? void 0 : config.animations,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider, {
        themeClassNameOnRoot: themeClassNameOnRoot != null ? themeClassNameOnRoot : getSetting("themeClassNameOnRoot"),
        disableRootThemeClass: disableRootThemeClass != null ? disableRootThemeClass : getSetting("disableRootThemeClass"),
        defaultTheme: defaultTheme != null ? defaultTheme : config ? Object.keys(config.themes)[0] : "",
        reset,
        className,
        children
      })
    })
  });
  return getSetting("disableSSR") && (contents = /* @__PURE__ */ jsxRuntimeExports.jsx(ClientOnly, {
    enabled: true,
    children: contents
  })), /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
    children: [contents, false]
  });
}
function UnmountedClassName(props) {
  var [mounted, setMounted] = React.useState(false);
  return React.useEffect(function() {
    setMounted(true);
  }, []), props.children;
}
TamaguiProvider$2.displayName = "TamaguiProvider";
var ellipsisStyle = {
  numberOfLines: 1,
  lineBreakMode: "clip"
}, Text$2 = createComponent({
  acceptsClassName: true,
  isText: true,
  defaultProps: {
    fontFamily: "unset",
    suppressHighlighting: true
  },
  inlineWhenUnflattened: /* @__PURE__ */ new Set(["fontFamily"]),
  variants: {
    /**
    * @deprecated Use ellipsis instead
    */
    ellipse: {
      true: ellipsisStyle
    },
    ellipsis: {
      true: ellipsisStyle
    }
  },
  validStyles: __spreadValues(__spreadValues({}, validStyles), stylePropsTextOnly)
});
Text$2.displayName = "Text";
var View$2 = createComponent({
  acceptsClassName: true,
  defaultProps: stackDefaultStyles,
  validStyles
});
function useGet(currentValue, initialValue2, forwardToFunction) {
  var curRef = React__namespace.useRef(initialValue2 != null ? initialValue2 : currentValue);
  return useIsomorphicLayoutEffect(function() {
    curRef.current = currentValue;
  }), React__namespace.useCallback(forwardToFunction ? function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
    var _curRef_current;
    return (_curRef_current = curRef.current) === null || _curRef_current === void 0 ? void 0 : _curRef_current.apply(null, args);
  } : function() {
    return curRef.current;
  }, []);
}
function useEvent(callback) {
  return useGet(callback, defaultValue, true);
}
var defaultValue = function() {
  throw new Error("Cannot call an event handler while rendering.");
};
const emptyObject$1 = {}, hasOwnProperty = Object.prototype.hasOwnProperty, isArray = Array.isArray, uppercasePattern = /[A-Z]/g;
function toHyphenLower(match) {
  return "-" + match.toLowerCase();
}
function hyphenateString(str) {
  return str.replace(uppercasePattern, toHyphenLower);
}
function processIDRefList(idRefList) {
  return isArray(idRefList) ? idRefList.join(" ") : idRefList;
}
function flattenStyle(style) {
  if (style === null || typeof style != "object") return;
  if (!isArray(style)) return style;
  const result = {};
  for (let i = 0, styleLength = style.length; i < styleLength; ++i) {
    const computedStyle = flattenStyle(style[i]);
    if (computedStyle) for (const key in computedStyle) hasOwnProperty.call(computedStyle, key) && (result[key] = computedStyle[key]);
  }
  return result;
}
const stylesFromProps = /* @__PURE__ */ new WeakMap(), createDOMProps = (elementType, props, options) => {
  props || (props = emptyObject$1);
  const _a = props, {
    accessibilityActiveDescendant,
    accessibilityAtomic,
    accessibilityAutoComplete,
    accessibilityBusy,
    accessibilityChecked,
    accessibilityColumnCount,
    accessibilityColumnIndex,
    accessibilityColumnSpan,
    accessibilityControls,
    accessibilityCurrent,
    accessibilityDescribedBy,
    accessibilityDetails,
    accessibilityDisabled,
    accessibilityErrorMessage,
    accessibilityExpanded,
    accessibilityFlowTo,
    accessibilityHasPopup,
    accessibilityHidden,
    accessibilityInvalid,
    accessibilityKeyShortcuts,
    accessibilityLabel,
    accessibilityLabelledBy,
    accessibilityLevel,
    accessibilityLiveRegion,
    accessibilityModal,
    accessibilityMultiline,
    accessibilityMultiSelectable,
    accessibilityOrientation,
    accessibilityOwns,
    accessibilityPlaceholder,
    accessibilityPosInSet,
    accessibilityPressed,
    accessibilityReadOnly,
    accessibilityRequired,
    accessibilityRole: accessibilityRole,
    accessibilityRoleDescription: accessibilityRoleDescription,
    accessibilityRowCount,
    accessibilityRowIndex,
    accessibilityRowSpan,
    accessibilitySelected,
    accessibilitySetSize,
    accessibilitySort,
    accessibilityValueMax,
    accessibilityValueMin,
    accessibilityValueNow,
    accessibilityValueText,
    dataSet,
    focusable,
    nativeID,
    pointerEvents,
    style,
    testID,
    id: id2
  } = _a, domProps = __objRest(_a, [
    "accessibilityActiveDescendant",
    "accessibilityAtomic",
    "accessibilityAutoComplete",
    "accessibilityBusy",
    "accessibilityChecked",
    "accessibilityColumnCount",
    "accessibilityColumnIndex",
    "accessibilityColumnSpan",
    "accessibilityControls",
    "accessibilityCurrent",
    "accessibilityDescribedBy",
    "accessibilityDetails",
    "accessibilityDisabled",
    "accessibilityErrorMessage",
    "accessibilityExpanded",
    "accessibilityFlowTo",
    "accessibilityHasPopup",
    "accessibilityHidden",
    "accessibilityInvalid",
    "accessibilityKeyShortcuts",
    "accessibilityLabel",
    "accessibilityLabelledBy",
    "accessibilityLevel",
    "accessibilityLiveRegion",
    "accessibilityModal",
    "accessibilityMultiline",
    "accessibilityMultiSelectable",
    "accessibilityOrientation",
    "accessibilityOwns",
    "accessibilityPlaceholder",
    "accessibilityPosInSet",
    "accessibilityPressed",
    "accessibilityReadOnly",
    "accessibilityRequired",
    /* eslint-disable */
    "accessibilityRole",
    /* eslint-enable */
    "accessibilityRoleDescription",
    "accessibilityRowCount",
    "accessibilityRowIndex",
    "accessibilityRowSpan",
    "accessibilitySelected",
    "accessibilitySetSize",
    "accessibilitySort",
    "accessibilityValueMax",
    "accessibilityValueMin",
    "accessibilityValueNow",
    "accessibilityValueText",
    "dataSet",
    "focusable",
    "nativeID",
    "pointerEvents",
    "style",
    "testID",
    "id"
  ]), disabled = accessibilityDisabled, role = AccessibilityUtil.propsToAriaRole(props);
  accessibilityActiveDescendant != null && (domProps["aria-activedescendant"] = accessibilityActiveDescendant), accessibilityAtomic != null && (domProps["aria-atomic"] = accessibilityAtomic), accessibilityAutoComplete != null && (domProps["aria-autocomplete"] = accessibilityAutoComplete), accessibilityBusy != null && (domProps["aria-busy"] = accessibilityBusy), accessibilityChecked != null && (domProps["aria-checked"] = accessibilityChecked), accessibilityColumnCount != null && (domProps["aria-colcount"] = accessibilityColumnCount), accessibilityColumnIndex != null && (domProps["aria-colindex"] = accessibilityColumnIndex), accessibilityColumnSpan != null && (domProps["aria-colspan"] = accessibilityColumnSpan), accessibilityControls != null && (domProps["aria-controls"] = processIDRefList(accessibilityControls)), accessibilityCurrent != null && (domProps["aria-current"] = accessibilityCurrent), accessibilityDescribedBy != null && (domProps["aria-describedby"] = processIDRefList(accessibilityDescribedBy)), accessibilityDetails != null && (domProps["aria-details"] = accessibilityDetails), disabled === true && (domProps["aria-disabled"] = true, (elementType === "button" || elementType === "form" || elementType === "input" || elementType === "select" || elementType === "textarea") && (domProps.disabled = true)), accessibilityErrorMessage != null && (domProps["aria-errormessage"] = accessibilityErrorMessage), accessibilityExpanded != null && (domProps["aria-expanded"] = accessibilityExpanded), accessibilityFlowTo != null && (domProps["aria-flowto"] = processIDRefList(accessibilityFlowTo)), accessibilityHasPopup != null && (domProps["aria-haspopup"] = accessibilityHasPopup), accessibilityHidden === true && (domProps["aria-hidden"] = accessibilityHidden), accessibilityInvalid != null && (domProps["aria-invalid"] = accessibilityInvalid), accessibilityKeyShortcuts != null && Array.isArray(accessibilityKeyShortcuts) && (domProps["aria-keyshortcuts"] = accessibilityKeyShortcuts.join(" ")), accessibilityLabel != null && (domProps["aria-label"] = accessibilityLabel), accessibilityLabelledBy != null && (domProps["aria-labelledby"] = processIDRefList(accessibilityLabelledBy)), accessibilityLevel != null && (domProps["aria-level"] = accessibilityLevel), accessibilityLiveRegion != null && (domProps["aria-live"] = accessibilityLiveRegion === "none" ? "off" : accessibilityLiveRegion), accessibilityModal != null && (domProps["aria-modal"] = accessibilityModal), accessibilityMultiline != null && (domProps["aria-multiline"] = accessibilityMultiline), accessibilityMultiSelectable != null && (domProps["aria-multiselectable"] = accessibilityMultiSelectable), accessibilityOrientation != null && (domProps["aria-orientation"] = accessibilityOrientation), accessibilityOwns != null && (domProps["aria-owns"] = processIDRefList(accessibilityOwns)), accessibilityPlaceholder != null && (domProps["aria-placeholder"] = accessibilityPlaceholder), accessibilityPosInSet != null && (domProps["aria-posinset"] = accessibilityPosInSet), accessibilityPressed != null && (domProps["aria-pressed"] = accessibilityPressed), accessibilityReadOnly != null && (domProps["aria-readonly"] = accessibilityReadOnly, (elementType === "input" || elementType === "select" || elementType === "textarea") && (domProps.readOnly = true)), accessibilityRequired != null && (domProps["aria-required"] = accessibilityRequired, (elementType === "input" || elementType === "select" || elementType === "textarea") && (domProps.required = true)), role != null && (domProps.role = role === "none" ? "presentation" : role), accessibilityRoleDescription != null && (domProps["aria-roledescription"] = accessibilityRoleDescription), accessibilityRowCount != null && (domProps["aria-rowcount"] = accessibilityRowCount), accessibilityRowIndex != null && (domProps["aria-rowindex"] = accessibilityRowIndex), accessibilityRowSpan != null && (domProps["aria-rowspan"] = accessibilityRowSpan), accessibilitySelected != null && (domProps["aria-selected"] = accessibilitySelected), accessibilitySetSize != null && (domProps["aria-setsize"] = accessibilitySetSize), accessibilitySort != null && (domProps["aria-sort"] = accessibilitySort), accessibilityValueMax != null && (domProps["aria-valuemax"] = accessibilityValueMax), accessibilityValueMin != null && (domProps["aria-valuemin"] = accessibilityValueMin), accessibilityValueNow != null && (domProps["aria-valuenow"] = accessibilityValueNow), accessibilityValueText != null && (domProps["aria-valuetext"] = accessibilityValueText);
  const tmgCN = dataSet ? dataSet.className : void 0, tmgID = dataSet ? dataSet.id : void 0;
  if (dataSet != null) {
    for (const dataProp in dataSet) if (!(dataProp === "className" || dataProp === "id") && hasOwnProperty.call(dataSet, dataProp)) {
      const dataName = hyphenateString(dataProp), dataValue = dataSet[dataProp];
      dataValue != null && (domProps[`data-${dataName}`] = dataValue);
    }
  }
  focusable === false && (domProps.tabIndex = "-1"), // These native elements are keyboard focusable by default
  elementType === "a" || elementType === "button" || elementType === "input" || elementType === "select" || elementType === "textarea" ? (focusable === false || accessibilityDisabled === true) && (domProps.tabIndex = "-1") : (
    /* These roles are made keyboard focusable by default */
    role === "button" || role === "checkbox" || role === "link" || role === "radio" || role === "textbox" || role === "switch" ? focusable !== false && (domProps.tabIndex = "0") : focusable === true && (domProps.tabIndex = "0")
  );
  flattenStyle(style);
  let className = tmgCN || "";
  props.className && (className += ` ${props.className}`);
  const stylesAtomic = getCSSStylesAtomic();
  stylesFromProps.set(domProps, stylesAtomic), domProps.style = stylesAtomic.reduce((acc, [key, value]) => key[0] === "_" || key.startsWith("is_") || key.startsWith("font_") ? (className += ` ${key}`, acc) : (key === "$$css" || key === "" || (acc[key] = value), acc), {}), className && (domProps.className = className);
  const _id = tmgID || id2 || nativeID;
  return _id && (domProps.id = _id), testID != null && (domProps["data-testid"] = testID), domProps;
};
const isWebColor = (color) => color === "currentcolor" || color === "currentColor" || color === "inherit" || color.startsWith("var(");
const processColor = (color) => {
  if (color == null)
    return color;
  let int32Color = index_default(color);
  if (int32Color != null)
    return int32Color = (int32Color << 24 | int32Color >>> 8) >>> 0, int32Color;
};
const normalizeColor = (color, opacity = 1) => {
  if (color == null) return;
  if (typeof color == "string" && isWebColor(color)) return color;
  const colorInt = processColor(color);
  if (colorInt != null) {
    const r = colorInt >> 16 & 255, g = colorInt >> 8 & 255, b2 = colorInt & 255, alpha = ((colorInt >> 24 & 255) / 255 * opacity).toFixed(2);
    return `rgba(${r},${g},${b2},${alpha})`;
  }
  if (typeof color == "string") return color;
};
function normalizeValueWithProperty(value, property) {
  let returnValue = value;
  return typeof value == "number" ? returnValue = `${value}px` : property != null, returnValue;
}
const focusableElements$1 = {
  A: true,
  INPUT: true,
  SELECT: true,
  TEXTAREA: true
}, UIManager$1 = {
  blur(node) {
    try {
      node.blur();
    } catch (e2) {
    }
  },
  focus(node) {
    try {
      const name = node.nodeName;
      node.getAttribute("tabIndex") == null && focusableElements$1[name] == null && node.setAttribute("tabIndex", "-1"), node.focus();
    } catch (e2) {
    }
  },
  measure(node, callback) {
    return measure(node, callback);
  },
  measureInWindow(node, callback) {
    return measureInWindow(node, callback);
  },
  // note its flipped fail and success on purpose lol
  measureLayout(node, relativeToNativeNode, onFail, onSuccess) {
    return __async(this, null, function* () {
      return measureLayout(node, relativeToNativeNode, onSuccess);
    });
  },
  configureNextLayoutAnimation(config, onAnimationDidEnd) {
    onAnimationDidEnd();
  },
  // mocks
  setLayoutAnimationEnabledExperimental() {
  }
};
const TextInputState = {
  /**
   * Internal state
   */
  _currentlyFocusedNode: null,
  /**
   * Returns the ID of the currently focused text field, if one exists
   * If no text field is focused it returns null
   */
  currentlyFocusedField() {
    return document.activeElement !== this._currentlyFocusedNode && (this._currentlyFocusedNode = null), this._currentlyFocusedNode;
  },
  /**
   * @param {Object} TextInputID id of the text field to focus
   * Focuses the specified text field
   * noop if the text field was already focused
   */
  focusTextInput(textFieldNode) {
    textFieldNode !== null && (this._currentlyFocusedNode = textFieldNode, document.activeElement !== textFieldNode && UIManager$1.focus(textFieldNode));
  },
  /**
   * @param {Object} textFieldNode id of the text field to focus
   * Unfocuses the specified text field
   * noop if it wasn't focused
   */
  blurTextInput(textFieldNode) {
    textFieldNode !== null && (this._currentlyFocusedNode = null, document.activeElement === textFieldNode && UIManager$1.blur(textFieldNode));
  }
};
const dismissKeyboard = () => {
  TextInputState.blurTextInput(TextInputState.currentlyFocusedField());
};
const dataUriPattern = /^data:/;
const _ImageUriCache = class _ImageUriCache {
  static has(uri) {
    const entries = _ImageUriCache._entries;
    return dataUriPattern.test(uri) || !!entries[uri];
  }
  static add(uri) {
    const entries = _ImageUriCache._entries, lastUsedTimestamp = Date.now();
    entries[uri] ? (entries[uri].lastUsedTimestamp = lastUsedTimestamp, entries[uri].refCount += 1) : entries[uri] = {
      lastUsedTimestamp,
      refCount: 1
    };
  }
  static remove(uri) {
    const entries = _ImageUriCache._entries;
    entries[uri] && (entries[uri].refCount -= 1), _ImageUriCache._cleanUpIfNeeded();
  }
  static _cleanUpIfNeeded() {
    const entries = _ImageUriCache._entries, imageUris = Object.keys(entries);
    if (imageUris.length + 1 > _ImageUriCache._maximumEntries) {
      let leastRecentlyUsedKey, leastRecentlyUsedEntry;
      imageUris.forEach((uri) => {
        const entry = entries[uri];
        (!leastRecentlyUsedEntry || entry.lastUsedTimestamp < leastRecentlyUsedEntry.lastUsedTimestamp) && entry.refCount === 0 && (leastRecentlyUsedKey = uri, leastRecentlyUsedEntry = entry);
      }), leastRecentlyUsedKey && delete entries[leastRecentlyUsedKey];
    }
  }
};
__publicField(_ImageUriCache, "_maximumEntries", 256);
__publicField(_ImageUriCache, "_entries", {});
let ImageUriCache = _ImageUriCache;
let id = 0;
const requests = {}, ImageLoader = {
  abort(requestId) {
    let image = requests[`${requestId}`];
    image && (image.onerror = null, image.onload = null, image = null, delete requests[`${requestId}`]);
  },
  getSize(uri, success, failure) {
    let complete = false;
    const interval = setInterval(callback, 16), requestId = ImageLoader.load(uri, callback, errorCallback);
    function callback() {
      const image = requests[`${requestId}`];
      if (image) {
        const {
          naturalHeight,
          naturalWidth
        } = image;
        naturalHeight && naturalWidth && (success(naturalWidth, naturalHeight), complete = true);
      }
      complete && (ImageLoader.abort(requestId), clearInterval(interval));
    }
    function errorCallback() {
      typeof failure == "function" && failure(), ImageLoader.abort(requestId), clearInterval(interval);
    }
  },
  has(uri) {
    return ImageUriCache.has(uri);
  },
  load(uri, onLoad, onError) {
    id += 1;
    const image = new window.Image();
    return image.onerror = onError, image.onload = (e2) => {
      const onDecode = () => onLoad({
        nativeEvent: e2
      });
      typeof image.decode == "function" ? image.decode().then(onDecode, onDecode) : setTimeout(onDecode, 0);
    }, image.src = uri, requests[`${id}`] = image, id;
  },
  prefetch(uri) {
    return new Promise((resolve, reject) => {
      ImageLoader.load(uri, () => {
        ImageUriCache.add(uri), ImageUriCache.remove(uri), resolve();
      }, reject);
    });
  },
  queryCache(uris) {
    const result = {};
    return uris.forEach((u) => {
      ImageUriCache.has(u) && (result[u] = "disk/memory");
    }), Promise.resolve(result);
  }
};
function pick(obj, list) {
  const nextObj = {};
  for (const key in obj) obj.hasOwnProperty(key) && list[key] === true && (nextObj[key] = obj[key]);
  return nextObj;
}
const Platform = {
  OS: "web"
};
const defaultOffset = {
  height: 0,
  width: 0
}, createBoxShadowValue = (style) => {
  const {
    shadowColor,
    shadowOffset,
    shadowOpacity,
    shadowRadius
  } = style, {
    height,
    width
  } = shadowOffset || defaultOffset, offsetX = normalizeValueWithProperty(width), offsetY = normalizeValueWithProperty(height), blurRadius = normalizeValueWithProperty(shadowRadius || 0), color = normalizeColor(shadowColor || "black", shadowOpacity);
  if (color != null && offsetX != null && offsetY != null && blurRadius != null) return `${offsetX} ${offsetY} ${blurRadius} ${color}`;
};
const absoluteFillObject = {
  position: "absolute",
  left: 0,
  right: 0,
  top: 0,
  bottom: 0
}, absoluteFill = absoluteFillObject;
function create(styles2) {
  return styles2;
}
function compose(style1, style2) {
  return flatten(style1, style2);
}
function flatten(...styles2) {
  return styles2.flat().flat().flat().flat().reduce((acc, cur) => (cur && Object.assign(acc, cur), acc), {});
}
function getSheet() {
  return {
    id: "",
    textContent: sheet.getTextContent()
  };
}
function StyleSheet(styles2, options) {
}
StyleSheet.absoluteFill = absoluteFill;
StyleSheet.absoluteFillObject = absoluteFillObject;
StyleSheet.create = create;
StyleSheet.compose = compose;
StyleSheet.flatten = flatten;
StyleSheet.getSheet = getSheet;
StyleSheet.hairlineWidth = 1;
const focusableElements = {
  A: true,
  INPUT: true,
  SELECT: true,
  TEXTAREA: true
}, UIManager = {
  blur(node) {
    try {
      node.blur();
    } catch (e2) {
    }
  },
  focus(node) {
    try {
      const name = node.nodeName;
      node.getAttribute("tabIndex") == null && focusableElements[name] == null && node.setAttribute("tabIndex", "-1"), node.focus();
    } catch (e2) {
    }
  },
  measure(node, callback) {
    return measure(node, callback);
  },
  measureInWindow(node, callback) {
    return measureInWindow(node, callback);
  },
  // note its flipped fail and success on purpose lol
  measureLayout(node, relativeToNativeNode, onFail, onSuccess) {
    return __async(this, null, function* () {
      return measureLayout(node, relativeToNativeNode, onSuccess);
    });
  },
  configureNextLayoutAnimation(config, onAnimationDidEnd) {
    onAnimationDidEnd();
  },
  // mocks
  setLayoutAnimationEnabledExperimental() {
  }
};
function useElementLayout(ref, onLayout) {
  const wrappedRef = React.useMemo(() => ({
    current: {
      get host() {
        return ref.current;
      }
    }
  }), [ref]);
  return React.useEffect(() => {
    enable();
  }, []), useElementLayout$1(wrappedRef, onLayout);
}
function invariant(condition, log, ...logVars) {
  if (!condition) throw new Error(log);
}
function warning(condition, log, ...logVars) {
}
function useMergeRefs(...args) {
  return React__namespace.useMemo(
    () => mergeRefs(...args),
    // eslint-disable-next-line
    [...args]
  );
}
const useCreateElement = (component, props, options) => {
  const {
    element,
    styles: styles2
  } = createElementAndStyles(component, props);
  useDidFinishSSR();
  const styleTags = React.useMemo(() => null, [
    // never changes
  ]);
  return React.useInsertionEffect(() => {
    if (!styles2) return;
    const styleObj = {};
    for (const style of styles2) styleObj[style[0]] = style;
  }, [styles2]), /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
    children: [element, styleTags]
  });
}, createElement = (component, props, options) => {
  const {
    element,
    styles: styles2
  } = createElementAndStyles(component, props);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
    children: [element, styles2 ? getStyleTags() : null]
  });
}, createElementAndStyles = (component, props, options) => {
  let accessibilityComponent;
  component && component.constructor === String && (accessibilityComponent = AccessibilityUtil.propsToAccessibilityComponent(props));
  const Component = accessibilityComponent || component, domProps = createDOMProps(Component, props), styles2 = stylesFromProps.get(domProps);
  let element = React.createElement(Component, domProps);
  return {
    element: domProps.dir ? /* @__PURE__ */ jsxRuntimeExports.jsx(LocaleProvider, {
      direction: domProps.dir,
      locale: domProps.lang,
      children: element
    }) : element,
    styles: styles2
  };
};
function getQuery() {
  return canUseDOM$1 && window.matchMedia != null ? window.matchMedia("(prefers-color-scheme: dark)") : null;
}
const query = getQuery(), listenerMapping = /* @__PURE__ */ new WeakMap(), Appearance = {
  getColorScheme() {
    return query && query.matches ? "dark" : "light";
  },
  addChangeListener(listener) {
    let mappedListener = listenerMapping.get(listener);
    mappedListener || (mappedListener = ({
      matches
    }) => {
      listener({
        colorScheme: matches ? "dark" : "light"
      });
    }, listenerMapping.set(listener, mappedListener)), query && query.addListener(mappedListener);
    function remove() {
      const mappedListener2 = listenerMapping.get(listener);
      query && mappedListener2 && query.removeListener(mappedListener2), listenerMapping.delete(listener);
    }
    return {
      remove
    };
  }
};
var reactDom = { exports: {} };
var reactDom_production = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDom_production;
function requireReactDom_production() {
  if (hasRequiredReactDom_production) return reactDom_production;
  hasRequiredReactDom_production = 1;
  var React$1 = React;
  function formatProdErrorMessage(code) {
    var url = "https://react.dev/errors/" + code;
    if (1 < arguments.length) {
      url += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var i = 2; i < arguments.length; i++)
        url += "&args[]=" + encodeURIComponent(arguments[i]);
    }
    return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function noop() {
  }
  var Internals = {
    d: {
      f: noop,
      r: function() {
        throw Error(formatProdErrorMessage(522));
      },
      D: noop,
      C: noop,
      L: noop,
      m: noop,
      X: noop,
      S: noop,
      M: noop
    },
    p: 0,
    findDOMNode: null
  }, REACT_PORTAL_TYPE = Symbol.for("react.portal");
  function createPortal$1(children, containerInfo, implementation) {
    var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return {
      $$typeof: REACT_PORTAL_TYPE,
      key: null == key ? null : "" + key,
      children,
      containerInfo,
      implementation
    };
  }
  var ReactSharedInternals = React$1.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function getCrossOriginStringAs(as, input) {
    if ("font" === as) return "";
    if ("string" === typeof input)
      return "use-credentials" === input ? input : "";
  }
  reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
  reactDom_production.createPortal = function(children, container) {
    var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
      throw Error(formatProdErrorMessage(299));
    return createPortal$1(children, container, null, key);
  };
  reactDom_production.flushSync = function(fn) {
    var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
    try {
      if (ReactSharedInternals.T = null, Internals.p = 2, fn) return fn();
    } finally {
      ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
    }
  };
  reactDom_production.preconnect = function(href, options) {
    "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
  };
  reactDom_production.prefetchDNS = function(href) {
    "string" === typeof href && Internals.d.D(href);
  };
  reactDom_production.preinit = function(href, options) {
    if ("string" === typeof href && options && "string" === typeof options.as) {
      var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
      "style" === as ? Internals.d.S(
        href,
        "string" === typeof options.precedence ? options.precedence : void 0,
        {
          crossOrigin,
          integrity,
          fetchPriority
        }
      ) : "script" === as && Internals.d.X(href, {
        crossOrigin,
        integrity,
        fetchPriority,
        nonce: "string" === typeof options.nonce ? options.nonce : void 0
      });
    }
  };
  reactDom_production.preinitModule = function(href, options) {
    if ("string" === typeof href)
      if ("object" === typeof options && null !== options) {
        if (null == options.as || "script" === options.as) {
          var crossOrigin = getCrossOriginStringAs(
            options.as,
            options.crossOrigin
          );
          Internals.d.M(href, {
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0
          });
        }
      } else null == options && Internals.d.M(href);
  };
  reactDom_production.preload = function(href, options) {
    if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
      var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
      Internals.d.L(href, as, {
        crossOrigin,
        integrity: "string" === typeof options.integrity ? options.integrity : void 0,
        nonce: "string" === typeof options.nonce ? options.nonce : void 0,
        type: "string" === typeof options.type ? options.type : void 0,
        fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
        referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
        imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
        imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
        media: "string" === typeof options.media ? options.media : void 0
      });
    }
  };
  reactDom_production.preloadModule = function(href, options) {
    if ("string" === typeof href)
      if (options) {
        var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
        Internals.d.m(href, {
          as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
          crossOrigin,
          integrity: "string" === typeof options.integrity ? options.integrity : void 0
        });
      } else Internals.d.m(href);
  };
  reactDom_production.requestFormReset = function(form) {
    Internals.d.r(form);
  };
  reactDom_production.unstable_batchedUpdates = function(fn, a) {
    return fn(a);
  };
  reactDom_production.useFormState = function(action, initialState, permalink) {
    return ReactSharedInternals.H.useFormState(action, initialState, permalink);
  };
  reactDom_production.useFormStatus = function() {
    return ReactSharedInternals.H.useHostTransitionStatus();
  };
  reactDom_production.version = "19.1.0";
  return reactDom_production;
}
var hasRequiredReactDom;
function requireReactDom() {
  if (hasRequiredReactDom) return reactDom.exports;
  hasRequiredReactDom = 1;
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    reactDom.exports = requireReactDom_production();
  }
  return reactDom.exports;
}
requireReactDom();
const pickProps$1 = (props) => pick(props, forwardPropsListView), View$1 = React__namespace.forwardRef((props, forwardedRef) => {
  const _a = props, {
    hrefAttrs,
    onLayout,
    onMoveShouldSetResponder,
    onMoveShouldSetResponderCapture,
    onResponderEnd,
    onResponderGrant,
    onResponderMove,
    onResponderReject,
    onResponderRelease,
    onResponderStart,
    onResponderTerminate,
    onResponderTerminationRequest,
    onScrollShouldSetResponder,
    onScrollShouldSetResponderCapture,
    onSelectionChangeShouldSetResponder,
    onSelectionChangeShouldSetResponderCapture,
    onStartShouldSetResponder,
    onStartShouldSetResponderCapture
  } = _a, rest = __objRest(_a, [
    "hrefAttrs",
    "onLayout",
    "onMoveShouldSetResponder",
    "onMoveShouldSetResponderCapture",
    "onResponderEnd",
    "onResponderGrant",
    "onResponderMove",
    "onResponderReject",
    "onResponderRelease",
    "onResponderStart",
    "onResponderTerminate",
    "onResponderTerminationRequest",
    "onScrollShouldSetResponder",
    "onScrollShouldSetResponderCapture",
    "onSelectionChangeShouldSetResponder",
    "onSelectionChangeShouldSetResponderCapture",
    "onStartShouldSetResponder",
    "onStartShouldSetResponderCapture"
  ]);
  const hasTextAncestor = React__namespace.useContext(TextAncestorContext), hostRef = React__namespace.useRef(null), {
    direction: contextDirection
  } = useLocaleContext();
  useElementLayout(hostRef, onLayout), useResponderEvents(hostRef, {
    onMoveShouldSetResponder,
    onMoveShouldSetResponderCapture,
    onResponderEnd,
    onResponderGrant,
    onResponderMove,
    onResponderReject,
    onResponderRelease,
    onResponderStart,
    onResponderTerminate,
    onResponderTerminationRequest,
    onScrollShouldSetResponder,
    onScrollShouldSetResponderCapture,
    onSelectionChangeShouldSetResponder,
    onSelectionChangeShouldSetResponderCapture,
    onStartShouldSetResponder,
    onStartShouldSetResponderCapture
  });
  let component = "div";
  const langDirection = props.lang != null ? getLocaleDirection(props.lang) : null, componentDirection = props.dir || langDirection, supportedProps = pickProps$1(rest);
  if (supportedProps.dir = componentDirection, supportedProps.style = [styles$5.view, hasTextAncestor && styles$5.inline, props.style], props.href != null && (component = "a", hrefAttrs != null)) {
    const {
      download,
      rel,
      target
    } = hrefAttrs;
    download != null && (supportedProps.download = download), rel != null && (supportedProps.rel = rel), typeof target == "string" && (supportedProps.target = target.charAt(0) !== "_" ? "_" + target : target);
  }
  const platformMethodsRef = usePlatformMethods(supportedProps), setRef2 = useMergeRefs(hostRef, platformMethodsRef, forwardedRef);
  return supportedProps.ref = setRef2, useCreateElement(component, supportedProps);
});
View$1.displayName = "View";
const styles$5 = {
  view: {
    alignItems: "stretch",
    boxSizing: "border-box",
    display: "flex",
    flexBasis: "auto",
    flexDirection: "column",
    flexShrink: 0
  },
  inline: {
    display: "inline-flex"
  }
};
const dimensions = {
  window: {
    fontScale: 1,
    height: 0,
    scale: 1,
    width: 0
  },
  screen: {
    fontScale: 1,
    height: 0,
    scale: 1,
    width: 0
  }
}, listeners = {};
let shouldInit = canUseDOM$1;
function update() {
  if (!canUseDOM$1) return;
  const win = window, docEl = win.document.documentElement;
  dimensions.window = {
    fontScale: 1,
    height: docEl.clientHeight,
    scale: win.devicePixelRatio || 1,
    width: docEl.clientWidth
  }, dimensions.screen = {
    fontScale: 1,
    height: win.screen.height,
    scale: win.devicePixelRatio || 1,
    width: win.screen.width
  };
}
function handleResize() {
  update(), Array.isArray(listeners.change) && listeners.change.forEach((handler) => handler(dimensions));
}
class Dimensions {
  static get(dimension) {
    return shouldInit && (shouldInit = false, update()), invariant(dimensions[dimension], `No dimension set for key ${dimension}`), dimensions[dimension];
  }
  static set(initialDimensions) {
    initialDimensions && (canUseDOM$1 ? invariant(false, "Dimensions cannot be set in the browser") : (initialDimensions.screen != null && (dimensions.screen = initialDimensions.screen), initialDimensions.window != null && (dimensions.window = initialDimensions.window)));
  }
  static addEventListener(type, handler) {
    return listeners[type] = listeners[type] || [], listeners[type].push(handler), {
      remove: () => {
        this.removeEventListener(type, handler);
      }
    };
  }
  static removeEventListener(type, handler) {
    Array.isArray(listeners[type]) && (listeners[type] = listeners[type].filter((_handler) => _handler !== handler));
  }
}
canUseDOM$1 && window.addEventListener("resize", handleResize, false);
const Keyboard = {
  addListener() {
    return {
      remove: () => {
      }
    };
  },
  dismiss() {
    dismissKeyboard();
  },
  removeAllListeners() {
  },
  removeListener() {
  }
};
const initialURL = canUseDOM$1 ? window.location.href : "";
class Linking {
  constructor() {
    /**
     * An object mapping of event name
     * and all the callbacks subscribing to it
     */
    __publicField(this, "_eventCallbacks", {});
    /**
     * Adds a event listener for the specified event. The callback will be called when the
     * said event is dispatched.
     */
    __publicField(this, "addEventListener", (event, callback) => {
      if (!this._eventCallbacks[event]) {
        this._eventCallbacks[event] = [callback];
        return;
      }
      this._eventCallbacks[event].push(callback);
    });
    /**
     * Removes a previously added event listener for the specified event. The callback must
     * be the same object as the one passed to `addEventListener`.
     */
    __publicField(this, "removeEventListener", (event, callback) => {
      const filteredCallbacks = this._eventCallbacks[event].filter((c) => c.toString() !== callback.toString());
      this._eventCallbacks[event] = filteredCallbacks;
    });
  }
  _dispatchEvent(event, ...data) {
    const listeners2 = this._eventCallbacks[event];
    listeners2 != null && Array.isArray(listeners2) && listeners2.map((listener) => {
      listener(...data);
    });
  }
  canOpenURL() {
    return Promise.resolve(true);
  }
  getInitialURL() {
    return Promise.resolve(initialURL);
  }
  /**
   * Try to open the given url in a secure fashion. The method returns a Promise object.
   * If a target is passed (including undefined) that target will be used, otherwise '_blank'.
   * If the url opens, the promise is resolved. If not, the promise is rejected.
   * Dispatches the `onOpen` event if `url` is opened successfully.
   */
  openURL(url, target) {
    arguments.length === 1 && (target = "_blank");
    try {
      return open(url, target), this._dispatchEvent("onOpen", url), Promise.resolve();
    } catch (e2) {
      return Promise.reject(e2);
    }
  }
  _validateURL(url) {
    invariant(typeof url == "string", "Invalid URL: should be a string. Was: " + url), invariant(url, "Invalid URL: cannot be empty");
  }
}
const open = (url, target) => {
  if (canUseDOM$1) {
    const urlToOpen = new URL(url, window.location).toString();
    urlToOpen.indexOf("tel:") === 0 ? window.location = urlToOpen : window.open(urlToOpen, target, "noopener");
  }
}, LinkingInstance = new Linking();
const currentCentroidXOfTouchesChangedAfter = () => 0, currentCentroidYOfTouchesChangedAfter = () => 0, previousCentroidXOfTouchesChangedAfter = () => 0, previousCentroidYOfTouchesChangedAfter = () => 0, PanResponder = {
  _initializeGestureState(gestureState) {
    gestureState.moveX = 0, gestureState.moveY = 0, gestureState.x0 = 0, gestureState.y0 = 0, gestureState.dx = 0, gestureState.dy = 0, gestureState.vx = 0, gestureState.vy = 0, gestureState.numberActiveTouches = 0, gestureState._accountsForMovesUpTo = 0;
  },
  _updateGestureStateOnMove(gestureState, touchHistory) {
    gestureState.numberActiveTouches = touchHistory.numberActiveTouches, gestureState.moveX = currentCentroidXOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo), gestureState.moveY = currentCentroidYOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo);
    gestureState._accountsForMovesUpTo;
    const prevX = previousCentroidXOfTouchesChangedAfter(), prevY = previousCentroidYOfTouchesChangedAfter(), nextDX = gestureState.dx + (gestureState.moveX - prevX), nextDY = gestureState.dy + (gestureState.moveY - prevY), dt = touchHistory.mostRecentTimeStamp - gestureState._accountsForMovesUpTo;
    gestureState.vx = (nextDX - gestureState.dx) / dt, gestureState.vy = (nextDY - gestureState.dy) / dt, gestureState.dx = nextDX, gestureState.dy = nextDY, gestureState._accountsForMovesUpTo = touchHistory.mostRecentTimeStamp;
  },
  create(config) {
    const interactionState = {
      handle: null
    }, gestureState = {
      stateID: Math.random(),
      moveX: 0,
      moveY: 0,
      x0: 0,
      y0: 0,
      dx: 0,
      dy: 0,
      vx: 0,
      vy: 0,
      numberActiveTouches: 0,
      _accountsForMovesUpTo: 0
    };
    return {
      panHandlers: {
        onStartShouldSetResponder: (evt) => config.onStartShouldSetPanResponder ? config.onStartShouldSetPanResponder(evt, gestureState) : false,
        onMoveShouldSetResponder: (evt) => config.onMoveShouldSetPanResponder ? config.onMoveShouldSetPanResponder(evt, gestureState) : false,
        onResponderGrant: (evt) => {
          this._initializeGestureState(gestureState), gestureState.x0 = evt.nativeEvent.pageX || 0, gestureState.y0 = evt.nativeEvent.pageY || 0, config.onPanResponderGrant && config.onPanResponderGrant(evt, gestureState);
        },
        onResponderMove: (evt) => {
          evt.nativeEvent.touches && evt.nativeEvent.touches.length === 1 && this._updateGestureStateOnMove(gestureState, evt.nativeEvent), config.onPanResponderMove && config.onPanResponderMove(evt, gestureState);
        },
        onResponderRelease: (evt) => {
          config.onPanResponderRelease && config.onPanResponderRelease(evt, gestureState);
        },
        onResponderTerminate: (evt) => {
          config.onPanResponderTerminate && config.onPanResponderTerminate(evt, gestureState);
        },
        onResponderTerminationRequest: (evt) => config.onPanResponderTerminationRequest ? config.onPanResponderTerminationRequest(evt, gestureState) : true
      },
      getInteractionHandle() {
        return interactionState.handle;
      }
    };
  }
};
var PanResponder_default = PanResponder;
class PixelRatio {
  /**
   * Returns the device pixel density.
   */
  static get() {
    return Dimensions.get("window").scale;
  }
  /**
   * No equivalent for Web
   */
  static getFontScale() {
    return Dimensions.get("window").fontScale || PixelRatio.get();
  }
  /**
   * Converts a layout size (dp) to pixel size (px).
   * Guaranteed to return an integer number.
   */
  static getPixelSizeForLayoutSize(layoutSize) {
    return Math.round(layoutSize * PixelRatio.get());
  }
  /**
   * Rounds a layout size (dp) to the nearest layout size that corresponds to
   * an integer number of pixels. For example, on a device with a PixelRatio
   * of 3, `PixelRatio.roundToNearestPixel(8.4) = 8.33`, which corresponds to
   * exactly (8.33 * 3) = 25 pixels.
   */
  static roundToNearestPixel(layoutSize) {
    const ratio = PixelRatio.get();
    return Math.round(layoutSize * ratio) / ratio;
  }
}
class UnimplementedView extends React.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "setNativeProps", () => {
    });
  }
  render() {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(View$1, __spreadValues({}, this.props));
  }
}
const createSvgCircle = (style) => /* @__PURE__ */ jsxRuntimeExports.jsx("circle", {
  cx: "16",
  cy: "16",
  fill: "none",
  r: "14",
  strokeWidth: "4",
  style
}), ActivityIndicator = React__namespace.forwardRef((props, forwardedRef) => {
  const _a = props, {
    animating = true,
    color = "#1976D2",
    hidesWhenStopped = true,
    size = "small",
    style
  } = _a, other = __objRest(_a, [
    "animating",
    "color",
    "hidesWhenStopped",
    "size",
    "style"
  ]), svg = /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", {
    height: "100%",
    viewBox: "0 0 32 32",
    width: "100%",
    children: [createSvgCircle({
      stroke: color,
      opacity: 0.2
    }), createSvgCircle({
      stroke: color,
      strokeDasharray: 80,
      strokeDashoffset: 60
    })]
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(View$1, __spreadProps(__spreadValues({}, other), {
    accessibilityRole: "progressbar",
    accessibilityValueMax: 1,
    accessibilityValueMin: 0,
    ref: forwardedRef,
    style: [styles$4.container, style],
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(View$1, {
      children: svg,
      style: [typeof size == "number" ? {
        height: size,
        width: size
      } : indicatorSizes[size], styles$4.animation, !animating && styles$4.animationPause, !animating && hidesWhenStopped && styles$4.hidesWhenStopped]
    })
  }));
});
ActivityIndicator.displayName = "ActivityIndicator";
const styles$4 = StyleSheet.create({
  container: {
    alignItems: "center",
    justifyContent: "center"
  },
  hidesWhenStopped: {
    visibility: "hidden"
  },
  animation: {
    animationDuration: "0.75s",
    animationKeyframes: [{
      "0%": {
        transform: [{
          rotate: "0deg"
        }]
      },
      "100%": {
        transform: [{
          rotate: "360deg"
        }]
      }
    }],
    animationTimingFunction: "linear",
    animationIterationCount: "infinite"
  },
  animationPause: {
    animationPlayState: "paused"
  }
}), indicatorSizes = StyleSheet.create({
  small: {
    width: 20,
    height: 20
  },
  large: {
    width: 36,
    height: 36
  }
});
const ERRORED = "ERRORED", LOADED = "LOADED", LOADING = "LOADING", IDLE = "IDLE";
let _filterId = 0;
const svgDataUriPattern = /^(data:image\/svg\+xml;utf8,)(.*)/;
function createTintColorSVG(tintColor, id2) {
  return tintColor && id2 != null ? /* @__PURE__ */ jsxRuntimeExports.jsx("svg", {
    style: {
      position: "absolute",
      height: 0,
      visibility: "hidden",
      width: 0
    },
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("defs", {
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("filter", {
        id: `tint-${id2}`,
        suppressHydrationWarning: true,
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx("feFlood", {
          floodColor: `${tintColor}`
        }, tintColor), /* @__PURE__ */ jsxRuntimeExports.jsx("feComposite", {
          in2: "SourceAlpha",
          operator: "atop"
        })]
      })
    })
  }) : null;
}
function getFlatStyle(style, blurRadius, filterId) {
  const flatStyle = StyleSheet.flatten(style), {
    filter,
    resizeMode,
    shadowOffset,
    tintColor
  } = flatStyle, filters = [];
  let _filter = null;
  if (filter && filters.push(filter), blurRadius && filters.push(`blur(${blurRadius}px)`), shadowOffset) {
    const shadowString = createBoxShadowValue(flatStyle);
    shadowString && filters.push(`drop-shadow(${shadowString})`);
  }
  return tintColor && filterId != null && filters.push(`url(#tint-${filterId})`), filters.length > 0 && (_filter = filters.join(" ")), delete flatStyle.blurRadius, delete flatStyle.shadowColor, delete flatStyle.shadowOpacity, delete flatStyle.shadowOffset, delete flatStyle.shadowRadius, delete flatStyle.tintColor, delete flatStyle.overlayColor, delete flatStyle.resizeMode, [flatStyle, resizeMode, _filter, tintColor];
}
function resolveAssetDimensions(source) {
  if (typeof source == "number") {
    const {
      height,
      width
    } = getAssetByID(source);
    return {
      height,
      width
    };
  } else if (source != null && !Array.isArray(source) && typeof source == "object") {
    const {
      height,
      width
    } = source;
    return {
      height,
      width
    };
  }
}
function resolveAssetUri(source) {
  let uri = null;
  if (typeof source == "number") {
    const asset = getAssetByID(source);
    let scale = asset.scales[0];
    if (asset.scales.length > 1) {
      const preferredScale = PixelRatio.get();
      scale = asset.scales.reduce((prev, curr) => Math.abs(curr - preferredScale) < Math.abs(prev - preferredScale) ? curr : prev);
    }
    const scaleSuffix = scale !== 1 ? `@${scale}x` : "";
    uri = asset ? `${asset.httpServerLocation}/${asset.name}${scaleSuffix}.${asset.type}` : "";
  } else typeof source == "string" ? uri = source : source && typeof source.uri == "string" && (uri = source.uri);
  if (uri) {
    const match = uri.match(svgDataUriPattern);
    if (match) {
      const [, prefix, svg] = match, encodedSvg = encodeURIComponent(svg);
      return `${prefix}${encodedSvg}`;
    }
  }
  return uri;
}
const Image$1 = React__namespace.forwardRef((props, ref) => {
  const _a = props, {
    accessibilityLabel,
    blurRadius,
    defaultSource,
    draggable,
    onError,
    onLayout,
    onLoad,
    onLoadEnd,
    onLoadStart,
    pointerEvents,
    source,
    style
  } = _a, rest = __objRest(_a, [
    "accessibilityLabel",
    "blurRadius",
    "defaultSource",
    "draggable",
    "onError",
    "onLayout",
    "onLoad",
    "onLoadEnd",
    "onLoadStart",
    "pointerEvents",
    "source",
    "style"
  ]);
  const [state, updateState] = React__namespace.useState(() => {
    const uri2 = resolveAssetUri(source);
    return uri2 != null && ImageLoader.has(uri2) ? LOADED : IDLE;
  }), [layout, updateLayout] = React__namespace.useState({}), hasTextAncestor = React__namespace.useContext(TextAncestorContext), hiddenImageRef = React__namespace.useRef(null), filterRef = React__namespace.useRef(_filterId++), requestRef = React__namespace.useRef(null), shouldDisplaySource = state === LOADED || state === LOADING && defaultSource == null, [flatStyle, _resizeMode, filter, tintColor] = getFlatStyle({}, blurRadius, filterRef.current), resizeMode = props.resizeMode || _resizeMode || "cover", selectedSource = shouldDisplaySource ? source : defaultSource, displayImageUri = resolveAssetUri(selectedSource), imageSizeStyle = resolveAssetDimensions(selectedSource), backgroundImage = displayImageUri ? `url("${displayImageUri}")` : null, backgroundSize = getBackgroundSize(), hiddenImage = displayImageUri ? createElement("img", {
    alt: accessibilityLabel || "",
    style: styles$3.accessibilityImage$raw,
    draggable: draggable || false,
    ref: hiddenImageRef,
    src: displayImageUri
  }) : null;
  function getBackgroundSize() {
    if (hiddenImageRef.current != null && (resizeMode === "center" || resizeMode === "repeat")) {
      const {
        naturalHeight,
        naturalWidth
      } = hiddenImageRef.current, {
        height,
        width
      } = layout;
      if (naturalHeight && naturalWidth && height && width) {
        const scaleFactor = Math.min(1, width / naturalWidth, height / naturalHeight), x = Math.ceil(scaleFactor * naturalWidth), y = Math.ceil(scaleFactor * naturalHeight);
        return `${x}px ${y}px`;
      }
    }
  }
  function handleLayout(e2) {
    if (resizeMode === "center" || resizeMode === "repeat" || onLayout) {
      const {
        layout: layout2
      } = e2.nativeEvent;
      onLayout && onLayout(e2), updateLayout(layout2);
    }
  }
  const uri = resolveAssetUri(source);
  return React__namespace.useEffect(() => {
    abortPendingRequest(), uri != null && (updateState(LOADING), onLoadStart && onLoadStart(), requestRef.current = ImageLoader.load(uri, function(e2) {
      updateState(LOADED), onLoad && onLoad(e2), onLoadEnd && onLoadEnd();
    }, function() {
      updateState(ERRORED), onError && onError({
        nativeEvent: {
          error: `Failed to load resource ${uri} (404)`
        }
      }), onLoadEnd && onLoadEnd();
    }));
    function abortPendingRequest() {
      requestRef.current != null && (ImageLoader.abort(requestRef.current), requestRef.current = null);
    }
    return abortPendingRequest;
  }, [uri, requestRef, updateState, onError, onLoad, onLoadEnd, onLoadStart]), /* @__PURE__ */ jsxRuntimeExports.jsxs(View$1, __spreadProps(__spreadValues({}, rest), {
    accessibilityLabel,
    onLayout: handleLayout,
    pointerEvents,
    ref,
    style: [style, styles$3.root, hasTextAncestor && styles$3.inline, imageSizeStyle, flatStyle],
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(View$1, {
      style: [...[].concat(styles$3.image), resizeModeStyles[resizeMode], {
        backgroundImage,
        filter
      }, backgroundSize != null && {
        backgroundSize
      }],
      suppressHydrationWarning: true
    }), hiddenImage, createTintColorSVG(tintColor, filterRef.current)]
  }));
});
Image$1.displayName = "Image";
const ImageWithStatics = Image$1;
ImageWithStatics.getSize = function(uri, success, failure) {
  ImageLoader.getSize(uri, success, failure);
};
ImageWithStatics.prefetch = function(uri) {
  return ImageLoader.prefetch(uri);
};
ImageWithStatics.queryCache = function(uris) {
  return ImageLoader.queryCache(uris);
};
const styles$3 = StyleSheet.create({
  root: {
    flexBasis: "auto",
    overflow: "hidden",
    zIndex: 0
  },
  inline: {
    display: "inline-flex"
  },
  image: __spreadProps(__spreadValues({}, StyleSheet.absoluteFillObject), {
    backgroundColor: "transparent",
    backgroundPosition: "center",
    backgroundRepeat: "no-repeat",
    backgroundSize: "cover",
    height: "100%",
    width: "100%",
    zIndex: -1
  }),
  accessibilityImage$raw: __spreadProps(__spreadValues({}, StyleSheet.absoluteFillObject), {
    height: "100%",
    opacity: 0,
    width: "100%",
    zIndex: -1
  })
}), resizeModeStyles = StyleSheet.create({
  center: {
    backgroundSize: "auto"
  },
  contain: {
    backgroundSize: "contain"
  },
  cover: {
    backgroundSize: "cover"
  },
  none: {
    backgroundPosition: "0",
    backgroundSize: "auto"
  },
  repeat: {
    backgroundPosition: "0",
    backgroundRepeat: "repeat",
    backgroundSize: "auto"
  },
  stretch: {
    backgroundSize: "100% 100%"
  }
});
function normalizeScrollEvent(e2) {
  return {
    nativeEvent: {
      contentOffset: {
        get x() {
          return e2.target.scrollLeft;
        },
        get y() {
          return e2.target.scrollTop;
        }
      },
      contentSize: {
        get height() {
          return e2.target.scrollHeight;
        },
        get width() {
          return e2.target.scrollWidth;
        }
      },
      layoutMeasurement: {
        get height() {
          return e2.target.offsetHeight;
        },
        get width() {
          return e2.target.offsetWidth;
        }
      }
    },
    timeStamp: Date.now()
  };
}
function shouldEmitScrollEvent(lastTick, eventThrottle) {
  const timeSinceLastTick = Date.now() - lastTick;
  return eventThrottle > 0 && timeSinceLastTick >= eventThrottle;
}
const ScrollViewBase = React__namespace.forwardRef((props, forwardedRef) => {
  const _a = props, {
    onScroll,
    onTouchMove,
    onWheel,
    scrollEnabled = true,
    scrollEventThrottle = 0,
    showsHorizontalScrollIndicator,
    showsVerticalScrollIndicator,
    style
  } = _a, rest = __objRest(_a, [
    "onScroll",
    "onTouchMove",
    "onWheel",
    "scrollEnabled",
    "scrollEventThrottle",
    "showsHorizontalScrollIndicator",
    "showsVerticalScrollIndicator",
    "style"
  ]), scrollState = React__namespace.useRef({
    isScrolling: false,
    scrollLastTick: 0
  }), scrollTimeout = React__namespace.useRef(null), scrollRef = React__namespace.useRef(null);
  function createPreventableScrollHandler(handler) {
    return (e2) => {
      scrollEnabled && handler && handler(e2);
    };
  }
  function handleScroll(e2) {
    e2.stopPropagation(), e2.target === scrollRef.current && (e2.persist(), scrollTimeout.current != null && clearTimeout(scrollTimeout.current), scrollTimeout.current = setTimeout(() => {
      handleScrollEnd(e2);
    }, 100), scrollState.current.isScrolling ? shouldEmitScrollEvent(scrollState.current.scrollLastTick, scrollEventThrottle) && handleScrollTick(e2) : handleScrollStart(e2));
  }
  function handleScrollStart(e2) {
    scrollState.current.isScrolling = true, handleScrollTick(e2);
  }
  function handleScrollTick(e2) {
    scrollState.current.scrollLastTick = Date.now(), onScroll && onScroll(normalizeScrollEvent(e2));
  }
  function handleScrollEnd(e2) {
    scrollState.current.isScrolling = false, onScroll && onScroll(normalizeScrollEvent(e2));
  }
  const hideScrollbar = showsHorizontalScrollIndicator === false || showsVerticalScrollIndicator === false;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(View$1, __spreadProps(__spreadValues({}, rest), {
    onScroll: handleScroll,
    onTouchMove: createPreventableScrollHandler(onTouchMove),
    onWheel: createPreventableScrollHandler(onWheel),
    ref: useMergeRefs(scrollRef, forwardedRef),
    style: [
      style,
      // @ts-ignore
      !scrollEnabled && styles$2.scrollDisabled,
      // @ts-ignore
      hideScrollbar && styles$2.hideScrollbar
    ]
  }));
}), styles$2 = {
  scrollDisabled: {
    overflowX: "hidden",
    overflowY: "hidden",
    touchAction: "none"
  },
  hideScrollbar: {
    scrollbarWidth: "none"
  }
};
const emptyObject = {}, IS_ANIMATING_TOUCH_START_THRESHOLD_MS = 16;
let ScrollView$1 = class ScrollView extends React.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "_scrollNodeRef");
    __publicField(this, "_innerViewRef");
    __publicField(this, "keyboardWillOpenTo", null);
    __publicField(this, "additionalScrollOffset", 0);
    __publicField(this, "preventNegativeScrollOffset", false);
    __publicField(this, "isTouching", false);
    __publicField(this, "lastMomentumScrollBeginTime", 0);
    __publicField(this, "lastMomentumScrollEndTime", 0);
    // Reset to false every time becomes responder. This is used to:
    // - Determine if the scroll view has been scrolled and therefore should
    // refuse to give up its responder lock.
    // - Determine if releasing should dismiss the keyboard when we are in
    // tap-to-dismiss mode (!this.props.keyboardShouldPersistTaps).
    __publicField(this, "observedScrollSinceBecomingResponder", false);
    __publicField(this, "becameResponderWhileAnimating", false);
    __publicField(this, "flashScrollIndicators", () => {
      this.scrollResponderFlashScrollIndicators();
    });
    /**
     * Scrolls to a given x, y offset, either immediately or with a smooth animation.
     * Syntax:
     *
     * scrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})
     *
     * Note: The weird argument signature is due to the fact that, for historical reasons,
     * the function also accepts separate arguments as as alternative to the options object.
     * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.
     */
    __publicField(this, "scrollTo", (y, x, animated) => {
      typeof y == "number" ? console.warn("`scrollTo(y, x, animated)` is deprecated. Use `scrollTo({x: 5, y: 5, animated: true})` instead.") : {
        x,
        y,
        animated
      } = y || emptyObject, this.scrollResponderScrollTo({
        x: x || 0,
        y: y || 0,
        animated: animated !== false
      });
    });
    /**
     * If this is a vertical ScrollView scrolls to the bottom.
     * If this is a horizontal ScrollView scrolls to the right.
     *
     * Use `scrollToEnd({ animated: true })` for smooth animated scrolling,
     * `scrollToEnd({ animated: false })` for immediate scrolling.
     * If no options are passed, `animated` defaults to true.
     */
    __publicField(this, "scrollToEnd", (options) => {
      const animated = (options && options.animated) !== false, {
        horizontal
      } = this.props, scrollResponderNode = this.getScrollableNode(), x = horizontal ? scrollResponderNode.scrollWidth : 0, y = horizontal ? 0 : scrollResponderNode.scrollHeight;
      this.scrollResponderScrollTo({
        x,
        y,
        animated
      });
    });
    /**
     * A helper function to scroll to a specific point in the scrollview.
     * This is currently used to help focus on child textviews, but can also
     * be used to quickly scroll to any element we want to focus. Syntax:
     *
     * scrollResponderScrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})
     *
     * Note: The weird argument signature is due to the fact that, for historical reasons,
     * the function also accepts separate arguments as as alternative to the options object.
     * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.
     */
    __publicField(this, "scrollResponderScrollTo", (x, y, animated) => {
      typeof x == "number" ? console.warn("`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead.") : {
        x,
        y,
        animated
      } = x || emptyObject;
      const node = this.getScrollableNode(), left = x || 0, top = y || 0;
      node != null && (typeof node.scroll == "function" ? node.scroll({
        top,
        left,
        behavior: animated ? "smooth" : "auto"
      }) : (node.scrollLeft = left, node.scrollTop = top));
    });
    /**
     * A helper function to zoom to a specific rect in the scrollview. The argument has the shape
     * {x: number; y: number; width: number; height: number; animated: boolean = true}
     *
     * @platform ios
     */
    __publicField(this, "scrollResponderZoomTo", (rect, animated) => {
      invariant("zoomToRect is not implemented");
    });
    /**
     * This method should be used as the callback to onFocus in a TextInputs'
     * parent view. Note that any module using this mixin needs to return
     * the parent view's ref in getScrollViewRef() in order to use this method.
     * @param {any} nodeHandle The TextInput node handle
     * @param {number} additionalOffset The scroll view's top "contentInset".
     *        Default is 0.
     * @param {bool} preventNegativeScrolling Whether to allow pulling the content
     *        down to make it meet the keyboard's top. Default is false.
     */
    __publicField(this, "scrollResponderScrollNativeHandleToKeyboard", (nodeHandle, additionalOffset, preventNegativeScrollOffset) => {
      this.additionalScrollOffset = additionalOffset || 0, this.preventNegativeScrollOffset = !!preventNegativeScrollOffset, UIManager.measureLayout(nodeHandle, this.getInnerViewNode(), this.scrollResponderTextInputFocusError, this.scrollResponderInputMeasureAndScrollToKeyboard);
    });
    /**
     * The calculations performed here assume the scroll view takes up the entire
     * screen - even if has some content inset. We then measure the offsets of the
     * keyboard, and compensate both for the scroll view's "contentInset".
     *
     * @param {number} left Position of input w.r.t. table view.
     * @param {number} top Position of input w.r.t. table view.
     * @param {number} width Width of the text input.
     * @param {number} height Height of the text input.
     */
    __publicField(this, "scrollResponderInputMeasureAndScrollToKeyboard", (left, top, width, height) => {
      let keyboardScreenY = Dimensions.get("window").height;
      this.keyboardWillOpenTo && (keyboardScreenY = this.keyboardWillOpenTo.endCoordinates.screenY);
      let scrollOffsetY = top - keyboardScreenY + height + this.additionalScrollOffset;
      this.preventNegativeScrollOffset && (scrollOffsetY = Math.max(0, scrollOffsetY)), this.scrollResponderScrollTo({
        x: 0,
        y: scrollOffsetY,
        animated: true
      }), this.additionalScrollOffset = 0, this.preventNegativeScrollOffset = false;
    });
    /**
     * Warning, this may be called several times for a single keyboard opening.
     * It's best to store the information in this method and then take any action
     * at a later point (either in `keyboardDidShow` or other).
     *
     * Here's the order that events occur in:
     * - focus
     * - willShow {startCoordinates, endCoordinates} several times
     * - didShow several times
     * - blur
     * - willHide {startCoordinates, endCoordinates} several times
     * - didHide several times
     *
     * The `ScrollResponder` providesModule callbacks for each of these events.
     * Even though any user could have easily listened to keyboard events
     * themselves, using these `props` callbacks ensures that ordering of events
     * is consistent - and not dependent on the order that the keyboard events are
     * subscribed to. This matters when telling the scroll view to scroll to where
     * the keyboard is headed - the scroll responder better have been notified of
     * the keyboard destination before being instructed to scroll to where the
     * keyboard will be. Stick to the `ScrollResponder` callbacks, and everything
     * will work.
     *
     * WARNING: These callbacks will fire even if a keyboard is displayed in a
     * different navigation pane. Filter out the events to determine if they are
     * relevant to you. (For example, only if you receive these callbacks after
     * you had explicitly focused a node etc).
     */
    __publicField(this, "scrollResponderKeyboardWillShow", (e2) => {
      this.keyboardWillOpenTo = e2, this.props.onKeyboardWillShow && this.props.onKeyboardWillShow(e2);
    });
    __publicField(this, "scrollResponderKeyboardWillHide", (e2) => {
      this.keyboardWillOpenTo = null, this.props.onKeyboardWillHide && this.props.onKeyboardWillHide(e2);
    });
    __publicField(this, "scrollResponderKeyboardDidShow", (e2) => {
      e2 && (this.keyboardWillOpenTo = e2), this.props.onKeyboardDidShow && this.props.onKeyboardDidShow(e2);
    });
    __publicField(this, "scrollResponderKeyboardDidHide", (e2) => {
      this.keyboardWillOpenTo = null, this.props.onKeyboardDidHide && this.props.onKeyboardDidHide(e2);
    });
  }
  /**
   * Returns a reference to the underlying scroll responder, which supports
   * operations like `scrollTo`. All ScrollView-like components should
   * implement this method so that they can be composed while providing access
   * to the underlying scroll responder's methods.
   */
  getScrollResponder() {
    return this;
  }
  getScrollableNode() {
    return this._scrollNodeRef;
  }
  getInnerViewRef() {
    return this._innerViewRef;
  }
  getInnerViewNode() {
    return this._innerViewRef;
  }
  getNativeScrollRef() {
    return this._scrollNodeRef;
  }
  render() {
    const _a = this.props, {
      contentContainerStyle,
      horizontal,
      onContentSizeChange,
      refreshControl,
      stickyHeaderIndices,
      pagingEnabled,
      forwardedRef: forwardedRef,
      keyboardDismissMode,
      onScroll,
      centerContent
    } = _a, other = __objRest(_a, [
      "contentContainerStyle",
      "horizontal",
      "onContentSizeChange",
      "refreshControl",
      "stickyHeaderIndices",
      "pagingEnabled",
      /* eslint-disable */
      "forwardedRef",
      "keyboardDismissMode",
      "onScroll",
      "centerContent"
    ]);
    let contentSizeChangeProps = {};
    onContentSizeChange && (contentSizeChangeProps = {
      onLayout: this._handleContentOnLayout.bind(this)
    });
    const hasStickyHeaderIndices = !horizontal && Array.isArray(stickyHeaderIndices), children = hasStickyHeaderIndices || pagingEnabled ? React.Children.map(this.props.children, (child, i) => {
      const isSticky = hasStickyHeaderIndices && stickyHeaderIndices.indexOf(i) > -1;
      return child != null && (isSticky || pagingEnabled) ? /* @__PURE__ */ jsxRuntimeExports.jsx(View$1, {
        style: StyleSheet.compose(isSticky && styles$1.stickyHeader, pagingEnabled && styles$1.pagingEnabledChild),
        children: child
      }) : child;
    }) : this.props.children, contentContainer = /* @__PURE__ */ jsxRuntimeExports.jsx(View$1, __spreadProps(__spreadValues({}, contentSizeChangeProps), {
      collapsable: false,
      ref: this._setInnerViewRef.bind(this),
      style: [horizontal && styles$1.contentContainerHorizontal, centerContent && styles$1.contentContainerCenterContent, contentContainerStyle],
      children
    })), baseStyle = horizontal ? styles$1.baseHorizontal : styles$1.baseVertical, pagingEnabledStyle = horizontal ? styles$1.pagingEnabledHorizontal : styles$1.pagingEnabledVertical, props = __spreadProps(__spreadValues({}, other), {
      style: [baseStyle, pagingEnabled && pagingEnabledStyle, this.props.style],
      onTouchStart: this.scrollResponderHandleTouchStart.bind(this),
      onTouchMove: this.scrollResponderHandleTouchMove.bind(this),
      onTouchEnd: this.scrollResponderHandleTouchEnd.bind(this),
      onScrollBeginDrag: this.scrollResponderHandleScrollBeginDrag.bind(this),
      onScrollEndDrag: this.scrollResponderHandleScrollEndDrag.bind(this),
      onMomentumScrollBegin: this.scrollResponderHandleMomentumScrollBegin.bind(this),
      onMomentumScrollEnd: this.scrollResponderHandleMomentumScrollEnd.bind(this),
      onStartShouldSetResponder: this.scrollResponderHandleStartShouldSetResponder.bind(this),
      onStartShouldSetResponderCapture: this.scrollResponderHandleStartShouldSetResponderCapture.bind(this),
      onScrollShouldSetResponder: this.scrollResponderHandleScrollShouldSetResponder.bind(this),
      onScroll: this._handleScroll.bind(this),
      onResponderGrant: this.scrollResponderHandleResponderGrant.bind(this),
      onResponderTerminationRequest: this.scrollResponderHandleTerminationRequest.bind(this),
      onResponderRelease: this.scrollResponderHandleResponderRelease.bind(this),
      onResponderReject: this.scrollResponderHandleResponderReject.bind(this),
      onResponderTerminate: this.scrollResponderHandleTerminate.bind(this)
    }), ScrollViewClass = ScrollViewBase;
    invariant(ScrollViewClass !== void 0, "ScrollViewClass must not be undefined");
    const scrollView = /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollViewClass, __spreadProps(__spreadValues({}, props), {
      ref: this._setScrollNodeRef.bind(this),
      children: contentContainer
    }));
    return refreshControl ? React.cloneElement(refreshControl, {
      style: props.style
    }, scrollView) : scrollView;
  }
  _handleContentOnLayout(e2) {
    var _a, _b;
    const {
      width,
      height
    } = e2.nativeEvent.layout;
    (_b = (_a = this.props).onContentSizeChange) == null ? void 0 : _b.call(_a, width, height);
  }
  _handleScroll(e2) {
    this.props.keyboardDismissMode === "on-drag" && dismissKeyboard(), this.scrollResponderHandleScroll(e2);
  }
  _setInnerViewRef(node) {
    this._innerViewRef = node;
  }
  _setScrollNodeRef(node) {
    this._scrollNodeRef = node, node != null && (node.getScrollResponder = this.getScrollResponder, node.getInnerViewNode = this.getInnerViewNode, node.getInnerViewRef = this.getInnerViewRef, node.getNativeScrollRef = this.getNativeScrollRef, node.getScrollableNode = this.getScrollableNode, node.scrollTo = this.scrollTo, node.scrollToEnd = this.scrollToEnd, node.flashScrollIndicators = this.flashScrollIndicators, node.scrollResponderZoomTo = this.scrollResponderZoomTo, node.scrollResponderScrollNativeHandleToKeyboard = this.scrollResponderScrollNativeHandleToKeyboard), mergeRefs(this.props.forwardedRef)(node);
  }
  /**
   * Invoke this from an `onScroll` event.
   */
  scrollResponderHandleScrollShouldSetResponder() {
    return this.isTouching;
  }
  /**
   * Merely touch starting is not sufficient for a scroll view to become the
   * responder. Being the "responder" means that the very next touch move/end
   * event will result in an action/movement.
   *
   * Invoke this from an `onStartShouldSetResponder` event.
   *
   * `onStartShouldSetResponder` is used when the next move/end will trigger
   * some UI movement/action, but when you want to yield priority to views
   * nested inside of the view.
   *
   * There may be some cases where scroll views actually should return `true`
   * from `onStartShouldSetResponder`: Any time we are detecting a standard tap
   * that gives priority to nested views.
   *
   * - If a single tap on the scroll view triggers an action such as
   *   recentering a map style view yet wants to give priority to interaction
   *   views inside (such as dropped pins or labels), then we would return true
   *   from this method when there is a single touch.
   *
   * - Similar to the previous case, if a two finger "tap" should trigger a
   *   zoom, we would check the `touches` count, and if `>= 2`, we would return
   *   true.
   *
   */
  scrollResponderHandleStartShouldSetResponder() {
    return false;
  }
  /**
   * There are times when the scroll view wants to become the responder
   * (meaning respond to the next immediate `touchStart/touchEnd`), in a way
   * that *doesn't* give priority to nested views (hence the capture phase):
   *
   * - Currently animating.
   * - Tapping anywhere that is not the focused input, while the keyboard is
   *   up (which should dismiss the keyboard).
   *
   * Invoke this from an `onStartShouldSetResponderCapture` event.
   */
  scrollResponderHandleStartShouldSetResponderCapture(e2) {
    return this.scrollResponderIsAnimating();
  }
  /**
   * Invoke this from an `onResponderReject` event.
   *
   * Some other element is not yielding its role as responder. Normally, we'd
   * just disable the `UIScrollView`, but a touch has already began on it, the
   * `UIScrollView` will not accept being disabled after that. The easiest
   * solution for now is to accept the limitation of disallowing this
   * altogether. To improve this, find a way to disable the `UIScrollView` after
   * a touch has already started.
   */
  scrollResponderHandleResponderReject() {
    warning();
  }
  /**
   * We will allow the scroll view to give up its lock iff it acquired the lock
   * during an animation. This is a very useful default that happens to satisfy
   * many common user experiences.
   *
   * - Stop a scroll on the left edge, then turn that into an outer view's
   *   backswipe.
   * - Stop a scroll mid-bounce at the top, continue pulling to have the outer
   *   view dismiss.
   * - However, without catching the scroll view mid-bounce (while it is
   *   motionless), if you drag far enough for the scroll view to become
   *   responder (and therefore drag the scroll view a bit), any backswipe
   *   navigation of a swipe gesture higher in the view hierarchy, should be
   *   rejected.
   */
  scrollResponderHandleTerminationRequest() {
    return !this.observedScrollSinceBecomingResponder;
  }
  /**
   * Invoke this from an `onTouchEnd` event.
   *
   * @param {SyntheticEvent} e Event.
   */
  scrollResponderHandleTouchEnd(e2) {
    const nativeEvent = e2.nativeEvent;
    this.isTouching = nativeEvent.touches.length !== 0, this.props.onTouchEnd && this.props.onTouchEnd(e2);
  }
  /**
   * Invoke this from an `onResponderRelease` event.
   */
  scrollResponderHandleResponderRelease(e2) {
    this.props.onResponderRelease && this.props.onResponderRelease(e2);
    const currentlyFocusedTextInput = TextInputState.currentlyFocusedField();
    !this.props.keyboardShouldPersistTaps && currentlyFocusedTextInput != null && e2.target !== currentlyFocusedTextInput && !this.observedScrollSinceBecomingResponder && !this.becameResponderWhileAnimating && (this.props.onScrollResponderKeyboardDismissed && this.props.onScrollResponderKeyboardDismissed(e2), TextInputState.blurTextInput(currentlyFocusedTextInput));
  }
  scrollResponderHandleScroll(e2) {
    this.observedScrollSinceBecomingResponder = true, this.props.onScroll && this.props.onScroll(e2);
  }
  /**
   * Invoke this from an `onResponderGrant` event.
   */
  scrollResponderHandleResponderGrant(e2) {
    this.observedScrollSinceBecomingResponder = false, this.props.onResponderGrant && this.props.onResponderGrant(e2), this.becameResponderWhileAnimating = this.scrollResponderIsAnimating();
  }
  /**
   * Unfortunately, `onScrollBeginDrag` also fires when *stopping* the scroll
   * animation, and there's not an easy way to distinguish a drag vs. stopping
   * momentum.
   *
   * Invoke this from an `onScrollBeginDrag` event.
   */
  scrollResponderHandleScrollBeginDrag(e2) {
    this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e2);
  }
  /**
   * Invoke this from an `onScrollEndDrag` event.
   */
  scrollResponderHandleScrollEndDrag(e2) {
    this.props.onScrollEndDrag && this.props.onScrollEndDrag(e2);
  }
  /**
   * Invoke this from an `onMomentumScrollBegin` event.
   */
  scrollResponderHandleMomentumScrollBegin(e2) {
    this.lastMomentumScrollBeginTime = Date.now(), this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e2);
  }
  /**
   * Invoke this from an `onMomentumScrollEnd` event.
   */
  scrollResponderHandleMomentumScrollEnd(e2) {
    this.lastMomentumScrollEndTime = Date.now(), this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e2);
  }
  /**
   * Invoke this from an `onTouchStart` event.
   *
   * Since we know that the `SimpleEventPlugin` occurs later in the plugin
   * order, after `ResponderEventPlugin`, we can detect that we were *not*
   * permitted to be the responder (presumably because a contained view became
   * responder). The `onResponderReject` won't fire in that case - it only
   * fires when a *current* responder rejects our request.
   *
   * @param {SyntheticEvent} e Touch Start event.
   */
  scrollResponderHandleTouchStart(e2) {
    this.isTouching = true, this.props.onTouchStart && this.props.onTouchStart(e2);
  }
  /**
   * Invoke this from an `onTouchMove` event.
   *
   * Since we know that the `SimpleEventPlugin` occurs later in the plugin
   * order, after `ResponderEventPlugin`, we can detect that we were *not*
   * permitted to be the responder (presumably because a contained view became
   * responder). The `onResponderReject` won't fire in that case - it only
   * fires when a *current* responder rejects our request.
   *
   * @param {SyntheticEvent} e Touch Start event.
   */
  scrollResponderHandleTouchMove(e2) {
    this.props.onTouchMove && this.props.onTouchMove(e2);
  }
  scrollResponderHandleTerminate(e2) {
    this.props.onResponderTerminate && this.props.onResponderTerminate(e2);
  }
  /**
   * A helper function for this class that lets us quickly determine if the
   * view is currently animating. This is particularly useful to know when
   * a touch has just started or ended.
   */
  scrollResponderIsAnimating() {
    return Date.now() - this.lastMomentumScrollEndTime < IS_ANIMATING_TOUCH_START_THRESHOLD_MS || this.lastMomentumScrollEndTime < this.lastMomentumScrollBeginTime;
  }
  /**
   * Displays the scroll indicators momentarily.
   */
  scrollResponderFlashScrollIndicators() {
  }
  scrollResponderTextInputFocusError(e2) {
    console.error("Error measuring text field: ", e2);
  }
};
const commonStyle = {
  flexGrow: 1,
  flexShrink: 1,
  // Enable hardware compositing in modern browsers.
  // Creates a new layer with its own backing surface that can significantly
  // improve scroll performance.
  transform: [{
    translateZ: 0
  }],
  // iOS native scrolling
  WebkitOverflowScrolling: "touch"
}, styles$1 = {
  baseVertical: __spreadProps(__spreadValues({}, commonStyle), {
    flexDirection: "column",
    overflowX: "hidden",
    overflowY: "auto"
  }),
  baseHorizontal: __spreadProps(__spreadValues({}, commonStyle), {
    flexDirection: "row",
    overflowX: "auto",
    overflowY: "hidden"
  }),
  contentContainerHorizontal: {
    flexDirection: "row"
  },
  contentContainerCenterContent: {
    justifyContent: "center",
    flexGrow: 1
  },
  stickyHeader: {
    position: "sticky",
    top: 0,
    zIndex: 10
  },
  pagingEnabledHorizontal: {
    scrollSnapType: "x mandatory"
  },
  pagingEnabledVertical: {
    scrollSnapType: "y mandatory"
  },
  pagingEnabledChild: {
    scrollSnapAlign: "start"
  }
}, ForwardedScrollView = React.forwardRef((props, forwardedRef) => /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollView$1, __spreadProps(__spreadValues({}, props), {
  forwardedRef
})));
ForwardedScrollView.displayName = "ScrollView";
const isSelectionStale = (node, selection) => {
  const {
    selectionEnd,
    selectionStart
  } = node, {
    start,
    end
  } = selection;
  return start !== selectionStart || end !== selectionEnd;
}, setSelection = (node, selection) => {
  if (isSelectionStale(node, selection)) {
    const {
      start,
      end
    } = selection;
    try {
      node.setSelectionRange(start, end || start);
    } catch (e2) {
    }
  }
}, forwardPropsList = Object.assign({}, forwardedProps.defaultProps, forwardedProps.accessibilityProps, forwardedProps.clickProps, forwardedProps.focusProps, forwardedProps.keyboardProps, forwardedProps.mouseProps, forwardedProps.touchProps, forwardedProps.styleProps, {
  autoCapitalize: true,
  className: true,
  autoComplete: true,
  autoCorrect: true,
  autoFocus: true,
  defaultValue: true,
  disabled: true,
  lang: true,
  maxLength: true,
  onChange: true,
  onScroll: true,
  placeholder: true,
  pointerEvents: true,
  readOnly: true,
  rows: true,
  spellCheck: true,
  value: true,
  type: true
}), pickProps = (props) => pick(props, forwardPropsList), useIsomorphicLayoutEffect$1 = typeof window > "u" ? React__namespace.useEffect : React__namespace.useLayoutEffect;
function isEventComposing(nativeEvent) {
  return nativeEvent.isComposing || nativeEvent.keyCode === 229;
}
let focusTimeout = null;
const TextInput = React__namespace.forwardRef((props, forwardedRef) => {
  const {
    autoCapitalize = "sentences",
    autoComplete,
    autoCompleteType,
    autoCorrect = true,
    blurOnSubmit,
    clearTextOnFocus,
    dir,
    editable,
    enterKeyHint,
    inputMode = "text",
    keyboardType,
    multiline = false,
    numberOfLines,
    onBlur,
    onChange,
    onChangeText,
    onContentSizeChange,
    onFocus,
    onKeyPress,
    onLayout,
    onMoveShouldSetResponder,
    onMoveShouldSetResponderCapture,
    onResponderEnd,
    onResponderGrant,
    onResponderMove,
    onResponderReject,
    onResponderRelease,
    onResponderStart,
    onResponderTerminate,
    onResponderTerminationRequest,
    onScrollShouldSetResponder,
    onScrollShouldSetResponderCapture,
    onSelectionChange,
    onSelectionChangeShouldSetResponder,
    onSelectionChangeShouldSetResponderCapture,
    onStartShouldSetResponder,
    onStartShouldSetResponderCapture,
    onSubmitEditing,
    placeholderTextColor,
    readOnly = false,
    returnKeyType,
    rows = 1,
    secureTextEntry = false,
    selection,
    selectTextOnFocus,
    showSoftInputOnFocus,
    caretHidden,
    spellCheck
  } = props;
  let type, _inputMode;
  if (inputMode != null) _inputMode = inputMode, inputMode === "email" ? type = "email" : inputMode === "tel" ? type = "tel" : inputMode === "search" ? type = "search" : inputMode === "url" ? type = "url" : type = "text";
  else if (keyboardType != null) switch (keyboardType) {
    case "email-address":
      type = "email";
      break;
    case "number-pad":
    case "numeric":
      _inputMode = "numeric";
      break;
    case "decimal-pad":
      _inputMode = "decimal";
      break;
    case "phone-pad":
      type = "tel";
      break;
    case "search":
    case "web-search":
      type = "search";
      break;
    case "url":
      type = "url";
      break;
    default:
      type = "text";
  }
  secureTextEntry && (type = "password");
  const dimensions2 = React__namespace.useRef({
    height: null,
    width: null
  }), hostRef = React__namespace.useRef(null), handleContentSizeChange = React__namespace.useCallback((hostNode) => {
    if (multiline && onContentSizeChange && hostNode != null) {
      const newHeight = hostNode.scrollHeight, newWidth = hostNode.scrollWidth;
      (newHeight !== dimensions2.current.height || newWidth !== dimensions2.current.width) && (dimensions2.current.height = newHeight, dimensions2.current.width = newWidth, onContentSizeChange({
        nativeEvent: {
          contentSize: {
            height: dimensions2.current.height,
            width: dimensions2.current.width
          }
        }
      }));
    }
  }, [multiline, onContentSizeChange]), imperativeRef = React__namespace.useMemo(() => (hostNode) => {
    hostNode != null && (hostNode.clear = () => {
      hostNode != null && (hostNode.value = "");
    }, hostNode.isFocused = () => hostNode != null && TextInputState.currentlyFocusedField() === hostNode, handleContentSizeChange(hostNode));
  }, [handleContentSizeChange]);
  function handleBlur(e2) {
    TextInputState._currentlyFocusedNode = null, onBlur && (e2.nativeEvent.text = e2.target.value, onBlur(e2));
  }
  function handleChange(e2) {
    const hostNode = e2.target, text = hostNode.value;
    e2.nativeEvent.text = text, handleContentSizeChange(hostNode), onChange && onChange(e2), onChangeText && onChangeText(text);
  }
  function handleFocus(e2) {
    const hostNode = e2.target;
    onFocus && (e2.nativeEvent.text = hostNode.value, onFocus(e2)), hostNode != null && (TextInputState._currentlyFocusedNode = hostNode, clearTextOnFocus && (hostNode.value = ""), selectTextOnFocus && (focusTimeout != null && clearTimeout(focusTimeout), focusTimeout = setTimeout(() => {
      hostNode == null ? void 0 : hostNode.select();
    }, 0)));
  }
  function handleKeyDown(e2) {
    const hostNode = e2.target;
    e2.stopPropagation();
    const shouldBlurOnSubmit = blurOnSubmit != null ? blurOnSubmit : !multiline, nativeEvent = e2.nativeEvent, isComposing = isEventComposing(nativeEvent);
    onKeyPress && onKeyPress(e2), e2.key === "Enter" && !e2.shiftKey && // Do not call submit if composition is occuring.
    !isComposing && !e2.isDefaultPrevented() && ((blurOnSubmit || !multiline) && onSubmitEditing && (e2.preventDefault(), nativeEvent.text = e2.target.value, onSubmitEditing(e2)), shouldBlurOnSubmit && hostNode != null && setTimeout(() => hostNode.blur(), 0));
  }
  function handleSelectionChange(e2) {
    if (onSelectionChange) try {
      const node = e2.target, {
        selectionStart,
        selectionEnd
      } = node;
      e2.nativeEvent.selection = {
        start: selectionStart,
        end: selectionEnd
      }, e2.nativeEvent.text = e2.target.value, onSelectionChange(e2);
    } catch (e3) {
    }
  }
  useIsomorphicLayoutEffect$1(() => {
    const node = hostRef.current;
    node != null && selection != null && setSelection(node, selection), document.activeElement === node && (TextInputState._currentlyFocusedNode = node);
  }, [hostRef, selection]);
  const component = multiline ? "textarea" : "input";
  useElementLayout(hostRef, onLayout), useResponderEvents(hostRef, {
    onMoveShouldSetResponder,
    onMoveShouldSetResponderCapture,
    onResponderEnd,
    onResponderGrant,
    onResponderMove,
    onResponderReject,
    onResponderRelease,
    onResponderStart,
    onResponderTerminate,
    onResponderTerminationRequest,
    onScrollShouldSetResponder,
    onScrollShouldSetResponderCapture,
    onSelectionChangeShouldSetResponder,
    onSelectionChangeShouldSetResponderCapture,
    onStartShouldSetResponder,
    onStartShouldSetResponderCapture
  });
  const {
    direction: contextDirection
  } = useLocaleContext(), supportedProps = pickProps(props);
  supportedProps.autoCapitalize = autoCapitalize, supportedProps.autoComplete = autoComplete || autoCompleteType || "on", supportedProps.autoCorrect = autoCorrect ? "on" : "off", supportedProps.dir = dir !== void 0 ? dir : "auto", supportedProps.enterKeyHint = enterKeyHint || returnKeyType, supportedProps.inputMode = _inputMode, supportedProps.onBlur = handleBlur, supportedProps.onChange = handleChange, supportedProps.onFocus = handleFocus, supportedProps.onKeyDown = handleKeyDown, supportedProps.onSelect = handleSelectionChange, supportedProps.readOnly = readOnly === true || editable === false, supportedProps.rows = multiline ? rows != null ? rows : numberOfLines : 1, supportedProps.spellCheck = spellCheck != null ? spellCheck : autoCorrect, supportedProps.style = [{
    "--placeholderTextColor": placeholderTextColor
  }, styles.textinput$raw, styles.placeholder, props.style, caretHidden && styles.caretHidden], supportedProps.type = multiline ? void 0 : type, supportedProps.virtualkeyboardpolicy = showSoftInputOnFocus === false ? "manual" : "auto";
  const platformMethodsRef = usePlatformMethods(supportedProps), setRef2 = useMergeRefs(hostRef, platformMethodsRef, imperativeRef, forwardedRef);
  supportedProps.ref = setRef2;
  const langDirection = props.lang != null ? getLocaleDirection(props.lang) : null;
  props.dir || langDirection || contextDirection;
  return useCreateElement(component, supportedProps);
});
TextInput.displayName = "TextInput";
TextInput.State = TextInputState;
const styles = StyleSheet.create({
  textinput$raw: {
    MozAppearance: "textfield",
    WebkitAppearance: "none",
    appearance: "none"
  },
  placeholder: {
    placeholderTextColor: "var(--placeholderTextColor)"
  },
  caretHidden: {
    caretColor: "transparent"
  }
});
function useWindowDimensions$1() {
  const [dims, setDims] = React.useState(() => Dimensions.get("window"));
  return React.useEffect(() => {
    function handleChange({
      window: window2
    }) {
      window2 != null && setDims(window2);
    }
    return Dimensions.addEventListener("change", handleChange), setDims(Dimensions.get("window")), () => {
      Dimensions.removeEventListener("change", handleChange);
    };
  }, []), dims;
}
const RootTagContext = React.createContext(null);
var IS_REACT_19 = typeof React.use < "u", isWeb = false, isServer = false, isClient = false, useIsomorphicLayoutEffect = React.useLayoutEffect, isChrome = false, isWebTouchable = false, isTouchable = true, isAndroid = process.env.TEST_NATIVE_PLATFORM === "android", isIos = process.env.TEST_NATIVE_PLATFORM === "ios", platforms = {
  ios: "ios",
  android: "android"
}, currentPlatform = platforms[Platform.OS] || "native";
var isServerSide = false;
function useForceUpdate() {
  return React.useReducer(function(x) {
    return Math.random();
  }, 0)[1];
}
var LayoutGroupContext = /* @__PURE__ */ React.createContext({});
function useConstant(fn) {
  if (typeof document > "u") return React__namespace.useMemo(function() {
    return fn();
  }, []);
  var ref = React__namespace.useRef(void 0);
  return ref.current || (ref.current = {
    v: fn()
  }), ref.current.v;
}
var PresenceContext = /* @__PURE__ */ React__namespace.createContext(null), ResetPresence = function(props) {
  var parent = React__namespace.useContext(PresenceContext);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceContext.Provider, {
    value: props.disable ? parent : null,
    children: props.children
  });
};
function usePresence() {
  var context2 = React__namespace.useContext(PresenceContext);
  if (!context2) return [true, null, context2];
  var {
    id: id2,
    isPresent: isPresent2,
    onExitComplete,
    register
  } = context2;
  React__namespace.useEffect(function() {
    return register(id2);
  }, []);
  var safeToRemove = function() {
    return onExitComplete == null ? void 0 : onExitComplete(id2);
  };
  return !isPresent2 && onExitComplete ? [false, safeToRemove, context2] : [true, void 0, context2];
}
function useIsPresent() {
  return isPresent(React__namespace.useContext(PresenceContext));
}
function isPresent(context2) {
  return context2 === null ? true : context2.isPresent;
}
var PresenceChild = /* @__PURE__ */ React__namespace.memo(function(param) {
  var {
    children,
    initial,
    isPresent: isPresent2,
    onExitComplete,
    exitVariant,
    enterVariant,
    enterExitVariant,
    presenceAffectsLayout,
    custom
  } = param, presenceChildren = useConstant(newChildrenMap), id2 = React.useId() || "", context2 = React__namespace.useMemo(
    function() {
      return {
        id: id2,
        initial,
        isPresent: isPresent2,
        custom,
        exitVariant,
        enterVariant,
        enterExitVariant,
        onExitComplete: function() {
          presenceChildren.set(id2, true);
          var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
          try {
            for (var _iterator = presenceChildren.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var isComplete = _step.value;
              if (!isComplete) return;
            }
          } catch (err) {
            _didIteratorError = true, _iteratorError = err;
          } finally {
            try {
              !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
            } finally {
              if (_didIteratorError) throw _iteratorError;
            }
          }
          onExitComplete == null ? void 0 : onExitComplete();
        },
        register: function() {
          return presenceChildren.set(id2, false), function() {
            return presenceChildren.delete(id2);
          };
        }
      };
    },
    /**
    * If the presence of a child affects the layout of the components around it,
    * we want to make a new context value to ensure they get re-rendered
    * so they can detect that layout change.
    */
    // @ts-expect-error its ok
    presenceAffectsLayout ? void 0 : [isPresent2, exitVariant, enterVariant]
  );
  return React__namespace.useMemo(function() {
    presenceChildren.forEach(function(_, key) {
      return presenceChildren.set(key, false);
    });
  }, [isPresent2]), React__namespace.useEffect(function() {
    !isPresent2 && !presenceChildren.size && (onExitComplete == null ? void 0 : onExitComplete());
  }, [isPresent2]), /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceContext.Provider, {
    value: context2,
    children
  });
});
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
var getChildKey = function(child) {
  return child.key || "";
};
function updateChildLookup(children, allChildren) {
  children.forEach(function(child) {
    var key = getChildKey(child);
    allChildren.set(key, child);
  });
}
function onlyElements(children) {
  var filtered = [];
  return React.Children.forEach(children, function(child) {
    /* @__PURE__ */ React.isValidElement(child) && filtered.push(child);
  }), filtered;
}
var AnimatePresence = function(param) {
  var {
    children,
    enterVariant,
    exitVariant,
    enterExitVariant,
    initial = true,
    onExitComplete,
    exitBeforeEnter,
    presenceAffectsLayout = true,
    custom,
    passThrough
  } = param, _useContext_forceRender, forceRender = (_useContext_forceRender = React.useContext(LayoutGroupContext).forceRender) !== null && _useContext_forceRender !== void 0 ? _useContext_forceRender : useForceUpdate(), filteredChildren = onlyElements(children), presentChildren = React.useRef(filteredChildren), allChildren = React.useRef(/* @__PURE__ */ new Map()).current, exiting = React.useRef(/* @__PURE__ */ new Set()).current;
  updateChildLookup(filteredChildren, allChildren);
  var isInitialRender = React.useRef(true);
  if (passThrough) return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children
  });
  if (useIsomorphicLayoutEffect(function() {
    isInitialRender.current = false;
  }, []), isInitialRender.current) return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children: filteredChildren.map(function(child) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceChild, {
        isPresent: true,
        enterExitVariant,
        exitVariant,
        enterVariant,
        initial: initial ? void 0 : false,
        presenceAffectsLayout,
        custom,
        children: child
      }, getChildKey(child));
    })
  });
  for (var childrenToRender = [...filteredChildren], presentKeys = presentChildren.current.map(getChildKey), targetKeys = filteredChildren.map(getChildKey), numPresent = presentKeys.length, i = 0; i < numPresent; i++) {
    var key = presentKeys[i];
    targetKeys.indexOf(key) === -1 ? exiting.add(key) : exiting.delete(key);
  }
  return exitBeforeEnter && exiting.size && (childrenToRender = []), exiting.forEach(function(key2) {
    if (targetKeys.indexOf(key2) === -1) {
      var child = allChildren.get(key2);
      if (child) {
        var insertionIndex = presentKeys.indexOf(key2), onExit = function() {
          allChildren.delete(key2), exiting.delete(key2);
          var removeIndex = presentChildren.current.findIndex(function(presentChild) {
            return presentChild.key === key2;
          });
          presentChildren.current.splice(removeIndex, 1), exiting.size || (presentChildren.current = filteredChildren, forceRender(), onExitComplete == null ? void 0 : onExitComplete());
        }, exitingComponent = /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceChild, {
          isPresent: false,
          onExitComplete: onExit,
          presenceAffectsLayout,
          enterExitVariant,
          enterVariant,
          exitVariant,
          custom,
          children: child
        }, getChildKey(child));
        childrenToRender.splice(insertionIndex, 0, exitingComponent);
      }
    }
  }), childrenToRender = childrenToRender.map(function(child) {
    var key2 = child.key;
    return exiting.has(key2) ? child : /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceChild, {
      isPresent: true,
      exitVariant,
      enterVariant,
      enterExitVariant,
      presenceAffectsLayout,
      custom,
      children: child
    }, getChildKey(child));
  }), presentChildren.current = childrenToRender, /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children: exiting.size ? childrenToRender : (
      // biome-ignore lint/correctness/useJsxKeyInIterable: <explanation>
      childrenToRender.map(function(child) {
        return /* @__PURE__ */ React.cloneElement(child);
      })
    )
  });
};
AnimatePresence.displayName = "AnimatePresence";
var startTransition = function(callback) {
  callback();
};
var emptyCallbackFn = function(_) {
  return _();
};
function useControllableState(param) {
  var {
    prop,
    defaultProp,
    onChange,
    strategy = "prop-wins",
    preventUpdate,
    transition
  } = param, [state, setState] = React__namespace.useState(prop != null ? prop : defaultProp), previous = React__namespace.useRef(state), propWins = strategy === "prop-wins" && prop !== void 0, value = propWins ? prop : state, onChangeCb = useEvent(onChange || idFn), transitionFn = transition ? startTransition : emptyCallbackFn;
  React__namespace.useEffect(function() {
    prop !== void 0 && (previous.current = prop, transitionFn(function() {
      setState(prop);
    }));
  }, [prop]), React__namespace.useEffect(function() {
    propWins || state !== previous.current && (previous.current = state, onChangeCb(state));
  }, [onChangeCb, state, propWins]);
  var setter = useEvent(function(next) {
    if (!preventUpdate) if (propWins) {
      var nextValue = typeof next == "function" ? next(previous.current) : next;
      onChangeCb(nextValue);
    } else transitionFn(function() {
      setState(next);
    });
  });
  return [value, setter];
}
var idFn = function() {
};
var COLLAPSIBLE_NAME = "Collapsible", {
  Provider: CollapsibleProvider,
  useStyledContext: useCollapsibleContext
} = createStyledContext(), _Collapsible = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    __scopeCollapsible,
    open: openProp,
    defaultOpen,
    disabled,
    onOpenChange
  } = _a, collapsibleProps = __objRest(_a, [
    "__scopeCollapsible",
    "open",
    "defaultOpen",
    "disabled",
    "onOpenChange"
  ]), [open2 = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CollapsibleProvider, {
    scope: __scopeCollapsible,
    disabled,
    contentId: React__namespace.useId(),
    open: open2,
    onOpenToggle: React__namespace.useCallback(function() {
      return setOpen(function(prevOpen) {
        return !prevOpen;
      });
    }, [setOpen]),
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Stack$1, __spreadProps(__spreadValues({
      "data-state": getState$4(open2),
      "data-disabled": disabled ? "" : void 0
    }, collapsibleProps), {
      ref: forwardedRef
    }))
  });
});
_Collapsible.displayName = COLLAPSIBLE_NAME;
var TRIGGER_NAME$4 = "CollapsibleTrigger", CollapsibleTriggerFrame = styled(Stack$1, {
  name: TRIGGER_NAME$4,
  tag: "button"
}), CollapsibleTrigger = CollapsibleTriggerFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    __scopeCollapsible,
    children
  } = _a, triggerProps = __objRest(_a, [
    "__scopeCollapsible",
    "children"
  ]), context2 = useCollapsibleContext(__scopeCollapsible);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CollapsibleTriggerFrame, __spreadProps(__spreadValues({
    "aria-controls": context2.contentId,
    "aria-expanded": context2.open || false,
    "data-state": getState$4(context2.open),
    "data-disabled": context2.disabled ? "" : void 0,
    disabled: context2.disabled
  }, triggerProps), {
    ref: forwardedRef,
    onPress: composeEventHandlers(props.onPress, context2.onOpenToggle),
    children: typeof children == "function" ? children({
      open: context2.open
    }) : children
  }));
});
CollapsibleTrigger.displayName = TRIGGER_NAME$4;
var CONTENT_NAME$3 = "CollapsibleContent", CollapsibleContentFrame = styled(Stack$1, {
  name: CONTENT_NAME$3
}), CollapsibleContent = CollapsibleContentFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    forceMount,
    children,
    __scopeCollapsible: __scopeCollapsible
  } = _a, contentProps = __objRest(_a, [
    "forceMount",
    "children",
    // @ts-expect-error
    "__scopeCollapsible"
  ]), context2 = useCollapsibleContext(__scopeCollapsible);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, __spreadProps(__spreadValues({}, contentProps), {
    children: forceMount || context2.open ? /* @__PURE__ */ jsxRuntimeExports.jsx(CollapsibleContentFrame, __spreadProps(__spreadValues({
      ref: forwardedRef
    }, contentProps), {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ResetPresence, {
        children
      })
    })) : null
  }));
});
CollapsibleContent.displayName = CONTENT_NAME$3;
function getState$4(open2) {
  return open2 ? "open" : "closed";
}
var Collapsible = withStaticProperties(_Collapsible, {
  Trigger: CollapsibleTrigger,
  Content: CollapsibleContent
});
var RE_MEDIA_QUERY = /(?:(only|not)?\s*([^\s\(\)]+)(?:\s*and)?\s*)?(.+)?/i, RE_MQ_EXPRESSION = /\(\s*([^\s\:\)]+)\s*(?:\:\s*([^\s\)]+))?\s*\)/, RE_MQ_FEATURE = /^(?:(min|max)-)?(.+)/, RE_LENGTH_UNIT = /(em|rem|px|cm|mm|in|pt|pc)?$/, RE_RESOLUTION_UNIT = /(dpi|dpcm|dppx)?$/;
function matchQuery(mediaQuery, values) {
  return parseQuery(mediaQuery).some(function(query2) {
    if (query2) {
      var inverse = query2.inverse, typeMatch = query2.type === "all" || values.type === query2.type;
      if (typeMatch && inverse || !(typeMatch || inverse)) return false;
      var expressionsMatch = query2.expressions.every(function(expression) {
        var feature = expression.feature, modifier = expression.modifier, expValue = expression.value, value = values[feature];
        if (!value) return false;
        switch (feature) {
          case "orientation":
          case "scan":
            return value.toLowerCase() === expValue.toLowerCase();
          case "width":
          case "height":
          case "device-width":
          case "device-height":
            expValue = toPx(expValue), value = toPx(value);
            break;
          case "resolution":
            expValue = toDpi(expValue), value = toDpi(value);
            break;
          case "aspect-ratio":
          case "device-aspect-ratio":
          case /* Deprecated */
          "device-pixel-ratio":
            expValue = toDecimal(expValue), value = toDecimal(value);
            break;
          case "grid":
          case "color":
          case "color-index":
          case "monochrome":
            expValue = Number.parseInt(expValue, 10) || 1, value = Number.parseInt(value, 10) || 0;
            break;
        }
        switch (modifier) {
          case "min":
            return value >= expValue;
          case "max":
            return value <= expValue;
          default:
            return value === expValue;
        }
      });
      return expressionsMatch && !inverse || !expressionsMatch && inverse;
    }
  });
}
function parseQuery(mediaQuery) {
  return mediaQuery.split(",").map(function(query2) {
    query2 = query2.trim();
    var captures = query2.match(RE_MEDIA_QUERY);
    if (!captures) return null;
    var modifier = captures[1], type = captures[2], expressionsCapture = captures[3] || "", expressions = expressionsCapture.match(/\([^\)]+\)/g) || [];
    return {
      inverse: !!modifier && modifier.toLowerCase() === "not",
      type: type ? type.toLowerCase() : "all",
      expressions: expressions.map(function(expression) {
        var captures2 = expression.match(RE_MQ_EXPRESSION), feature = captures2[1].toLowerCase().match(RE_MQ_FEATURE);
        return {
          modifier: feature[1],
          feature: feature[2],
          value: captures2[2]
        };
      })
    };
  });
}
function toDecimal(ratio) {
  var decimal = Number(ratio), numbers;
  return decimal || (numbers = ratio.match(/^(\d+)\s*\/\s*(\d+)$/), decimal = numbers[1] / numbers[2]), decimal;
}
function toDpi(resolution) {
  var _String_match, value = Number.parseFloat(resolution), units = (_String_match = String(resolution).match(RE_RESOLUTION_UNIT)) === null || _String_match === void 0 ? void 0 : _String_match[1];
  switch (units) {
    case "dpcm":
      return value / 2.54;
    case "dppx":
      return value * 96;
    default:
      return value;
  }
}
function toPx(length) {
  var _String_match, value = Number.parseFloat(length), units = (_String_match = String(length).match(RE_LENGTH_UNIT)) === null || _String_match === void 0 ? void 0 : _String_match[1];
  switch (units) {
    case "em":
      return value * 16;
    case "rem":
      return value * 16;
    case "cm":
      return value * 96 / 2.54;
    case "mm":
      return value * 96 / 2.54 / 10;
    case "in":
      return value * 96;
    case "pt":
      return value * 72;
    case "pc":
      return value * 72 / 12;
    default:
      return value;
  }
}
function _class_call_check(instance, Constructor) {
  if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor && (descriptor.writable = true), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties(Constructor.prototype, protoProps), Constructor;
}
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: true,
    configurable: true,
    writable: true
  }) : obj[key] = value, obj;
}
var NativeMediaQueryList = /* @__PURE__ */ (function() {
  function NativeMediaQueryList2(query2) {
    var _this = this;
    _class_call_check(this, NativeMediaQueryList2), _define_property(this, "query", void 0), _define_property(this, "listeners", void 0), this.query = query2, this.listeners = [], this.notify(), Dimensions.addEventListener("change", function() {
      _this.notify();
    });
  }
  return _create_class(NativeMediaQueryList2, [{
    key: "orientation",
    get: function() {
      var windowDimensions = Dimensions.get("window");
      return windowDimensions.height > windowDimensions.width ? "portrait" : "landscape";
    }
  }, {
    key: "notify",
    value: function() {
      var _this = this;
      this.listeners.forEach(function(listener) {
        listener(_this.orientation);
      });
    }
  }, {
    key: "addListener",
    value: function(listener) {
      this.listeners.push(listener);
    }
  }, {
    key: "removeListener",
    value: function(listener) {
      var index2 = this.listeners.indexOf(listener);
      index2 !== -1 && this.listeners.splice(index2, 1);
    }
  }, {
    key: "match",
    value: function(query2, param) {
      var {
        width,
        height
      } = param;
      return matchQuery(query2, {
        type: "screen",
        orientation: height > width ? "portrait" : "landscape",
        "device-width": width,
        "device-height": height
      });
    }
  }, {
    key: "matches",
    get: function() {
      var windowDimensions = Dimensions.get("window"), matches = matchQuery(this.query, __spreadProps(__spreadValues({
        type: "screen",
        orientation: this.orientation
      }, windowDimensions), {
        "device-width": windowDimensions.width,
        "device-height": windowDimensions.height
      }));
      return matches;
    }
  }]), NativeMediaQueryList2;
})();
var matchMedia = function(query2) {
  return new NativeMediaQueryList(query2);
};
function createMedia(media) {
  return setupMatchMedia(matchMedia), media;
}
function getReactNativeVersion() {
  var version = process.env.REACT_NATIVE_VERSION || "";
  if (!process.env.REACT_NATIVE_VERSION) try {
    var ReactNativeOfficalVersion = require("react-native/Libraries/Core/ReactNativeVersion");
    if (ReactNativeOfficalVersion) {
      var {
        version: {
          major,
          minor,
          patch
        }
      } = ReactNativeOfficalVersion;
      version = `${major}.${minor}.${patch}`;
    }
  } catch (e2) {
  } finally {
    version || (version = "0.77");
  }
  var [major1, minor1, patch1] = version.split(".");
  return [+major1, +minor1, +patch1];
}
function addNativeValidStyles() {
  var [major, minor] = getReactNativeVersion();
  if (major === 0 && minor >= 77) {
    var additional = {
      boxSizing: true,
      mixBlendMode: true,
      outlineWidth: true,
      outlineStyle: true,
      outlineSpread: true,
      outlineColor: true
    };
    Object.assign(validStyles, additional), Object.assign(stylePropsAll, additional);
  }
}
function createOptimizedView(children, viewProps, baseViews2) {
  var _viewProps_style, TextAncestor = baseViews2.TextAncestor, {
    accessibilityElementsHidden,
    accessibilityLabel,
    accessibilityLabelledBy,
    accessibilityLiveRegion,
    accessibilityState,
    accessibilityValue,
    "aria-busy": ariaBusy,
    "aria-checked": ariaChecked,
    "aria-disabled": ariaDisabled,
    "aria-expanded": ariaExpanded,
    "aria-hidden": ariaHidden,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    "aria-live": ariaLive,
    "aria-selected": ariaSelected,
    "aria-valuemax": ariaValueMax,
    "aria-valuemin": ariaValueMin,
    "aria-valuenow": ariaValueNow,
    "aria-valuetext": ariaValueText,
    focusable,
    id: id2,
    role,
    tabIndex
  } = (
    // ...otherProps
    viewProps
  ), _ariaLabelledBy_split, _accessibilityLabelledBy = (_ariaLabelledBy_split = ariaLabelledBy == null ? void 0 : ariaLabelledBy.split(/\s*,\s*/g)) !== null && _ariaLabelledBy_split !== void 0 ? _ariaLabelledBy_split : accessibilityLabelledBy, _accessibilityState;
  (accessibilityState != null || ariaBusy != null || ariaChecked != null || ariaDisabled != null || ariaExpanded != null || ariaSelected != null) && (_accessibilityState = {
    busy: ariaBusy != null ? ariaBusy : accessibilityState == null ? void 0 : accessibilityState.busy,
    checked: ariaChecked != null ? ariaChecked : accessibilityState == null ? void 0 : accessibilityState.checked,
    disabled: ariaDisabled != null ? ariaDisabled : accessibilityState == null ? void 0 : accessibilityState.disabled,
    expanded: ariaExpanded != null ? ariaExpanded : accessibilityState == null ? void 0 : accessibilityState.expanded,
    selected: ariaSelected != null ? ariaSelected : accessibilityState == null ? void 0 : accessibilityState.selected
  });
  var _accessibilityValue;
  if ((accessibilityValue != null || ariaValueMax != null || ariaValueMin != null || ariaValueNow != null || ariaValueText != null) && (_accessibilityValue = {
    max: ariaValueMax != null ? ariaValueMax : accessibilityValue == null ? void 0 : accessibilityValue.max,
    min: ariaValueMin != null ? ariaValueMin : accessibilityValue == null ? void 0 : accessibilityValue.min,
    now: ariaValueNow != null ? ariaValueNow : accessibilityValue == null ? void 0 : accessibilityValue.now,
    text: ariaValueText != null ? ariaValueText : accessibilityValue == null ? void 0 : accessibilityValue.text
  }), !((_viewProps_style = viewProps.style) === null || _viewProps_style === void 0) && _viewProps_style.pointerEvents) {
    var _viewProps_style1;
    viewProps.pointerEvents = (_viewProps_style1 = viewProps.style) === null || _viewProps_style1 === void 0 ? void 0 : _viewProps_style1.pointerEvents;
  }
  if (id2 && (viewProps.nativeID = id2), ariaHidden === true && (viewProps.importantForAccessibility = "no-hide-descendants"), _accessibilityValue && (viewProps.accessibilityValue = _accessibilityValue), role && (viewProps.accessibilityRole = getAccessibilityRoleFromRole(role)), ariaLive === "off") viewProps.accessibilityLiveRegion = "none";
  else {
    var alr = ariaLive != null ? ariaLive : accessibilityLiveRegion;
    alr && (viewProps.accessibilityLiveRegion = alr);
  }
  var al = ariaLabel != null ? ariaLabel : accessibilityLabel;
  al && (viewProps.accessibilityLabel = al);
  var f = tabIndex !== void 0 ? !tabIndex : focusable;
  f != null && (viewProps.focusable = f), _accessibilityState != null && (viewProps.accessibilityState = _accessibilityState);
  var ah = ariaHidden != null ? ariaHidden : accessibilityElementsHidden;
  ah != null && (viewProps.accessibilityElementsHidden = ah), _accessibilityLabelledBy && (viewProps.accessibilityLabelledBy = _accessibilityLabelledBy);
  var isInText = React.useContext(TextAncestor), finalElement = /* @__PURE__ */ React.createElement("RCTView", viewProps, children);
  return isInText ? /* @__PURE__ */ React.createElement(TextAncestor.Provider, {
    value: false
  }, finalElement) : finalElement;
}
function getAccessibilityRoleFromRole(role) {
  switch (role) {
    case "alert":
      return "alert";
    case "alertdialog":
      return;
    case "application":
      return;
    case "article":
      return;
    case "banner":
      return;
    case "button":
      return "button";
    case "cell":
      return;
    case "checkbox":
      return "checkbox";
    case "columnheader":
      return;
    case "combobox":
      return "combobox";
    case "complementary":
      return;
    case "contentinfo":
      return;
    case "definition":
      return;
    case "dialog":
      return;
    case "directory":
      return;
    case "document":
      return;
    case "feed":
      return;
    case "figure":
      return;
    case "form":
      return;
    case "grid":
      return "grid";
    case "group":
      return;
    case "heading":
      return "header";
    case "img":
      return "image";
    case "link":
      return "link";
    case "list":
      return "list";
    case "listitem":
      return;
    case "log":
      return;
    case "main":
      return;
    case "marquee":
      return;
    case "math":
      return;
    case "menu":
      return "menu";
    case "menubar":
      return "menubar";
    case "menuitem":
      return "menuitem";
    case "meter":
      return;
    case "navigation":
      return;
    case "none":
      return "none";
    case "note":
      return;
    case "option":
      return;
    case "presentation":
      return "none";
    case "progressbar":
      return "progressbar";
    case "radio":
      return "radio";
    case "radiogroup":
      return "radiogroup";
    case "region":
      return;
    case "row":
      return;
    case "rowgroup":
      return;
    case "rowheader":
      return;
    case "scrollbar":
      return "scrollbar";
    case "searchbox":
      return "search";
    case "separator":
      return;
    case "slider":
      return "adjustable";
    case "spinbutton":
      return "spinbutton";
    case "status":
      return;
    case "summary":
      return "summary";
    case "switch":
      return "switch";
    case "tab":
      return "tab";
    case "table":
      return;
    case "tablist":
      return "tablist";
    case "tabpanel":
      return;
    case "term":
      return;
    case "timer":
      return "timer";
    case "toolbar":
      return "toolbar";
    case "tooltip":
      return;
    case "tree":
      return;
    case "treegrid":
      return;
    case "treeitem":
      return;
  }
}
function getBaseViews() {
  var _native_default, _native_default1, _native_default2, _native_default3, native = require("react-native");
  return {
    View: native.View || ((_native_default = native.default) === null || _native_default === void 0 ? void 0 : _native_default.View),
    Text: native.Text || ((_native_default1 = native.default) === null || _native_default1 === void 0 ? void 0 : _native_default1.Text),
    TextAncestor: native.unstable_TextAncestorContext,
    StyleSheet: native.StyleSheet || ((_native_default2 = native.default) === null || _native_default2 === void 0 ? void 0 : _native_default2.StyleSheet),
    Pressable: native.Pressable || ((_native_default3 = native.default) === null || _native_default3 === void 0 ? void 0 : _native_default3.Pressable)
  };
}
require("react-native/Libraries/Pressability/Pressability").default;
var usePressability = require("react-native/Libraries/Pressability/usePressability").default;
addNativeValidStyles();
var TamaguiProvider$1 = function(props) {
  return useIsomorphicLayoutEffect(function() {
    enable();
  }, []), /* @__PURE__ */ jsxRuntimeExports.jsx(TamaguiProvider$2, __spreadValues({}, props));
}, createTamagui$1 = function(conf2) {
  return conf2.media && (conf2.media = createMedia(conf2.media)), createTamagui$2(conf2);
}, baseViews = getBaseViews();
setupHooks({
  getBaseViews,
  setElementProps: function(node) {
  },
  usePropsTransform(elementType, propsIn, stateRef, willHydrate) {
  },
  useEvents(viewProps, events, splitStyles, setStateShallow, staticConfig) {
    if (events && (events.onFocus && (viewProps.onFocus = events.onFocus), events.onBlur && (viewProps.onBlur = events.onBlur)), staticConfig.isInput) {
      if (events) {
        var {
          onPressIn,
          onPressOut,
          onPress
        } = events, inputEvents = {
          onPressIn,
          onPressOut: onPressOut || onPress
        };
        onPressOut && onPress && (inputEvents.onPressOut = composeEventHandlers(onPress, onPressOut)), Object.assign(viewProps, inputEvents);
      }
    } else {
      events && viewProps.hitSlop && (events.hitSlop = viewProps.hitSlop);
      var pressability = usePressability(events);
      if (events && events.onPress) for (var key in pressability) {
        var og = viewProps[key], val = pressability[key];
        viewProps[key] = og && !dontComposePressabilityKeys[key] ? composeEventHandlers(og, val) : val;
      }
    }
  },
  useChildren(elementType, children, viewProps) {
    if (elementType === baseViews.View && baseViews.TextAncestor) return createOptimizedView(children, viewProps, baseViews);
  }
});
var dontComposePressabilityKeys = {
  onClick: true
}, View = View$2, Stack = Stack$1, Text$1 = Text$2;
function createCollection(name) {
  var {
    Provider: CollectionProviderImpl,
    useStyledContext: useCollectionContext
  } = createStyledContext({
    collectionRef: {
      current: void 0
    },
    itemMap: /* @__PURE__ */ new Map()
  }, "Toast"), CollectionProvider = function(props) {
    var {
      scope,
      children
    } = props, ref = React.useRef(void 0), itemMap = React.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionProviderImpl, {
      scope,
      itemMap,
      collectionRef: ref,
      children
    });
  };
  CollectionProvider.displayName = "CollectionProvider";
  var COLLECTION_SLOT_NAME = name + "CollectionSlot", CollectionSlot = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
    var {
      scope,
      children
    } = props, context2 = useCollectionContext(scope), composedRefs = useComposedRefs(forwardedRef, context2.collectionRef);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Slot, {
      ref: composedRefs,
      children
    });
  });
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  var ITEM_SLOT_NAME = name + "CollectionItemSlot", ITEM_DATA_ATTR = "data-collection-item", CollectionItemSlot = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
    var _a = props, {
      scope,
      children
    } = _a, itemData = __objRest(_a, [
      "scope",
      "children"
    ]), ref = React.useRef(void 0), composedRefs = useComposedRefs(forwardedRef, ref), context2 = useCollectionContext(scope);
    return React.useEffect(function() {
      return context2.itemMap.set(ref, __spreadValues({
        ref
      }, itemData)), function() {
        return void context2.itemMap.delete(ref);
      };
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(Slot, {
      [ITEM_DATA_ATTR]: "",
      ref: composedRefs,
      children
    });
  });
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection2(scope) {
    var context2 = useCollectionContext(scope), getItems = React.useCallback(function() {
      return [];
    }, [context2.collectionRef, context2.itemMap]);
    return getItems;
  }
  return [{
    Provider: CollectionProvider,
    Slot: CollectionSlot,
    ItemSlot: CollectionItemSlot
  }, useCollection2];
}
var getElevation = function(size, extras) {
  if (size) {
    var {
      tokens
    } = extras, token = tokens.size[size], sizeNum = isVariable(token) ? +token.val : size;
    return getSizedElevation(sizeNum, extras);
  }
}, getSizedElevation = function(val, param) {
  var {
    theme,
    tokens
  } = param, num = 0;
  if (val === true) {
    var _$val = getVariableValue(tokens.size.true);
    typeof _$val == "number" ? num = _$val : num = 10;
  } else num = +val;
  if (num !== 0) {
    var [height, shadowRadius] = [Math.round(num / 4 + 1), Math.round(num / 2 + 2)], shadow = __spreadValues({
      shadowColor: theme.shadowColor,
      shadowRadius,
      shadowOffset: {
        height,
        width: 0
      }
    }, isAndroid ? {
      elevationAndroid: 2 * height
    } : {});
    return shadow;
  }
};
function _type_of$2(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var fullscreenStyle = {
  position: "absolute",
  top: 0,
  left: 0,
  right: 0,
  bottom: 0
}, getInset = function(val) {
  return val && (typeof val > "u" ? "undefined" : _type_of$2(val)) === "object" ? val : {
    top: val,
    left: val,
    bottom: val,
    right: val
  };
}, variants = {
  fullscreen: {
    true: fullscreenStyle
  },
  elevation: {
    "...size": getElevation,
    ":number": getElevation
  },
  inset: getInset
}, YStack = styled(View, {
  flexDirection: "column",
  variants
});
YStack.displayName = "YStack";
var XStack = styled(View, {
  flexDirection: "row",
  variants
});
XStack.displayName = "XStack";
var ZStack = styled(YStack, {
  position: "relative"
}, {
  neverFlatten: true,
  isZStack: true
});
ZStack.displayName = "ZStack";
var defaultOptions = {
  shift: 0,
  bounds: [0]
}, getSize = function(size, options) {
  return getTokenRelative("size", size, options);
}, getSpace = function(space, options) {
  return getTokenRelative("space", space, options);
}, cacheVariables = {}, cacheWholeVariables = {}, cacheKeys = {}, cacheWholeKeys = {}, stepTokenUpOrDown = function(type, current) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultOptions, _options_bounds, _options_bounds1, tokens = getTokens({
    prefixed: true
  })[type];
  if (!(type in cacheVariables)) {
    cacheKeys[type] = [], cacheVariables[type] = [], cacheWholeKeys[type] = [], cacheWholeVariables[type] = [];
    var sorted = Object.keys(tokens).map(function(k) {
      return tokens[k];
    }).sort(function(a, b2) {
      return a.val - b2.val;
    }), _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
    try {
      for (var _iterator = sorted[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var token = _step.value;
        cacheKeys[type].push(token.key), cacheVariables[type].push(token);
      }
    } catch (err) {
      _didIteratorError = true, _iteratorError = err;
    } finally {
      try {
        !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
      } finally {
        if (_didIteratorError) throw _iteratorError;
      }
    }
    var sortedExcludingHalfSteps = sorted.filter(function(x) {
      return !x.key.endsWith(".5");
    }), _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = void 0;
    try {
      for (var _iterator1 = sortedExcludingHalfSteps[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
        var token1 = _step1.value;
        cacheWholeKeys[type].push(token1.key), cacheWholeVariables[type].push(token1);
      }
    } catch (err) {
      _didIteratorError1 = true, _iteratorError1 = err;
    } finally {
      try {
        !_iteratorNormalCompletion1 && _iterator1.return != null && _iterator1.return();
      } finally {
        if (_didIteratorError1) throw _iteratorError1;
      }
    }
  }
  var isString = typeof current == "string", cache2 = options.excludeHalfSteps ? isString ? cacheWholeKeys : cacheWholeVariables : isString ? cacheKeys : cacheVariables, tokensOrdered = cache2[type], _options_bounds_, min2 = (_options_bounds_ = (_options_bounds = options.bounds) === null || _options_bounds === void 0 ? void 0 : _options_bounds[0]) !== null && _options_bounds_ !== void 0 ? _options_bounds_ : 0, _options_bounds_1, max2 = (_options_bounds_1 = (_options_bounds1 = options.bounds) === null || _options_bounds1 === void 0 ? void 0 : _options_bounds1[1]) !== null && _options_bounds_1 !== void 0 ? _options_bounds_1 : tokensOrdered.length - 1, currentIndex = tokensOrdered.indexOf(current), shift2 = options.shift || 0;
  shift2 && (current === "$true" || isVariable(current) && current.name === "true") && (shift2 += shift2 > 0 ? 1 : -1);
  var index2 = Math.min(max2, Math.max(min2, currentIndex + shift2)), found = tokensOrdered[index2], result = (typeof found == "string" ? tokens[found] : found) || tokens.$true;
  return result;
}, getTokenRelative = stepTokenUpOrDown;
var getButtonSized = function(val, param) {
  var {
    tokens,
    props
  } = param;
  if (!(!val || props.circular)) {
    if (typeof val == "number") return {
      paddingHorizontal: val * 0.25,
      height: val,
      borderRadius: props.circular ? 1e5 : val * 0.2
    };
    var xSize = getSpace(val), _tokens_radius_val, radiusToken = (_tokens_radius_val = tokens.radius[val]) !== null && _tokens_radius_val !== void 0 ? _tokens_radius_val : tokens.radius.$true;
    return {
      paddingHorizontal: xSize,
      height: val,
      borderRadius: props.circular ? 1e5 : radiusToken
    };
  }
};
var elevate = {
  true: function(_, extras) {
    return getElevation(extras.props.size, extras);
  }
}, bordered = function(val, param) {
  var {
    props
  } = param;
  return __spreadValues(__spreadValues(__spreadValues({
    // TODO size it with size in '...size'
    borderWidth: typeof val == "number" ? val : 1,
    borderColor: "$borderColor"
  }, props.hoverTheme && {
    hoverStyle: {
      borderColor: "$borderColorHover"
    }
  }), props.pressTheme && {
    pressStyle: {
      borderColor: "$borderColorPress"
    }
  }), props.focusTheme && {
    focusStyle: {
      borderColor: "$borderColorFocus"
    }
  });
}, padded = {
  true: function(_, extras) {
    var {
      tokens,
      props
    } = extras;
    return {
      padding: tokens.space[props.size] || tokens.space.$true
    };
  }
}, radiused = {
  true: function(_, extras) {
    var {
      tokens,
      props
    } = extras;
    return {
      borderRadius: tokens.radius[props.size] || tokens.radius.$true
    };
  }
}, circularStyle = {
  borderRadius: 1e5,
  padding: 0
}, circular = {
  true: function(_, param) {
    var {
      props,
      tokens
    } = param;
    if (!("size" in props)) return circularStyle;
    var size = typeof props.size == "number" ? props.size : tokens.size[props.size];
    return __spreadProps(__spreadValues({}, circularStyle), {
      width: size,
      height: size,
      maxWidth: size,
      maxHeight: size,
      minWidth: size,
      minHeight: size
    });
  }
}, hoverTheme = {
  true: {
    hoverStyle: {
      backgroundColor: "$backgroundHover",
      borderColor: "$borderColorHover"
    }
  },
  false: {}
}, pressTheme = {
  true: {
    cursor: "pointer",
    pressStyle: {
      backgroundColor: "$backgroundPress",
      borderColor: "$borderColorPress"
    }
  },
  false: {}
}, focusTheme = {
  true: {
    focusStyle: {
      backgroundColor: "$backgroundFocus",
      borderColor: "$borderColorFocus"
    }
  },
  false: {}
};
var SizableStack = styled(XStack, {
  name: "SizableStack",
  variants: {
    unstyled: {
      true: {
        hoverTheme: false,
        pressTheme: false,
        focusTheme: false,
        elevate: false,
        bordered: false
      }
    },
    hoverTheme,
    pressTheme,
    focusTheme,
    circular,
    elevate,
    bordered,
    size: {
      "...size": function(val, extras) {
        return getButtonSized(val, extras);
      }
    }
  }
});
var chromelessStyle = {
  backgroundColor: "transparent",
  borderColor: "transparent",
  shadowColor: "transparent",
  hoverStyle: {
    borderColor: "transparent"
  }
}, themeableVariants = {
  backgrounded: {
    true: {
      backgroundColor: "$background"
    }
  },
  radiused,
  hoverTheme,
  pressTheme,
  focusTheme,
  circular,
  padded,
  elevate,
  bordered,
  transparent: {
    true: {
      backgroundColor: "transparent"
    }
  },
  chromeless: {
    true: chromelessStyle,
    all: __spreadProps(__spreadValues({}, chromelessStyle), {
      hoverStyle: chromelessStyle,
      pressStyle: chromelessStyle,
      focusStyle: chromelessStyle
    })
  }
}, ThemeableStack = styled(YStack, {
  variants: themeableVariants
});
var ButtonNestingContext = /* @__PURE__ */ React.createContext(false);
function _type_of$1(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var getFontSized = function() {
  var sizeTokenIn = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "$true", {
    font,
    fontFamily,
    props
  } = arguments.length > 1 ? arguments[1] : void 0, _font_lineHeight, _font_weight, _font_letterSpacing, _font_transform, _font_style, _font_color;
  if (!font) return {
    fontSize: sizeTokenIn
  };
  var sizeToken = sizeTokenIn === "$true" ? getDefaultSizeToken(font) : sizeTokenIn, style = {}, fontSize = font.size[sizeToken], lineHeight = (_font_lineHeight = font.lineHeight) === null || _font_lineHeight === void 0 ? void 0 : _font_lineHeight[sizeToken], fontWeight = (_font_weight = font.weight) === null || _font_weight === void 0 ? void 0 : _font_weight[sizeToken], letterSpacing = (_font_letterSpacing = font.letterSpacing) === null || _font_letterSpacing === void 0 ? void 0 : _font_letterSpacing[sizeToken], textTransform = (_font_transform = font.transform) === null || _font_transform === void 0 ? void 0 : _font_transform[sizeToken], _props_fontStyle, fontStyle = (_props_fontStyle = props.fontStyle) !== null && _props_fontStyle !== void 0 ? _props_fontStyle : (_font_style = font.style) === null || _font_style === void 0 ? void 0 : _font_style[sizeToken], _props_color, color = (_props_color = props.color) !== null && _props_color !== void 0 ? _props_color : (_font_color = font.color) === null || _font_color === void 0 ? void 0 : _font_color[sizeToken];
  return fontStyle && (style.fontStyle = fontStyle), textTransform && (style.textTransform = textTransform), fontFamily && (style.fontFamily = fontFamily), fontWeight && (style.fontWeight = fontWeight), letterSpacing && (style.letterSpacing = letterSpacing), fontSize && (style.fontSize = fontSize), lineHeight && (style.lineHeight = lineHeight), color && (style.color = color), style;
};
styled(Text$2, {
  name: "SizableText",
  fontFamily: "$body",
  variants: {
    size: {
      "...fontSize": getFontSized
    }
  },
  defaultVariants: {
    size: "$true"
  }
});
var cache = /* @__PURE__ */ new WeakMap();
function getDefaultSizeToken(font) {
  if ((typeof font > "u" ? "undefined" : _type_of$1(font)) === "object" && cache.has(font)) return cache.get(font);
  var sizeTokens = "$true" in font.size ? font.size : getTokens().size, sizeDefault = sizeTokens.$true, sizeDefaultSpecific = sizeDefault ? Object.keys(sizeTokens).find(function(x) {
    return x !== "$true" && sizeTokens[x].val === sizeDefault.val;
  }) : null;
  return !sizeDefault || !sizeDefaultSpecific ? Object.keys(font.size)[3] : (cache.set(font, sizeDefaultSpecific), sizeDefaultSpecific);
}
var SizableText = styled(Text$2, {
  name: "SizableText",
  fontFamily: "$body",
  variants: {
    unstyled: {
      false: {
        size: "$true",
        color: "$color"
      }
    },
    size: getFontSized
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
});
SizableText.staticConfig.variants.fontFamily = {
  "...": function(_val, extras) {
    var sizeProp = extras.props.size, fontSizeProp = extras.props.fontSize, size = sizeProp === "$true" && fontSizeProp ? fontSizeProp : extras.props.size || "$true";
    return getFontSized(size, extras);
  }
};
var Paragraph = styled(SizableText, {
  name: "Paragraph",
  tag: "p",
  userSelect: "auto",
  color: "$color",
  size: "$true",
  whiteSpace: "normal"
});
var Heading = styled(Paragraph, {
  tag: "span",
  name: "Heading",
  accessibilityRole: "header",
  fontFamily: "$heading",
  size: "$8",
  margin: 0
}), H1 = styled(Heading, {
  name: "H1",
  tag: "h1",
  variants: {
    unstyled: {
      false: {
        size: "$10"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), H2 = styled(Heading, {
  name: "H2",
  tag: "h2",
  variants: {
    unstyled: {
      false: {
        size: "$9"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), H3 = styled(Heading, {
  name: "H3",
  tag: "h3",
  variants: {
    unstyled: {
      false: {
        size: "$8"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), H4 = styled(Heading, {
  name: "H4",
  tag: "h4",
  variants: {
    unstyled: {
      false: {
        size: "$7"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), H5 = styled(Heading, {
  name: "H5",
  tag: "h5",
  variants: {
    unstyled: {
      false: {
        size: "$6"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), H6 = styled(Heading, {
  name: "H6",
  tag: "h6",
  variants: {
    unstyled: {
      false: {
        size: "$5"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
});
function wrapChildrenInText(TextComponent, propsIn, extraProps) {
  var {
    children,
    textProps,
    size,
    noTextWrap,
    color,
    fontFamily,
    fontSize,
    fontWeight,
    letterSpacing,
    textAlign,
    fontStyle,
    maxFontSizeMultiplier
  } = propsIn;
  if (noTextWrap || !children) return [children];
  var props = __spreadValues({}, extraProps);
  return color && (props.color = color), fontFamily && (props.fontFamily = fontFamily), fontSize && (props.fontSize = fontSize), fontWeight && (props.fontWeight = fontWeight), letterSpacing && (props.letterSpacing = letterSpacing), textAlign && (props.textAlign = textAlign), size && (props.size = size), fontStyle && (props.fontStyle = fontStyle), maxFontSizeMultiplier && (props.maxFontSizeMultiplier = maxFontSizeMultiplier), React.Children.toArray(children).map(function(child, index2) {
    return typeof child == "string" ? (
      // so "data-disable-theme" is a hack to fix themeInverse, don't ask me why
      /* @__PURE__ */ jsxRuntimeExports.jsx(TextComponent, __spreadProps(__spreadValues(__spreadValues({}, props), textProps), {
        children: child
      }), index2)
    ) : child;
  });
}
var DirectionContext = /* @__PURE__ */ React__namespace.createContext(void 0);
function useDirection(localDir) {
  var globalDir = React__namespace.useContext(DirectionContext);
  return localDir || globalDir || "ltr";
}
var ACCORDION_NAME = "Accordion", ACCORDION_KEYS = ["Home", "End", "ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"], [Collection, useCollection] = createCollection(ACCORDION_NAME), ACCORDION_CONTEXT = "Accordion", AccordionComponent = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    type
  } = _a, accordionProps = __objRest(_a, [
    "type"
  ]), singleProps = accordionProps, multipleProps = accordionProps;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Provider, {
    scope: props.__scopeAccordion || ACCORDION_CONTEXT,
    children: type === "multiple" ? /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionImplMultiple, __spreadProps(__spreadValues({}, multipleProps), {
      ref: forwardedRef
    })) : /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionImplSingle, __spreadProps(__spreadValues({}, singleProps), {
      ref: forwardedRef
    }))
  });
});
AccordionComponent.displayName = ACCORDION_NAME;
AccordionComponent.propTypes = {
  type(props) {
    var value = props.value || props.defaultValue;
    return props.type && !["single", "multiple"].includes(props.type) ? new Error("Invalid prop `type` supplied to `Accordion`. Expected one of `single | multiple`.") : props.type === "multiple" && typeof value == "string" ? new Error("Invalid prop `type` supplied to `Accordion`. Expected `single` when `defaultValue` or `value` is type `string`.") : props.type === "single" && Array.isArray(value) ? new Error("Invalid prop `type` supplied to `Accordion`. Expected `multiple` when `defaultValue` or `value` is type `string[]`.") : null;
  }
};
var {
  Provider: AccordionValueProvider,
  useStyledContext: useAccordionValueContext
} = createStyledContext(), {
  Provider: AccordionCollapsibleProvider,
  useStyledContext: useAccordionCollapsibleContext
} = createStyledContext(), AccordionImplSingle = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    value: valueProp,
    defaultValue: defaultValue2,
    control,
    onValueChange = function() {
    },
    collapsible = false
  } = _a, accordionSingleProps = __objRest(_a, [
    "value",
    "defaultValue",
    "control",
    "onValueChange",
    "collapsible"
  ]), [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue2 || "",
    onChange: onValueChange
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionValueProvider, {
    scope: props.__scopeAccordion,
    value: value ? [value] : [],
    onItemOpen: setValue,
    onItemClose: React__namespace.useCallback(function() {
      return collapsible && setValue("");
    }, [setValue, collapsible]),
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionCollapsibleProvider, {
      scope: props.__scopeAccordion,
      collapsible,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionImpl, __spreadProps(__spreadValues({}, accordionSingleProps), {
        ref: forwardedRef
      }))
    })
  });
}), AccordionImplMultiple = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    value: valueProp,
    defaultValue: defaultValue2,
    onValueChange = function() {
    }
  } = _a, accordionMultipleProps = __objRest(_a, [
    "value",
    "defaultValue",
    "onValueChange"
  ]), [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue2 || [],
    onChange: onValueChange
  }), handleItemOpen = React__namespace.useCallback(function(itemValue) {
    return setValue(function() {
      var prevValue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      return [...prevValue, itemValue];
    });
  }, [setValue]), handleItemClose = React__namespace.useCallback(function(itemValue) {
    return setValue(function() {
      var prevValue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      return prevValue.filter(function(value2) {
        return value2 !== itemValue;
      });
    });
  }, [setValue]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionValueProvider, {
    scope: props.__scopeAccordion,
    value: value || [],
    onItemOpen: handleItemOpen,
    onItemClose: handleItemClose,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionCollapsibleProvider, {
      scope: props.__scopeAccordion,
      collapsible: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionImpl, __spreadProps(__spreadValues({}, accordionMultipleProps), {
        ref: forwardedRef
      }))
    })
  });
}), {
  Provider: AccordionImplProvider,
  useStyledContext: useAccordionContext
} = createStyledContext(), AccordionImpl = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    __scopeAccordion,
    disabled,
    dir,
    orientation = "vertical"
  } = _a, accordionProps = __objRest(_a, [
    "__scopeAccordion",
    "disabled",
    "dir",
    "orientation"
  ]), accordionRef = React__namespace.useRef(null), composedRef = useComposedRefs(accordionRef, forwardedRef), getItems = useCollection(__scopeAccordion || ACCORDION_CONTEXT), direction = useDirection(dir), isDirectionLTR = direction === "ltr";
  composeEventHandlers(props.onKeyDown, function(event) {
    var _triggerCollection_clampedIndex_ref_current;
    if (ACCORDION_KEYS.includes(event.key)) {
      var target = event.target, triggerCollection = getItems().filter(function(item) {
        var el = item.ref.current;
        return !(el == null ? void 0 : el.disabled);
      }), triggerIndex = triggerCollection.findIndex(function(item) {
        return item.ref.current === target;
      }), triggerCount = triggerCollection.length;
      if (triggerIndex !== -1) {
        event.preventDefault();
        var nextIndex = triggerIndex, homeIndex = 0, endIndex = triggerCount - 1, moveNext = function() {
          nextIndex = triggerIndex + 1, nextIndex > endIndex && (nextIndex = homeIndex);
        }, movePrev = function() {
          nextIndex = triggerIndex - 1, nextIndex < homeIndex && (nextIndex = endIndex);
        };
        switch (event.key) {
          case "Home":
            nextIndex = homeIndex;
            break;
          case "End":
            nextIndex = endIndex;
            break;
          case "ArrowRight":
            orientation === "horizontal" && (isDirectionLTR ? moveNext() : movePrev());
            break;
          case "ArrowDown":
            orientation === "vertical" && moveNext();
            break;
          case "ArrowLeft":
            orientation === "horizontal" && (isDirectionLTR ? movePrev() : moveNext());
            break;
          case "ArrowUp":
            orientation === "vertical" && movePrev();
            break;
        }
        var clampedIndex = nextIndex % triggerCount;
        (_triggerCollection_clampedIndex_ref_current = triggerCollection[clampedIndex].ref.current) === null || _triggerCollection_clampedIndex_ref_current === void 0 || _triggerCollection_clampedIndex_ref_current.focus();
      }
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionImplProvider, {
    scope: __scopeAccordion,
    disabled,
    direction: dir,
    orientation,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Slot, {
      scope: __scopeAccordion || ACCORDION_CONTEXT,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(YStack, __spreadValues(__spreadValues({
        "data-orientation": orientation,
        ref: composedRef
      }, accordionProps), isWeb))
    })
  });
}), ITEM_NAME$2 = "AccordionItem", {
  Provider: AccordionItemProvider,
  useStyledContext: useAccordionItemContext
} = createStyledContext(), AccordionItem = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    __scopeAccordion,
    value
  } = _a, accordionItemProps = __objRest(_a, [
    "__scopeAccordion",
    "value"
  ]), accordionContext = useAccordionContext(__scopeAccordion), valueContext = useAccordionValueContext(__scopeAccordion), triggerId = React__namespace.useId(), open2 = value && valueContext.value.includes(value) || false, disabled = accordionContext.disabled || props.disabled;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionItemProvider, {
    scope: __scopeAccordion,
    open: open2,
    disabled,
    triggerId,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collapsible, __spreadProps(__spreadValues({
      "data-orientation": accordionContext.orientation,
      "data-state": open2 ? "open" : "closed",
      __scopeCollapsible: __scopeAccordion || ACCORDION_CONTEXT
    }, accordionItemProps), {
      ref: forwardedRef,
      disabled,
      open: open2,
      onOpenChange: function(open22) {
        open22 ? valueContext.onItemOpen(value) : valueContext.onItemClose(value);
      }
    }))
  });
});
AccordionItem.displayName = ITEM_NAME$2;
var HEADER_NAME = "AccordionHeader", AccordionHeader = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    __scopeAccordion
  } = _a, headerProps = __objRest(_a, [
    "__scopeAccordion"
  ]), accordionContext = useAccordionContext(__scopeAccordion), itemContext = useAccordionItemContext(__scopeAccordion);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(H1, __spreadProps(__spreadValues({
    "data-orientation": accordionContext.orientation,
    "data-state": getState$3(itemContext.open),
    "data-disabled": itemContext.disabled ? "" : void 0
  }, headerProps), {
    ref: forwardedRef
  }));
});
AccordionHeader.displayName = HEADER_NAME;
var AccordionTriggerFrame = styled(Collapsible.Trigger, {
  variants: {
    unstyled: {
      false: {
        cursor: "pointer",
        backgroundColor: "$background",
        borderColor: "$borderColor",
        borderWidth: 1,
        padding: "$true",
        hoverStyle: {
          backgroundColor: "$backgroundHover"
        },
        focusStyle: {
          backgroundColor: "$backgroundFocus"
        },
        pressStyle: {
          backgroundColor: "$backgroundPress"
        }
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), AccordionTrigger = AccordionTriggerFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    __scopeAccordion
  } = _a, triggerProps = __objRest(_a, [
    "__scopeAccordion"
  ]), accordionContext = useAccordionContext(__scopeAccordion), itemContext = useAccordionItemContext(__scopeAccordion), collapsibleContext = useAccordionCollapsibleContext(__scopeAccordion);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.ItemSlot, {
    scope: __scopeAccordion || ACCORDION_CONTEXT,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionTriggerFrame, __spreadProps(__spreadValues({
      //   @ts-ignore
      __scopeCollapsible: __scopeAccordion || ACCORDION_CONTEXT,
      "aria-disabled": itemContext.open && !collapsibleContext.collapsible || void 0,
      "data-orientation": accordionContext.orientation,
      id: itemContext.triggerId
    }, triggerProps), {
      ref: forwardedRef
    }))
  });
}), AccordionContentFrame = styled(Collapsible.Content, {
  variants: {
    unstyled: {
      false: {
        padding: "$true",
        backgroundColor: "$background"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), AccordionContent = AccordionContentFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    __scopeAccordion
  } = _a, contentProps = __objRest(_a, [
    "__scopeAccordion"
  ]), accordionContext = useAccordionContext(__scopeAccordion), itemContext = useAccordionItemContext(__scopeAccordion);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionContentFrame, __spreadProps(__spreadValues({
    role: "region",
    "aria-labelledby": itemContext.triggerId,
    "data-orientation": accordionContext.orientation,
    // @ts-ignore
    __scopeCollapsible: __scopeAccordion || ACCORDION_CONTEXT
  }, contentProps), {
    ref: forwardedRef
  }));
}), HeightAnimator = View.styleable(function(props, ref) {
  var itemContext = useAccordionItemContext(), _a = props, {
    children
  } = _a, rest = __objRest(_a, [
    "children"
  ]), [height, setHeight] = React__namespace.useState(0);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(View, __spreadProps(__spreadValues({
    ref,
    height: itemContext.open ? height : 0
  }, rest), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(View, {
      position: "absolute",
      width: "100%",
      onLayout: function(param) {
        var {
          nativeEvent
        } = param;
        nativeEvent.layout.height && setHeight(nativeEvent.layout.height);
      },
      children
    })
  }));
});
function getState$3(open2) {
  return open2 ? "open" : "closed";
}
var Accordion = withStaticProperties(AccordionComponent, {
  Trigger: AccordionTrigger,
  Header: AccordionHeader,
  Content: AccordionContent,
  Item: AccordionItem,
  HeightAnimator
});
var ZIndexStackContext = React.createContext(1), ZIndexHardcodedContext = React.createContext(void 0);
var ZIndicesByContext = {}, CurrentPortalZIndices = {}, useStackedZIndex = function(props) {
  if (process.env.TAMAGUI_STACK_Z_INDEX_GLOBAL) {
    var {
      stackZIndex,
      zIndex: zIndexProp
    } = props, id2 = React.useId(), zIndex = React.useMemo(function() {
      if (stackZIndex && stackZIndex !== "global" && zIndexProp === void 0) {
        var highest = Object.values(CurrentPortalZIndices).reduce(function(acc, cur) {
          return Math.max(acc, cur);
        }, 0);
        return Math.max(stackZIndex === true ? 1 : stackZIndex, highest + 1);
      }
      return zIndexProp != null ? zIndexProp : 1e3;
    }, [stackZIndex]);
    return React.useEffect(function() {
      if (typeof stackZIndex == "number") return CurrentPortalZIndices[id2] = stackZIndex, function() {
        delete CurrentPortalZIndices[id2];
      };
    }, [stackZIndex]), zIndex;
  } else {
    var _ZIndicesByContext, _stackLayer, {
      stackZIndex: stackZIndex1,
      zIndex: zIndexProp1
    } = props, id1 = React.useId(), stackingContextLevel = React.useContext(ZIndexStackContext), stackLayer = stackZIndex1 === "global" ? 0 : stackingContextLevel, hardcoded = React.useContext(ZIndexHardcodedContext);
    (_ZIndicesByContext = ZIndicesByContext)[_stackLayer = stackLayer] || (_ZIndicesByContext[_stackLayer] = {});
    var stackContext = ZIndicesByContext[stackLayer], zIndex1 = React.useMemo(function() {
      if (typeof zIndexProp1 == "number") return zIndexProp1;
      if (stackZIndex1) {
        if (hardcoded) return hardcoded + 1;
        var highest = Object.values(stackContext).reduce(function(acc, cur) {
          return Math.max(acc, cur);
        }, 0), found = stackLayer * 5e3 + highest + 1;
        return typeof stackZIndex1 == "number" ? stackZIndex1 + found : found;
      }
      return 1;
    }, [stackLayer, zIndexProp1, stackZIndex1]);
    return React.useEffect(function() {
      if (stackZIndex1) return stackContext[id1] = zIndex1, function() {
        delete stackContext[id1];
      };
    }, [zIndex1]), zIndex1;
  }
};
var StackZIndexContext = function(param) {
  var {
    children,
    zIndex
  } = param, existing = React.useContext(ZIndexStackContext), content = /* @__PURE__ */ jsxRuntimeExports.jsx(ZIndexStackContext.Provider, {
    value: existing + 1,
    children
  });
  return typeof zIndex < "u" && (content = /* @__PURE__ */ jsxRuntimeExports.jsx(ZIndexHardcodedContext.Provider, {
    value: zIndex,
    children: content
  })), content;
};
var _global__IS_FABRIC, IS_FABRIC = typeof global < "u" && !!((_global__IS_FABRIC = global._IS_FABRIC) !== null && _global__IS_FABRIC !== void 0 ? _global__IS_FABRIC : global.nativeFabricUIManager), USE_NATIVE_PORTAL = process.env.TAMAGUI_USE_NATIVE_PORTAL && process.env.TAMAGUI_USE_NATIVE_PORTAL !== "false" ? true : !isAndroid && !IS_FABRIC, allPortalHosts = /* @__PURE__ */ new Map(), portalListeners = {};
var ACTIONS = /* @__PURE__ */ (function(ACTIONS2) {
  return ACTIONS2[ACTIONS2.REGISTER_HOST = 0] = "REGISTER_HOST", ACTIONS2[ACTIONS2.DEREGISTER_HOST = 1] = "DEREGISTER_HOST", ACTIONS2[ACTIONS2.ADD_UPDATE_PORTAL = 2] = "ADD_UPDATE_PORTAL", ACTIONS2[ACTIONS2.REMOVE_PORTAL = 3] = "REMOVE_PORTAL", ACTIONS2;
})(ACTIONS || {}), INITIAL_STATE = {};
var registerHost = function(state, hostName) {
  return hostName in state || (state[hostName] = []), state;
}, deregisterHost = function(state, hostName) {
  return delete state[hostName], state;
}, addUpdatePortal = function(state, hostName, portalName, node) {
  hostName in state || (state = registerHost(state, hostName));
  var index2 = state[hostName].findIndex(function(item) {
    return item.name === portalName;
  });
  return index2 !== -1 ? state[hostName][index2].node = node : state[hostName].push({
    name: portalName,
    node
  }), state;
}, removePortal = function(state, hostName, portalName) {
  if (!(hostName in state)) return console.info(`Failed to remove portal '${portalName}', '${hostName}' was not registered!`), state;
  var index2 = state[hostName].findIndex(function(item) {
    return item.name === portalName;
  });
  return index2 !== -1 && state[hostName].splice(index2, 1), state;
}, reducer = function(state, action) {
  var {
    type
  } = action;
  switch (type) {
    case 0:
      return registerHost(__spreadValues({}, state), action.hostName);
    case 1:
      return deregisterHost(__spreadValues({}, state), action.hostName);
    case 2:
      return addUpdatePortal(__spreadValues({}, state), action.hostName, action.portalName, action.node);
    case 3:
      return removePortal(__spreadValues({}, state), action.hostName, action.portalName);
    default:
      return state;
  }
}, PortalStateContext = /* @__PURE__ */ React.createContext(null), PortalDispatchContext = /* @__PURE__ */ React.createContext(null), usePortalState = function(hostName) {
  var state = React.useContext(PortalStateContext);
  if (state === null) throw new Error("'PortalStateContext' cannot be null, please add 'PortalProvider' to the root component.");
  return state[hostName] || [];
}, usePortal = function() {
  var hostName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "root", dispatch = React.useContext(PortalDispatchContext);
  if (dispatch === null) throw new Error("'PortalDispatchContext' cannot be null, please add 'PortalProvider' to the root component.");
  var registerHost2 = React.useCallback(function() {
    dispatch({
      type: 0,
      hostName
    });
  }, []), deregisterHost2 = React.useCallback(function() {
    dispatch({
      type: 1,
      hostName
    });
  }, []), addUpdatePortal2 = React.useCallback(function(name, node) {
    dispatch({
      type: 2,
      hostName,
      portalName: name,
      node
    });
  }, []), removePortal2 = React.useCallback(function(name) {
    dispatch({
      type: 3,
      hostName,
      portalName: name
    });
  }, []);
  return {
    registerHost: registerHost2,
    deregisterHost: deregisterHost2,
    addPortal: addUpdatePortal2,
    updatePortal: addUpdatePortal2,
    removePortal: removePortal2
  };
}, PortalProviderComponent = function(param) {
  var {
    rootHostName = "root",
    shouldAddRootHost = true,
    children
  } = param, [state, dispatch] = React.useReducer(reducer, INITIAL_STATE), transitionDispatch = React.useMemo(function() {
    var next = function(value) {
      startTransition(function() {
        dispatch(value);
      });
    };
    return next;
  }, [dispatch]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalDispatchContext.Provider, {
    value: transitionDispatch,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(PortalStateContext.Provider, {
      value: state,
      children: [children, shouldAddRootHost && /* @__PURE__ */ jsxRuntimeExports.jsx(PortalHost, {
        name: rootHostName
      })]
    })
  });
}, PortalProvider = /* @__PURE__ */ React.memo(PortalProviderComponent);
PortalProvider.displayName = "PortalProvider";
var defaultRenderer = function(children) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children
  });
}, PortalHost = /* @__PURE__ */ React.memo(function(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalHostNonNative, __spreadValues({}, props));
});
function PortalHostNonNative(props) {
  var {
    name,
    forwardProps,
    render = defaultRenderer
  } = props, state = usePortalState(name), {
    registerHost: registerHost2,
    deregisterHost: deregisterHost2
  } = usePortal(props.name);
  return useIsomorphicLayoutEffect(function() {
    if (!(typeof window > "u")) return registerHost2(), function() {
      deregisterHost2();
    };
  }, []), render(forwardProps ? state.map(function(item) {
    var next = item.node, _a = forwardProps, {
      children
    } = _a, restForwardProps = __objRest(_a, [
      "children"
    ]);
    return forwardProps ? React.Children.map(next, function(child) {
      return /* @__PURE__ */ React.isValidElement(child) ? /* @__PURE__ */ React.cloneElement(child, __spreadValues({
        key: child.key
      }, restForwardProps)) : child;
    }) : next;
  }) : state.map(function(item) {
    return item.node;
  }));
}
var GorhomPortalItem = function(props) {
  var {
    name: _providedName,
    hostName,
    handleOnMount: _providedHandleOnMount,
    handleOnUnmount: _providedHandleOnUnmount,
    handleOnUpdate: _providedHandleOnUpdate,
    children,
    passThrough
  } = props, {
    addPortal: addUpdatePortal2,
    removePortal: removePortal2
  } = usePortal(hostName), id2 = React.useId(), name = _providedName || id2, handleOnMount = useEvent(function() {
    _providedHandleOnMount ? _providedHandleOnMount(function() {
      return addUpdatePortal2(name, children);
    }) : addUpdatePortal2(name, children);
  }), handleOnUnmount = useEvent(function() {
    _providedHandleOnUnmount ? _providedHandleOnUnmount(function() {
      return removePortal2(name);
    }) : removePortal2(name);
  }), handleOnUpdate = useEvent(function() {
    _providedHandleOnUpdate ? _providedHandleOnUpdate(function() {
      return addUpdatePortal2(name, children);
    }) : addUpdatePortal2(name, children);
  });
  return useIsomorphicLayoutEffect(function() {
    if (!passThrough) return handleOnMount(), function() {
      handleOnUnmount();
    };
  }, []), React.useEffect(function() {
    passThrough || handleOnUpdate();
  }, [children]), passThrough ? children : null;
};
var getStackedZIndexProps = function(propsIn) {
  return {
    stackZIndex: propsIn.stackZIndex,
    zIndex: resolveViewZIndex(propsIn.zIndex)
  };
}, resolveViewZIndex = function(zIndex) {
  return typeof zIndex > "u" || zIndex === "unset" ? void 0 : typeof zIndex == "number" ? zIndex : getTokenValue(zIndex, "zIndex");
};
var createPortal = (function() {
  if (IS_FABRIC) try {
    var _ReactFabricShimModule_default, ReactFabricShimModule = require("react-native/Libraries/Renderer/shims/ReactFabric"), _ReactFabricShimModule_default_createPortal;
    return (_ReactFabricShimModule_default_createPortal = ReactFabricShimModule == null || (_ReactFabricShimModule_default = ReactFabricShimModule.default) === null || _ReactFabricShimModule_default === void 0 ? void 0 : _ReactFabricShimModule_default.createPortal) !== null && _ReactFabricShimModule_default_createPortal !== void 0 ? _ReactFabricShimModule_default_createPortal : ReactFabricShimModule.createPortal;
  } catch (err) {
    return console.info("Note: error importing portal, defaulting to non-native portals", err), null;
  }
  try {
    var _ReactNativeShimModule_default, ReactNativeShimModule = require("react-native/Libraries/Renderer/shims/ReactNative"), _ReactNativeShimModule_default_createPortal;
    return (_ReactNativeShimModule_default_createPortal = ReactNativeShimModule == null || (_ReactNativeShimModule_default = ReactNativeShimModule.default) === null || _ReactNativeShimModule_default === void 0 ? void 0 : _ReactNativeShimModule_default.createPortal) !== null && _ReactNativeShimModule_default_createPortal !== void 0 ? _ReactNativeShimModule_default_createPortal : ReactNativeShimModule.createPortal;
  } catch (err) {
    return console.info("Note: error importing portal, defaulting to non-native portals", err), null;
  }
})(), Portal = function(propsIn) {
  var rootTag = React__namespace.useContext(RootTagContext), zIndex = useStackedZIndex(getStackedZIndexProps(propsIn)), {
    children,
    passThrough
  } = propsIn, contents = /* @__PURE__ */ jsxRuntimeExports.jsx(View, {
    pointerEvents: "box-none",
    position: "absolute",
    inset: 0,
    maxWidth: "100%",
    zIndex,
    passThrough,
    children
  });
  return !createPortal || !USE_NATIVE_PORTAL || !rootTag ? /* @__PURE__ */ jsxRuntimeExports.jsx(GorhomPortalItem, {
    passThrough,
    hostName: "root",
    children: contents
  }) : createPortal(contents, rootTag);
};
var AdaptContext = createStyledContext({
  Contents: null,
  scopeName: "",
  portalName: "",
  platform: null,
  setPlatform: function(x) {
  },
  when: null,
  setChildren: null,
  setWhen: function() {
  }
}), LastAdaptContextScope = /* @__PURE__ */ React.createContext(""), ProvideAdaptContext = function(param) {
  var _a = param, {
    children
  } = _a, context2 = __objRest(_a, [
    "children"
  ]), scope = context2.scopeName || "", lastScope = React.useContext(LastAdaptContextScope);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(LastAdaptContextScope.Provider, {
    value: lastScope || context2.lastScope || "",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(AdaptContext.Provider, __spreadProps(__spreadValues({
      scope,
      lastScope: lastScope || context2.lastScope
    }, context2), {
      children
    }))
  });
}, useAdaptContext = function(scope) {
  var lastScope = React.useContext(LastAdaptContextScope), adaptScope = scope != null ? scope : lastScope;
  return AdaptContext.useStyledContext(adaptScope);
}, AdaptPortals = /* @__PURE__ */ new Map(), AdaptParent = function(param) {
  var {
    children,
    Contents,
    scope,
    portal
  } = param, id2 = React.useId(), portalName = `AdaptPortal${scope}${id2}`, FinalContents = React.useMemo(function() {
    if (Contents) return Contents;
    if (AdaptPortals.has(portalName)) return AdaptPortals.get(portalName);
    var element = function() {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalHost, {
        name: portalName,
        forwardProps: typeof portal == "boolean" ? void 0 : portal == null ? void 0 : portal.forwardProps
      }, id2);
    };
    return AdaptPortals.set(portalName, element), element;
  }, [portalName, Contents]);
  useIsomorphicLayoutEffect(function() {
    return AdaptPortals.set(portalName, FinalContents), function() {
      AdaptPortals.delete(portalName);
    };
  }, [portalName]);
  var [when, setWhen] = React.useState(null), [platform2, setPlatform] = React.useState(null), [children2, setChildren] = React.useState(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(LastAdaptContextScope.Provider, {
    value: scope,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ProvideAdaptContext, {
      Contents: FinalContents,
      when,
      platform: platform2,
      setPlatform,
      setWhen,
      setChildren,
      portalName,
      scopeName: scope,
      children
    })
  });
}, AdaptContents = function(param) {
  var _a = param, {
    scope
  } = _a, rest = __objRest(_a, [
    "scope"
  ]), context2 = useAdaptContext(scope);
  if (!(context2 == null ? void 0 : context2.Contents)) throw new Error("tamagui.dev/docs/intro/errors#warning-002");
  return /* @__PURE__ */ React.createElement(context2.Contents, __spreadProps(__spreadValues({}, rest), {
    key: "stable"
  }));
};
AdaptContents.shouldForwardSpace = true;
var Adapt = withStaticProperties(function(props) {
  var {
    platform: platform2,
    when,
    children,
    scope
  } = props, context2 = useAdaptContext(scope), enabled = useAdaptIsActiveGiven(props);
  useIsomorphicLayoutEffect(function() {
    var _context_setWhen, _context_setPlatform;
    context2 == null || (_context_setWhen = context2.setWhen) === null || _context_setWhen === void 0 || _context_setWhen.call(context2, when || enabled), context2 == null || (_context_setPlatform = context2.setPlatform) === null || _context_setPlatform === void 0 || _context_setPlatform.call(context2, platform2 || null);
  }, [when, platform2, enabled, context2.setWhen, context2.setPlatform]), useIsomorphicLayoutEffect(function() {
    return function() {
      var _context_setWhen, _context_setPlatform;
      context2 == null || (_context_setWhen = context2.setWhen) === null || _context_setWhen === void 0 || _context_setWhen.call(context2, null), context2 == null || (_context_setPlatform = context2.setPlatform) === null || _context_setPlatform === void 0 || _context_setPlatform.call(context2, null);
    };
  }, []);
  var output;
  if (typeof children == "function") {
    var Component = context2 == null ? void 0 : context2.Contents;
    output = children(Component ? /* @__PURE__ */ jsxRuntimeExports.jsx(Component, {}) : null);
  } else output = children;
  return useIsomorphicLayoutEffect(function() {
    typeof children == "function" && output !== void 0 && (context2 == null ? void 0 : context2.setChildren(output));
  }, [output]), /* @__PURE__ */ jsxRuntimeExports.jsx(StackZIndexContext, {
    children: enabled ? output : null
  });
}, {
  Contents: AdaptContents
}), AdaptPortalContents = function(props) {
  var isActive = useAdaptIsActive(props.scope), {
    portalName
  } = useAdaptContext(props.scope);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GorhomPortalItem, {
    passThrough: !isActive,
    hostName: portalName,
    children: props.children
  });
}, useAdaptIsActiveGiven = function(param) {
  var {
    when,
    platform: platform2
  } = param, media = useMedia();
  if (when == null && platform2 == null) return false;
  if (when === true) return true;
  var enabled = false;
  return platform2 === "touch" ? enabled = isTouchable : platform2 === "native" ? enabled = !isWeb : platform2 === "web" ? enabled = isWeb : platform2 === "ios" ? enabled = isIos : platform2 === "android" && (enabled = isAndroid), platform2 && enabled == false ? false : (when && typeof when == "string" && (enabled = media[when]), enabled);
}, useAdaptIsActive = function(scope) {
  var props = useAdaptContext(scope);
  return useAdaptIsActiveGiven(props);
};
function createContext(rootComponentName, defaultContext) {
  var Context = /* @__PURE__ */ React__namespace.createContext(defaultContext);
  function Provider(props) {
    var _a = props, {
      children
    } = _a, context2 = __objRest(_a, [
      "children"
    ]), value = React__namespace.useMemo(function() {
      return context2;
    }, Object.values(context2));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, {
      value,
      children
    });
  }
  function useContext(consumerName) {
    var context2 = React__namespace.useContext(Context);
    if (context2) return context2;
    if (defaultContext !== void 0) return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  return [Provider, useContext];
}
function createContextScope(scopeName) {
  var createContextScopeDeps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], defaultContexts = [];
  function createContext2(rootComponentName, defaultContext) {
    var BaseContext = /* @__PURE__ */ React__namespace.createContext(defaultContext), index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    function Provider(props) {
      var _scope_scopeName, _a = props, {
        scope,
        children
      } = _a, context2 = __objRest(_a, [
        "scope",
        "children"
      ]), Context = (scope == null || (_scope_scopeName = scope[scopeName]) === null || _scope_scopeName === void 0 ? void 0 : _scope_scopeName[index2]) || BaseContext, value = React__namespace.useMemo(function() {
        return context2;
      }, Object.values(context2));
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, {
        value,
        children
      });
    }
    function useContext(consumerName, scope, options) {
      var _scope_scopeName, Context = (scope == null || (_scope_scopeName = scope[scopeName]) === null || _scope_scopeName === void 0 ? void 0 : _scope_scopeName[index2]) || BaseContext, context2 = React__namespace.useContext(Context);
      if (context2) return context2;
      if (defaultContext !== void 0) return defaultContext;
      var missingContextMessage = `\`${consumerName}\` must be used within \`${rootComponentName}\``;
      if (options == null ? void 0 : options.fallback) return (options == null ? void 0 : options.warn) !== false && console.warn(missingContextMessage), options.fallback;
      throw new Error(missingContextMessage);
    }
    return [Provider, useContext];
  }
  var createScope = function() {
    var scopeContexts = defaultContexts.map(function(defaultContext) {
      return /* @__PURE__ */ React__namespace.createContext(defaultContext);
    });
    return function(scope) {
      var contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return React__namespace.useMemo(function() {
        return {
          [`__scope${scopeName}`]: __spreadProps(__spreadValues({}, scope), {
            [scopeName]: contexts
          })
        };
      }, [scope, contexts]);
    };
  };
  return createScope.scopeName = scopeName, [createContext2, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes() {
  for (var _len = arguments.length, scopes = new Array(_len), _key = 0; _key < _len; _key++) scopes[_key] = arguments[_key];
  var baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  var createScope = function() {
    var scopeHooks = scopes.map(function(createScope2) {
      return {
        useScope: createScope2(),
        scopeName: createScope2.scopeName
      };
    });
    return function(overrideScopes) {
      var nextScopes = scopeHooks.reduce(function(nextScopes2, param) {
        var {
          useScope,
          scopeName
        } = param, scopeProps = useScope(overrideScopes), currentScope = scopeProps[`__scope${scopeName}`];
        return __spreadValues(__spreadValues({}, nextScopes2), currentScope);
      }, {});
      return React__namespace.useMemo(function() {
        return {
          [`__scope${baseScope.scopeName}`]: nextScopes
        };
      }, [nextScopes]);
    };
  };
  return createScope.scopeName = baseScope.scopeName, createScope;
}
var FOCUS_SCOPE_CONTROLLER_NAME = "FocusScopeController", [createFocusScopeControllerContext, createFocusScopeControllerScope] = createContextScope(FOCUS_SCOPE_CONTROLLER_NAME), [FocusScopeControllerProvider, useFocusScopeControllerContext] = createFocusScopeControllerContext(FOCUS_SCOPE_CONTROLLER_NAME);
function FocusScopeController(props) {
  var {
    __scopeFocusScope,
    children,
    enabled,
    loop,
    trapped,
    onMountAutoFocus,
    onUnmountAutoFocus,
    forceUnmount,
    focusOnIdle
  } = props, stableOnMountAutoFocus = useEvent(onMountAutoFocus), stableOnUnmountAutoFocus = useEvent(onUnmountAutoFocus), contextValue = React__namespace.useMemo(function() {
    return {
      enabled,
      loop,
      trapped,
      onMountAutoFocus: stableOnMountAutoFocus,
      onUnmountAutoFocus: stableOnUnmountAutoFocus,
      forceUnmount,
      focusOnIdle
    };
  }, [enabled, loop, trapped, stableOnMountAutoFocus, stableOnUnmountAutoFocus, forceUnmount, focusOnIdle]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FocusScopeControllerProvider, __spreadProps(__spreadValues({
    scope: __scopeFocusScope
  }, contextValue), {
    children
  }));
}
var FocusScopeControllerComponent = FocusScopeController;
var RemoveScroll = function(props) {
  return props.children;
};
var SHEET_NAME = "Sheet", SHEET_HANDLE_NAME = "SheetHandle", SHEET_OVERLAY_NAME = "SheetOverlay";
var [createSheetContext, createSheetScope] = createContextScope(SHEET_NAME), [SheetProvider, useSheetContext] = createSheetContext(SHEET_NAME, {});
var useSheetController = function() {
  var controller = React.useContext(SheetControllerContext), isHidden = controller == null ? void 0 : controller.hidden, isShowingNonSheet = isHidden && (controller == null ? void 0 : controller.open);
  return {
    controller,
    isHidden,
    isShowingNonSheet,
    disableDrag: controller == null ? void 0 : controller.disableDrag
  };
}, SheetControllerContext = /* @__PURE__ */ React.createContext(null);
var useSheetOpenState = function(props) {
  var {
    isHidden,
    controller
  } = useSheetController(), onOpenChangeInternal = function(val) {
    var _controller_onOpenChange, _props_onOpenChange;
    controller == null || (_controller_onOpenChange = controller.onOpenChange) === null || _controller_onOpenChange === void 0 || _controller_onOpenChange.call(controller, val), (_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 || _props_onOpenChange.call(props, val);
  }, _controller_open, _props_open, propVal = props.preferAdaptParentOpenState ? (_controller_open = controller == null ? void 0 : controller.open) !== null && _controller_open !== void 0 ? _controller_open : props.open : (_props_open = props.open) !== null && _props_open !== void 0 ? _props_open : controller == null ? void 0 : controller.open, _props_defaultOpen, [open2, setOpen] = useControllableState({
    prop: propVal,
    defaultProp: (_props_defaultOpen = props.defaultOpen) !== null && _props_defaultOpen !== void 0 ? _props_defaultOpen : false,
    onChange: onOpenChangeInternal,
    strategy: "most-recent-wins"
  });
  return {
    open: open2,
    setOpen,
    isHidden,
    controller
  };
};
function useSheetProviderProps(props, state) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, handleRef = React.useRef(null), contentRef = React.useRef(null), [frameSize, setFrameSize] = React.useState(0), [maxContentSize, setMaxContentSize] = React.useState(0), _props_snapPointsMode, snapPointsMode = (_props_snapPointsMode = props.snapPointsMode) !== null && _props_snapPointsMode !== void 0 ? _props_snapPointsMode : "percent", _props_snapPoints, snapPointsProp = (_props_snapPoints = props.snapPoints) !== null && _props_snapPoints !== void 0 ? _props_snapPoints : snapPointsMode === "percent" ? [80] : snapPointsMode === "constant" ? [256] : ["fit"], hasFit = snapPointsProp[0] === "fit", snapPoints = React.useMemo(function() {
    return props.dismissOnSnapToBottom ? [...snapPointsProp, 0] : snapPointsProp;
  }, [JSON.stringify(snapPointsProp), props.dismissOnSnapToBottom]), [position_, setPositionImmediate] = useControllableState({
    prop: props.position,
    defaultProp: props.defaultPosition || (state.open ? 0 : -1),
    onChange: props.onPositionChange,
    strategy: "most-recent-wins"
  }), position = state.open === false ? -1 : position_, {
    open: open2
  } = state, setPosition = React.useCallback(function(next) {
    props.dismissOnSnapToBottom && next === snapPoints.length - 1 ? state.setOpen(false) : setPositionImmediate(next);
  }, [props.dismissOnSnapToBottom, snapPoints.length, setPositionImmediate, state.setOpen]);
  open2 && props.dismissOnSnapToBottom && position === snapPoints.length - 1 && setPositionImmediate(0);
  var shouldSetPositionOpen = open2 && position < 0;
  React.useEffect(function() {
    shouldSetPositionOpen && setPosition(0);
  }, [setPosition, shouldSetPositionOpen]);
  var {
    animationDriver
  } = useConfiguration();
  if (!animationDriver) throw new Error(" 008");
  var scrollBridge = useConstant(function() {
    var parentDragListeners = /* @__PURE__ */ new Set(), bridge = {
      hasScrollableContent: false,
      enabled: false,
      y: 0,
      paneY: 0,
      paneMinY: 0,
      scrollStartY: -1,
      drag: function() {
      },
      release: function() {
      },
      scrollLock: false,
      isParentDragging: false,
      onParentDragging: function(cb) {
        return parentDragListeners.add(cb), function() {
          parentDragListeners.delete(cb);
        };
      },
      setParentDragging: function(val) {
        val !== bridge.isParentDragging && (bridge.isParentDragging = val, parentDragListeners.forEach(function(cb) {
          return cb(val);
        }));
      }
    };
    return bridge;
  }), _props_forceRemoveScrollEnabled, removeScrollEnabled = (_props_forceRemoveScrollEnabled = props.forceRemoveScrollEnabled) !== null && _props_forceRemoveScrollEnabled !== void 0 ? _props_forceRemoveScrollEnabled : open2 && props.modal, maxSnapPoint = snapPoints[0], screenSize = snapPointsMode === "percent" ? frameSize / ((typeof maxSnapPoint == "number" ? maxSnapPoint : 100) / 100) : maxContentSize, _props_dismissOnOverlayPress, _props_dismissOnSnapToBottom, providerProps = {
    screenSize,
    maxSnapPoint,
    removeScrollEnabled,
    scrollBridge,
    modal: !!props.modal,
    open: state.open,
    setOpen: state.setOpen,
    hidden: !!state.isHidden,
    contentRef,
    handleRef,
    frameSize,
    setFrameSize,
    dismissOnOverlayPress: (_props_dismissOnOverlayPress = props.dismissOnOverlayPress) !== null && _props_dismissOnOverlayPress !== void 0 ? _props_dismissOnOverlayPress : true,
    dismissOnSnapToBottom: (_props_dismissOnSnapToBottom = props.dismissOnSnapToBottom) !== null && _props_dismissOnSnapToBottom !== void 0 ? _props_dismissOnSnapToBottom : false,
    onOverlayComponent: options.onOverlayComponent,
    scope: props.__scopeSheet,
    hasFit,
    position,
    snapPoints,
    snapPointsMode,
    setMaxContentSize,
    setPosition,
    setPositionImmediate,
    onlyShowFrame: false
  };
  return providerProps;
}
var nativeSheets = {
  ios: null
};
function getNativeSheet(platform2) {
  return nativeSheets[platform2];
}
function setupNativeSheet(platform2, RNIOSModal) {
  var {
    ModalSheetView,
    ModalSheetViewMainContent
  } = RNIOSModal;
  platform2 === "ios" && (nativeSheets[platform2] = function(props) {
    var state = useSheetOpenState(props), providerProps = useSheetProviderProps(props, state), {
      open: open2,
      setOpen
    } = state, ref = React.useRef(void 0);
    React.useEffect(function() {
      if (open2) {
        var _ref_current;
        (_ref_current = ref.current) === null || _ref_current === void 0 || _ref_current.presentModal();
      } else {
        var _ref_current1;
        (_ref_current1 = ref.current) === null || _ref_current1 === void 0 || _ref_current1.dismissModal();
      }
    }, [open2]);
    function setOpenInternal(next) {
      var _props_onOpenChange;
      (_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 || _props_onOpenChange.call(props, open2), setOpen(next);
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(SheetProvider, __spreadProps(__spreadValues({
        setHasScrollView: emptyFn
      }, providerProps), {
        onlyShowFrame: true,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ModalSheetView, {
            ref,
            onModalDidDismiss: function() {
              return setOpenInternal(false);
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(ModalSheetViewMainContent, {
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(View$1, {
                style: {
                  flex: 1
                },
                children: props.children
              })
            })
          }),
          /* for some reason select triggers wont show on native if this isn't inside the actual tree not inside implementation... */
          /* so just hiding it here for now... not great... */
          /* @__PURE__ */ jsxRuntimeExports.jsx(YStack, {
            position: "absolute",
            opacity: 0,
            pointerEvents: "none",
            width: 0,
            height: 0,
            children: props.children
          })
        ]
      }))
    });
  });
}
var emptyFn = function() {
};
var ParentSheetContext = React.createContext({
  zIndex: 1e5
}), SheetInsideSheetContext = React.createContext(null);
function resisted(y, minY) {
  if (y >= minY) return y;
  var pastBoundary = minY - y, resistedDistance = Math.sqrt(pastBoundary) * 2;
  return minY - resistedDistance;
}
var hiddenSize = 10000.1, relativeDimensionTo = "screen", SheetImplementationCustom = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var parentSheet = React.useContext(ParentSheetContext), {
    animation,
    animationConfig: animationConfigProp,
    modal = false,
    zIndex = parentSheet.zIndex + 1,
    moveOnKeyboardChange = false,
    unmountChildrenWhenHidden = false,
    portalProps,
    containerComponent: ContainerComponent = React.Fragment
  } = props, state = useSheetOpenState(props), [overlayComponent, setOverlayComponent] = React.useState(null), providerProps = useSheetProviderProps(props, state, {
    onOverlayComponent: setOverlayComponent
  }), {
    frameSize,
    setFrameSize,
    snapPoints,
    snapPointsMode,
    hasFit,
    position,
    setPosition,
    scrollBridge,
    screenSize,
    setMaxContentSize,
    maxSnapPoint
  } = providerProps, {
    open: open2,
    controller,
    isHidden
  } = state, sheetRef = React.useRef(void 0), ref = useComposedRefs(forwardedRef, sheetRef, providerProps.contentRef), {
    animationDriver
  } = useConfiguration();
  if (!animationDriver) throw new Error("Sheet reqiures an animation driver to be set");
  var animationConfig = (function() {
    if (animationDriver.supportsCSS) return {};
    var [animationProp, animationPropConfig] = animation ? Array.isArray(animation) ? animation : [animation] : [];
    return animationConfigProp != null ? animationConfigProp : animationProp ? __spreadValues(__spreadValues({}, animationDriver.animations[animationProp]), animationPropConfig) : null;
  })(), [isShowingInnerSheet, setIsShowingInnerSheet] = React.useState(false), shouldHideParentSheet = modal && isShowingInnerSheet && // if not using weird portal limitation we dont need to hide parent sheet
  USE_NATIVE_PORTAL, sheetInsideSheet = React.useContext(SheetInsideSheetContext), onInnerSheet = React.useCallback(function(hasChild) {
    setIsShowingInnerSheet(hasChild);
  }, []), positions = React.useMemo(function() {
    return snapPoints.map(function(point) {
      return getYPositions(snapPointsMode, point, screenSize, frameSize);
    });
  }, [screenSize, frameSize, snapPoints, snapPointsMode]), {
    useAnimatedNumber,
    useAnimatedNumberStyle,
    useAnimatedNumberReaction
  } = animationDriver, _animationDriver_View, AnimatedView = (_animationDriver_View = animationDriver.View) !== null && _animationDriver_View !== void 0 ? _animationDriver_View : Stack;
  useIsomorphicLayoutEffect(function() {
    if (sheetInsideSheet && open2) return sheetInsideSheet(true), function() {
      sheetInsideSheet(false);
    };
  }, [sheetInsideSheet, open2]);
  var nextParentContext = React.useMemo(function() {
    return {
      zIndex
    };
  }, [zIndex]);
  useDidFinishSSR();
  var startPosition = screenSize ? screenSize : hiddenSize, animatedNumber = useAnimatedNumber(startPosition), at = React.useRef(startPosition), hasntMeasured = at.current === hiddenSize, [disableAnimation, setDisableAnimation] = React.useState(hasntMeasured), hasScrollView = React.useRef(false);
  useAnimatedNumberReaction({
    value: animatedNumber,
    hostRef: sheetRef
  }, React.useCallback(function(value) {
    at.current = value, scrollBridge.paneY = value;
  }, [animationDriver]));
  function stopSpring() {
    animatedNumber.stop(), scrollBridge.onFinishAnimate && (scrollBridge.onFinishAnimate(), scrollBridge.onFinishAnimate = void 0);
  }
  var animateTo = useEvent(function(position2) {
    if (frameSize !== 0) {
      var toValue = isHidden || position2 === -1 ? screenSize : positions[position2];
      at.current !== toValue && (at.current = toValue, stopSpring(), animatedNumber.setValue(toValue, __spreadValues({
        type: "spring"
      }, animationConfig)));
    }
  });
  useIsomorphicLayoutEffect(function() {
    if (hasntMeasured && screenSize && frameSize) {
      at.current = screenSize, animatedNumber.setValue(screenSize, {
        type: "timing",
        duration: 0
      }, function() {
        setTimeout(function() {
          setDisableAnimation(false);
        }, 10);
      });
      return;
    }
    disableAnimation || !frameSize || !screenSize || isHidden || hasntMeasured && !open2 || (animateTo(position), position === -1 && (scrollBridge.scrollLock = false, scrollBridge.scrollStartY = -1));
  }, [hasntMeasured, disableAnimation, isHidden, frameSize, screenSize, open2, position]);
  var _props_disableDrag, disableDrag = (_props_disableDrag = props.disableDrag) !== null && _props_disableDrag !== void 0 ? _props_disableDrag : controller == null ? void 0 : controller.disableDrag, themeName = useThemeName(), [isDragging, setIsDragging] = React.useState(false), panResponder = React.useMemo(function() {
    if (disableDrag || !frameSize || isShowingInnerSheet) return;
    var minY = positions[0];
    scrollBridge.paneMinY = minY;
    var startY = at.current;
    function setPanning(val) {
      setIsDragging(val);
    }
    var release = function(param) {
      var {
        vy,
        dragAt
      } = param;
      if (scrollBridge.setParentDragging(false), !scrollBridge.scrollLock) {
        isExternalDrag = false, setPanning(false);
        for (var at2 = dragAt + startY, end = at2 + frameSize * vy * 0.2, closestPoint = 0, dist = Number.POSITIVE_INFINITY, i = 0; i < positions.length; i++) {
          var position2 = positions[i], curDist = end > position2 ? end - position2 : position2 - end;
          curDist < dist && (dist = curDist, closestPoint = i);
        }
        setPosition(closestPoint), animateTo(closestPoint);
      }
    }, finish = function(_e, state2) {
      release({
        vy: state2.vy,
        dragAt: state2.dy
      });
    }, onMoveShouldSet = function(e2, param) {
      var {
        dy
      } = param;
      function getShouldSet() {
        if (e2.target === providerProps.handleRef.current) return true;
        if (scrollBridge.hasScrollableContent === true) {
          if (scrollBridge.scrollLock) return false;
          var isScrolled = scrollBridge.y !== 0, isDraggingUp = dy < 0, isNearTop = scrollBridge.paneY - 5 <= scrollBridge.paneMinY;
          if (isScrolled) return false;
          if (isNearTop && hasScrollView.current && isDraggingUp) return false;
        }
        return Math.abs(dy) > 10;
      }
      var granted = getShouldSet();
      return granted && scrollBridge.setParentDragging(true), granted;
    }, grant = function() {
      setPanning(true), stopSpring(), startY = at.current;
    }, isExternalDrag = false;
    return scrollBridge.drag = function(dy) {
      isExternalDrag || (isExternalDrag = true, grant());
      var to = dy + startY;
      animatedNumber.setValue(resisted(to, minY), {
        type: "direct"
      });
    }, scrollBridge.release = release, PanResponder_default.create({
      onMoveShouldSetPanResponder: onMoveShouldSet,
      onPanResponderGrant: grant,
      onPanResponderMove: function(_e, param) {
        var {
          dy
        } = param, toFull = dy + startY, to = resisted(toFull, minY), isAtTop = to <= minY;
        isAtTop ? scrollBridge.setParentDragging(false) : scrollBridge.setParentDragging(true), animatedNumber.setValue(to, {
          type: "direct"
        });
      },
      onPanResponderEnd: finish,
      onPanResponderTerminate: finish,
      onPanResponderRelease: finish
    });
  }, [disableDrag, isShowingInnerSheet, animateTo, frameSize, positions, setPosition]), handleAnimationViewLayout = React.useCallback(function(e2) {
    var _e_nativeEvent, next = Math.min((_e_nativeEvent = e2.nativeEvent) === null || _e_nativeEvent === void 0 ? void 0 : _e_nativeEvent.layout.height, Dimensions.get(relativeDimensionTo).height);
    next && setFrameSize(next);
  }, []), handleMaxContentViewLayout = React.useCallback(function(e2) {
    var _e_nativeEvent, next = Math.min((_e_nativeEvent = e2.nativeEvent) === null || _e_nativeEvent === void 0 ? void 0 : _e_nativeEvent.layout.height, Dimensions.get(relativeDimensionTo).height);
    next && setMaxContentSize(next);
  }, []), animatedStyle = useAnimatedNumberStyle(animatedNumber, function(val) {
    "worklet";
    var translateY = frameSize === 0 ? hiddenSize : val;
    return {
      transform: [{
        translateY
      }]
    };
  }), sizeBeforeKeyboard = React.useRef(null);
  React.useEffect(function() {
    if (!!moveOnKeyboardChange) {
      var keyboardShowListener = Keyboard.addListener(currentPlatform === "ios" ? "keyboardWillShow" : "keyboardDidShow", function(e2) {
        sizeBeforeKeyboard.current === null && (sizeBeforeKeyboard.current = isHidden || position === -1 ? screenSize : positions[position], animatedNumber.setValue(Math.max(sizeBeforeKeyboard.current - e2.endCoordinates.height, 0), {
          type: "timing",
          duration: 250
        }));
      }), keyboardDidHideListener = Keyboard.addListener("keyboardDidHide", function() {
        sizeBeforeKeyboard.current !== null && (animatedNumber.setValue(sizeBeforeKeyboard.current, {
          type: "timing",
          duration: 250
        }), sizeBeforeKeyboard.current = null);
      });
      return function() {
        keyboardDidHideListener.remove(), keyboardShowListener.remove();
      };
    }
  }, [moveOnKeyboardChange, positions, position, isHidden]);
  var [opacity, setOpacity] = React.useState(open2 ? 1 : 0);
  open2 && opacity === 0 && setOpacity(1), React.useEffect(function() {
    if (!open2) {
      var tm = setTimeout(function() {
        setOpacity(0);
      }, 400);
      return function() {
        clearTimeout(tm);
      };
    }
  }, [open2]);
  var forcedContentHeight = hasFit ? void 0 : snapPointsMode === "percent" ? `${maxSnapPoint}${"%"}` : maxSnapPoint, setHasScrollView = React.useCallback(function(val) {
    hasScrollView.current = val;
  }, []), contents = /* @__PURE__ */ jsxRuntimeExports.jsx(LayoutMeasurementController, {
    disable: !open2,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ParentSheetContext.Provider, {
      value: nextParentContext,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(SheetProvider, __spreadProps(__spreadValues({}, providerProps), {
        setHasScrollView,
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, {
          custom: {
            open: open2
          },
          children: shouldHideParentSheet || !open2 ? null : overlayComponent
        }), snapPointsMode !== "percent" && /* @__PURE__ */ jsxRuntimeExports.jsx(View$1, {
          style: {
            opacity: 0,
            position: "absolute",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            pointerEvents: "none"
          },
          onLayout: handleMaxContentViewLayout
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatedView, __spreadProps(__spreadValues({
          ref
        }, panResponder == null ? void 0 : panResponder.panHandlers), {
          onLayout: handleAnimationViewLayout,
          // @ts-ignore for CSS driver this is necessary to attach the transition
          // also motion driver at least though i suspect all drivers?
          animation: isDragging || disableAnimation ? null : animation,
          // @ts-ignore
          disableClassName: true,
          style: [__spreadValues({
            position: "absolute",
            zIndex,
            width: "100%",
            height: forcedContentHeight,
            minHeight: forcedContentHeight,
            opacity: shouldHideParentSheet ? 0 : opacity
          }, (shouldHideParentSheet || !open2) && {
            pointerEvents: "none"
          }), animatedStyle],
          children: (
            /* <AdaptProvider>{props.children}</AdaptProvider> */
            props.children
          )
        }))]
      }))
    })
  });
  if (!USE_NATIVE_PORTAL) {
    var adaptContext = useAdaptContext();
    contents = /* @__PURE__ */ jsxRuntimeExports.jsx(ProvideAdaptContext, __spreadProps(__spreadValues({}, adaptContext), {
      children: (
        /* @ts-ignore */
        contents
      )
    }));
  }
  var shouldMountChildren = unmountChildrenWhenHidden ? !!opacity : true;
  if (modal) {
    var modalContents = /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, __spreadProps(__spreadValues({
      stackZIndex: zIndex
    }, portalProps), {
      children: shouldMountChildren && /* @__PURE__ */ jsxRuntimeExports.jsx(ContainerComponent, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Theme, {
          contain: true,
          forceClassName: true,
          name: themeName,
          children: contents
        })
      })
    }));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SheetInsideSheetContext.Provider, {
      value: onInnerSheet,
      children: modalContents
    });
  }
  return contents;
});
function getYPositions(mode, point, screenSize, frameSize) {
  if (!screenSize || !frameSize) return 0;
  if (mode === "mixed") {
    if (typeof point == "number") return screenSize - Math.min(screenSize, Math.max(0, point));
    if (point === "fit") return screenSize - Math.min(screenSize, frameSize);
    if (point.endsWith("%")) {
      var pct = Math.min(100, Math.max(0, Number(point.slice(0, -1)))) / 100;
      if (Number.isNaN(pct)) return console.warn("Invalid snapPoint percentage string"), 0;
      var next = Math.round(screenSize - pct * screenSize);
      return next;
    }
    return console.warn("Invalid snapPoint unknown value"), 0;
  }
  if (mode === "fit") return point === 0 ? screenSize : screenSize - Math.min(screenSize, frameSize);
  if (mode === "constant" && typeof point == "number") return screenSize - Math.min(screenSize, Math.max(0, point));
  var pct1 = Math.min(100, Math.max(0, Number(point))) / 100;
  return Number.isNaN(pct1) ? (console.warn("Invalid snapPoint percentage"), 0) : Math.round(screenSize - pct1 * screenSize);
}
var ScrollView2 = styled(ForwardedScrollView, {
  name: "ScrollView",
  scrollEnabled: true,
  variants: {
    fullscreen: {
      true: fullscreenStyle
    }
  }
}, {
  accept: {
    contentContainerStyle: "style"
  }
});
var SHEET_SCROLL_VIEW_NAME = "SheetScrollView", SheetScrollView = /* @__PURE__ */ React.forwardRef(
  // we disallow customizing it because we want to let people know it doens't work well with out measuring of inner content
  // height using a view
  function(param, ref) {
    var _a = param, {
      __scopeSheet,
      children,
      onScroll,
      scrollEnabled: scrollEnabledProp
    } = _a, props = __objRest(_a, [
      "__scopeSheet",
      "children",
      "onScroll",
      "scrollEnabled"
    ]), context2 = useSheetContext(SHEET_SCROLL_VIEW_NAME, __scopeSheet), {
      scrollBridge,
      setHasScrollView
    } = context2, [scrollEnabled, setScrollEnabled_] = useControllableState({
      prop: scrollEnabledProp,
      defaultProp: true
    }), scrollRef = React.useRef(null), setScrollEnabled = function(next) {
      var _scrollRef_current_setNativeProps, _scrollRef_current;
      (_scrollRef_current = scrollRef.current) === null || _scrollRef_current === void 0 || (_scrollRef_current_setNativeProps = _scrollRef_current.setNativeProps) === null || _scrollRef_current_setNativeProps === void 0 || _scrollRef_current_setNativeProps.call(_scrollRef_current, {
        scrollEnabled: next
      }), setScrollEnabled_(next);
    }, state = React.useRef({
      lastPageY: 0,
      dragAt: 0,
      dys: [],
      // store a few recent dys to get velocity on release
      isScrolling: false,
      isDraggingScrollArea: false
    });
    React.useEffect(function() {
      return setHasScrollView(true), function() {
        setHasScrollView(false);
      };
    }, []);
    var release = function() {
      if (state.current.isDraggingScrollArea) {
        state.current.isDraggingScrollArea = false, scrollBridge.scrollStartY = -1, scrollBridge.scrollLock = false, state.current.isScrolling = false, setScrollEnabled(true);
        var vy = 0;
        if (state.current.dys.length) {
          var recentDys = state.current.dys.slice(-10), dist = recentDys.length ? recentDys.reduce(function(a, b2) {
            return a + b2;
          }, 0) : 0, avgDy = dist / recentDys.length;
          vy = avgDy * 0.04;
        }
        state.current.dys = [], scrollBridge.release({
          dragAt: state.current.dragAt,
          vy
        });
      }
    }, scrollable = scrollEnabled;
    React.useEffect(function() {
    }, [scrollRef]);
    var [hasScrollableContent, setHasScrollableContent] = React.useState(true), parentHeight = React.useRef(0), contentHeight = React.useRef(0), setIsScrollable = function() {
      parentHeight.current && contentHeight.current && setHasScrollableContent(contentHeight.current > parentHeight.current);
    };
    return React.useEffect(function() {
      scrollBridge.hasScrollableContent = hasScrollableContent;
    }, [hasScrollableContent]), /* @__PURE__ */ jsxRuntimeExports.jsxs(ScrollView2, __spreadProps(__spreadValues({
      onLayout: function(e2) {
        parentHeight.current = Math.ceil(e2.nativeEvent.layout.height), setIsScrollable();
      },
      ref: composeRefs(scrollRef, ref),
      flex: 1,
      scrollEventThrottle: 8,
      onResponderRelease: release,
      className: "_ovs-contain",
      scrollEnabled: scrollable,
      // {...(Platform.OS === 'android' && {
      //   pointerEvents: scrollable ? undefined : 'none',
      // })}
      onScroll: function(e2) {
        var {
          y
        } = e2.nativeEvent.contentOffset;
        scrollBridge.y = y, y > 0 && (scrollBridge.scrollStartY = -1), onScroll == null ? void 0 : onScroll(e2);
      },
      // This assures that we do not skip the "scrollBridge" values processing
      // when passing this prop into a <Sheet.ScrollView /> overriding it here
      // Useful when using this ScrollView with lists such as "FlashList", i.e.
      // ```
      // renderScrollComponent={Sheet.ScrollView}
      // ```
      onStartShouldSetResponder: function() {
        return scrollBridge.scrollStartY = -1, state.current.isDraggingScrollArea = true, scrollable;
      },
      // setting to false while onResponderMove is disabled
      onMoveShouldSetResponder: function(e2) {
        return scrollable;
      },
      contentContainerStyle: {
        minHeight: "100%"
      },
      onResponderMove: function(e2) {
      }
    }, props), {
      children: [
        /* content height measurer */
        /* @__PURE__ */ jsxRuntimeExports.jsx(View, {
          position: "absolute",
          inset: 0,
          pointerEvents: "none",
          zIndex: -1,
          onLayout: function(e2) {
            contentHeight.current = Math.floor(e2.nativeEvent.layout.height), setIsScrollable();
          }
        }),
        children
      ]
    }));
  }
);
var useSheetOffscreenSize = function(param) {
  var {
    snapPoints,
    position,
    screenSize,
    frameSize,
    snapPointsMode
  } = param;
  if (snapPointsMode === "fit") return 0;
  if (snapPointsMode === "constant") {
    var maxSize = Number(snapPoints[0]), _snapPoints_position, currentSize = Number((_snapPoints_position = snapPoints[position]) !== null && _snapPoints_position !== void 0 ? _snapPoints_position : 0), offscreenSize = maxSize - currentSize;
    return offscreenSize;
  }
  if (snapPointsMode === "percent") {
    var maxPercentOpened = Number(snapPoints[0]) / 100, _snapPoints_position1, percentOpened = Number((_snapPoints_position1 = snapPoints[position]) !== null && _snapPoints_position1 !== void 0 ? _snapPoints_position1 : 0) / 100, percentHidden = maxPercentOpened - percentOpened, offscreenSize1 = percentHidden * screenSize;
    return offscreenSize1;
  }
  var maxSnapPoint = snapPoints[0];
  if (maxSnapPoint === "fit") return 0;
  var maxSize1 = typeof maxSnapPoint == "string" ? Number(maxSnapPoint.slice(0, -1)) / 100 * screenSize : maxSnapPoint, _snapPoints_position2, currentSnapPoint = (_snapPoints_position2 = snapPoints[position]) !== null && _snapPoints_position2 !== void 0 ? _snapPoints_position2 : 0, currentSize1 = typeof currentSnapPoint == "string" ? Number(currentSnapPoint.slice(0, -1)) / 100 * screenSize : currentSnapPoint, offscreenSize2 = maxSize1 - currentSize1;
  return Number.isNaN(offscreenSize2) ? 0 : offscreenSize2;
};
function createSheet(param) {
  var {
    Handle: Handle2,
    Frame: Frame2,
    Overlay: Overlay2
  } = param, SheetHandle = Handle2.styleable(function(param2, forwardedRef) {
    var _a = param2, {
      __scopeSheet
    } = _a, props = __objRest(_a, [
      "__scopeSheet"
    ]), context2 = useSheetContext(SHEET_HANDLE_NAME, __scopeSheet), composedRef = useComposedRefs(context2.handleRef, forwardedRef);
    return context2.onlyShowFrame ? null : (
      // @ts-ignore
      /* @__PURE__ */ jsxRuntimeExports.jsx(Handle2, __spreadValues({
        ref: composedRef,
        onPress: function() {
          var max2 = context2.snapPoints.length + (context2.dismissOnSnapToBottom ? -1 : 0), nextPos = (context2.position + 1) % max2;
          context2.setPosition(nextPos);
        },
        open: context2.open
      }, props))
    );
  }), SheetOverlay = Overlay2.extractable(/* @__PURE__ */ React.memo(function(propsIn) {
    var _a = propsIn, {
      __scopeSheet
    } = _a, props = __objRest(_a, [
      "__scopeSheet"
    ]), context2 = useSheetContext(SHEET_OVERLAY_NAME, __scopeSheet), element = React.useMemo(function() {
      return (
        // @ts-ignore
        /* @__PURE__ */ jsxRuntimeExports.jsx(Overlay2, __spreadProps(__spreadValues({}, props), {
          onPress: composeEventHandlers(props.onPress, context2.dismissOnOverlayPress ? function() {
            context2.setOpen(false);
          } : void 0)
        }))
      );
    }, [props.onPress, props.opacity, context2.dismissOnOverlayPress]);
    return useIsomorphicLayoutEffect(function() {
      var _context_onOverlayComponent;
      (_context_onOverlayComponent = context2.onOverlayComponent) === null || _context_onOverlayComponent === void 0 || _context_onOverlayComponent.call(context2, element);
    }, [element]), context2.onlyShowFrame, null;
  })), SheetFrame = Frame2.extractable(/* @__PURE__ */ React.forwardRef(function(param2, forwardedRef) {
    var _a = param2, {
      __scopeSheet,
      adjustPaddingForOffscreenContent,
      disableHideBottomOverflow,
      children
    } = _a, props = __objRest(_a, [
      "__scopeSheet",
      "adjustPaddingForOffscreenContent",
      "disableHideBottomOverflow",
      "children"
    ]), context2 = useSheetContext(SHEET_NAME, __scopeSheet), {
      hasFit,
      removeScrollEnabled = true,
      frameSize,
      contentRef,
      open: open2
    } = context2, composedContentRef = useComposedRefs(forwardedRef, contentRef), offscreenSize = useSheetOffscreenSize(context2), sheetContents = React.useMemo(function() {
      return (
        // @ts-expect-error
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Frame2, __spreadProps(__spreadValues({
          ref: composedContentRef,
          flex: hasFit ? 0 : 1,
          height: hasFit ? void 0 : frameSize,
          pointerEvents: open2 ? "auto" : "none"
        }, props), {
          children: [/* @__PURE__ */ jsxRuntimeExports.jsx(StackZIndexContext, {
            zIndex: resolveViewZIndex(props.zIndex),
            children
          }), adjustPaddingForOffscreenContent && /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, {
            "data-sheet-offscreen-pad": true,
            height: offscreenSize,
            width: "100%"
          })]
        }))
      );
    }, [open2, props, frameSize, offscreenSize, adjustPaddingForOffscreenContent, hasFit]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(RemoveScroll, {
          enabled: removeScrollEnabled && context2.open,
          children: sheetContents
        }),
        /* below frame hide when bouncing past 100% */
        !disableHideBottomOverflow && // @ts-ignore
        /* @__PURE__ */ jsxRuntimeExports.jsx(Frame2, __spreadProps(__spreadValues({}, props), {
          "data-testid": "ensure-sheet-cover-not-overlapping",
          componentName: "SheetCover",
          // biome-ignore lint/correctness/noChildrenProp: <explanation>
          children: null,
          position: "absolute",
          bottom: "-100%",
          zIndex: -1,
          height: context2.frameSize,
          left: 0,
          right: 0,
          borderWidth: 0,
          borderRadius: 0,
          shadowOpacity: 0
        }))
      ]
    });
  })), Sheet2 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
    useDidFinishSSR();
    var {
      isShowingNonSheet
    } = useSheetController(), SheetImplementation = SheetImplementationCustom;
    if (props.native && Platform.OS === "ios") ;
    return isShowingNonSheet || false ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(SheetImplementation, __spreadValues({
      ref
    }, props));
  }), components = {
    Frame: SheetFrame,
    Overlay: SheetOverlay,
    Handle: SheetHandle,
    ScrollView: SheetScrollView
  }, Controlled = withStaticProperties(Sheet2, components);
  return withStaticProperties(Sheet2, __spreadProps(__spreadValues({}, components), {
    Controlled
  }));
}
var Handle = styled(XStack, {
  name: SHEET_HANDLE_NAME,
  variants: {
    open: {
      true: {
        opacity: 1,
        pointerEvents: "auto"
      },
      false: {
        opacity: 0,
        pointerEvents: "none"
      }
    },
    unstyled: {
      false: {
        height: 10,
        borderRadius: 100,
        backgroundColor: "$background",
        zIndex: 10,
        marginHorizontal: "35%",
        marginBottom: "$2",
        opacity: 0.5,
        hoverStyle: {
          opacity: 0.7
        }
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), Overlay = styled(ThemeableStack, {
  name: SHEET_OVERLAY_NAME,
  variants: {
    open: {
      true: {
        pointerEvents: "auto"
      },
      false: {
        pointerEvents: "none"
      }
    },
    unstyled: {
      false: {
        fullscreen: true,
        position: "absolute",
        backgrounded: true,
        zIndex: 99999,
        pointerEvents: "auto"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), Frame = styled(YStack, {
  name: SHEET_NAME,
  variants: {
    unstyled: {
      false: {
        flex: 1,
        backgroundColor: "$background",
        borderTopLeftRadius: "$true",
        borderTopRightRadius: "$true",
        width: "100%",
        maxHeight: "100%",
        overflow: "hidden"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), Sheet = createSheet({
  Frame,
  Handle,
  Overlay
}), SheetOverlayFrame = Overlay, SheetHandleFrame = Handle;
var useSheet = function() {
  return useSheetContext("", void 0);
};
var SheetController = function(param) {
  var {
    children,
    onOpenChange: onOpenChangeProp,
    open: open2,
    hidden,
    disableDrag
  } = param, onOpenChange = useEvent(onOpenChangeProp), id2 = React.useId(), memoValue = React.useMemo(function() {
    return {
      id: id2,
      open: open2,
      hidden,
      disableDrag,
      onOpenChange
    };
  }, [id2, onOpenChange, open2, hidden, disableDrag]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SheetControllerContext.Provider, {
    value: memoValue,
    children
  });
};
function _instanceof(left, right) {
  return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
}
var DialogContext = createStyledContext(
  // since we always provide this we can avoid setting here
  {},
  "Dialog__"
), {
  useStyledContext: useDialogContext,
  Provider: DialogProvider
} = DialogContext, DialogTriggerFrame = styled(View, {
  name: "DialogTrigger"
}), DialogTrigger = DialogTriggerFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, triggerProps = __objRest(_a, [
    "scope"
  ]), isInsideButton = React__namespace.useContext(ButtonNestingContext), context2 = useDialogContext(scope), composedTriggerRef = useComposedRefs(forwardedRef, context2.triggerRef);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonNestingContext.Provider, {
    value: true,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTriggerFrame, __spreadProps(__spreadValues({
      tag: isInsideButton ? "span" : "button",
      "aria-haspopup": "dialog",
      "aria-expanded": context2.open,
      "aria-controls": context2.contentId,
      "data-state": getState$2(context2.open)
    }, triggerProps), {
      ref: composedTriggerRef,
      onPress: composeEventHandlers(props.onPress, context2.onOpenToggle)
    }))
  });
}), DialogPortalFrame = styled(YStack, {
  pointerEvents: "none",
  tag: "dialog",
  variants: {
    unstyled: {
      false: {
        alignItems: "center",
        justifyContent: "center",
        fullscreen: true,
        "$platform-web": {
          // undo dialog styles
          borderWidth: 0,
          backgroundColor: "transparent",
          color: "inherit",
          maxInlineSize: "none",
          margin: 0,
          width: "auto",
          height: "auto",
          // ensure always in frame and right height
          maxHeight: "100vh",
          position: "fixed"
        }
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), needsRepropagation$1 = isAndroid || isIos && !USE_NATIVE_PORTAL, DialogPortalItem = function(param) {
  var {
    context: context2,
    children
  } = param, themeName = useThemeName(), isAdapted = useAdaptIsActive(context2.adaptScope), adaptContext = useAdaptContext(context2.adaptScope), content = /* @__PURE__ */ jsxRuntimeExports.jsx(Theme, {
    name: themeName,
    children
  });
  return needsRepropagation$1 && (content = /* @__PURE__ */ jsxRuntimeExports.jsx(ProvideAdaptContext, __spreadProps(__spreadValues({}, adaptContext), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogProvider, __spreadProps(__spreadValues({}, context2), {
      children: content
    }))
  }))), isAdapted ? /* @__PURE__ */ jsxRuntimeExports.jsx(AdaptPortalContents, {
    scope: context2.adaptScope,
    children: content
  }) : context2.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(GorhomPortalItem, {
    hostName: context2.modal ? "root" : context2.adaptScope,
    children: content
  }) : content;
}, DialogPortal = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardRef) {
  var _a = props, {
    scope,
    forceMount,
    children
  } = _a, frameProps = __objRest(_a, [
    "scope",
    "forceMount",
    "children"
  ]), dialogRef = React__namespace.useRef(null), ref = composeRefs(dialogRef, forwardRef), context2 = useDialogContext(scope), isMountedOrOpen = forceMount || context2.open, [isFullyHidden, setIsFullyHidden] = React__namespace.useState(!isMountedOrOpen), isAdapted = useAdaptIsActive(context2.adaptScope);
  isMountedOrOpen && isFullyHidden && setIsFullyHidden(false);
  var handleExitComplete = React__namespace.useCallback(function() {
    setIsFullyHidden(true);
  }, []), zIndex = getExpandedShorthand("zIndex", props), contents = /* @__PURE__ */ jsxRuntimeExports.jsx(StackZIndexContext, {
    zIndex: resolveViewZIndex(zIndex),
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, {
      passThrough: isAdapted,
      onExitComplete: handleExitComplete,
      children: isMountedOrOpen || isAdapted ? children : null
    })
  }), framedContents = (
    // NOTE: we remove the inner frame, but not the portal itself
    // saw a bug when we removed and re-added portals that caused stale inner contents of the portal
    // seems like a React bug itself but leaving this for now as it fixes
    isFullyHidden && !isAdapted ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(LayoutMeasurementController, {
      disable: !isMountedOrOpen,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogPortalFrame, __spreadProps(__spreadValues(__spreadProps(__spreadValues({
        ref
      }, isWeb), {
        // passThrough={isAdapted}
        pointerEvents: isMountedOrOpen ? "auto" : "none"
      }), frameProps), {
        className: "_no_backdrop " + (frameProps.className || ""),
        children: contents
      }))
    })
  );
  return isAdapted ? framedContents : /* @__PURE__ */ jsxRuntimeExports.jsx(DialogPortalItem, {
    context: context2,
    children: framedContents
  });
}), OVERLAY_NAME$1 = "DialogOverlay", DialogOverlayFrame = styled(Overlay, {
  name: OVERLAY_NAME$1
}), DialogOverlay = DialogOverlayFrame.styleable(function(param, forwardedRef) {
  var _a = param, {
    scope
  } = _a, props = __objRest(_a, [
    "scope"
  ]), context2 = useDialogContext(scope), _b = props, {
    forceMount = context2.forceMount
  } = _b, overlayProps = __objRest(_b, [
    "forceMount"
  ]), isAdapted = useAdaptIsActive(context2.adaptScope);
  return !forceMount && (!context2.modal || isAdapted) ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(DialogOverlayFrame, __spreadProps(__spreadValues({
    "data-state": getState$2(context2.open),
    // TODO: this will be apply for v2
    // onPress={() => {
    //   // if the overlay is pressed, close the dialog
    //   context.onOpenChange(false)
    // }}
    // We re-enable pointer-events prevented by `Dialog.Content` to allow scrolling the overlay.
    pointerEvents: context2.open ? "auto" : "none"
  }, overlayProps), {
    ref: forwardedRef
  }));
}), CONTENT_NAME$2 = "DialogContent", DialogContentFrame = styled(ThemeableStack, {
  name: CONTENT_NAME$2,
  variants: {
    size: {
      "...size": function(val, extras) {
        return {};
      }
    },
    unstyled: {
      false: {
        position: "relative",
        backgrounded: true,
        padded: true,
        radiused: true,
        elevate: true,
        zIndex: 1e5
      }
    }
  },
  defaultVariants: {
    size: "$true",
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), DialogContent = DialogContentFrame.styleable(function(param, forwardedRef) {
  var _a = param, {
    scope
  } = _a, props = __objRest(_a, [
    "scope"
  ]), context2 = useDialogContext(scope), _b = props, {
    forceMount = context2.forceMount
  } = _b, contentProps = __objRest(_b, [
    "forceMount"
  ]), contents = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children: context2.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentModal, __spreadProps(__spreadValues({
      context: context2
    }, contentProps), {
      ref: forwardedRef
    })) : /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentNonModal, __spreadProps(__spreadValues({
      context: context2
    }, contentProps), {
      ref: forwardedRef
    }))
  });
  return contents;
}), DialogContentModal = /* @__PURE__ */ React__namespace.forwardRef(function(param, forwardedRef) {
  var _a = param, {
    children,
    context: context2
  } = _a, props = __objRest(_a, [
    "children",
    "context"
  ]), contentRef = React__namespace.useRef(null), composedRefs = useComposedRefs(forwardedRef, context2.contentRef, contentRef);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentImpl, __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, props), {
    context: context2,
    ref: composedRefs,
    // we make sure focus isn't trapped once `DialogContent` has been closed
    // (closed !== unmounted when animating out)
    trapFocus: context2.open,
    disableOutsidePointerEvents: true,
    onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, function(event) {
      var _context_triggerRef_current;
      event.preventDefault(), (_context_triggerRef_current = context2.triggerRef.current) === null || _context_triggerRef_current === void 0 || _context_triggerRef_current.focus();
    }),
    onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, function(event) {
      var originalEvent = event.detail.originalEvent, ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true, isRightClick = originalEvent.button === 2 || ctrlLeftClick;
      isRightClick && event.preventDefault();
    }),
    // When focus is trapped, a `focusout` event may still happen.
    // We make sure we don't trigger our `onDismiss` in such case.
    onFocusOutside: composeEventHandlers(props.onFocusOutside, function(event) {
      return event.preventDefault();
    })
  }), !props.unstyled && {
    outlineStyle: "none"
  }), {
    children
  }));
}), DialogContentNonModal = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var hasInteractedOutsideRef = React__namespace.useRef(false);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentImpl, __spreadProps(__spreadValues({}, props), {
    ref: forwardedRef,
    trapFocus: false,
    disableOutsidePointerEvents: false,
    onCloseAutoFocus: function(event) {
      var _props_onCloseAutoFocus;
      if ((_props_onCloseAutoFocus = props.onCloseAutoFocus) === null || _props_onCloseAutoFocus === void 0 || _props_onCloseAutoFocus.call(props, event), !event.defaultPrevented) {
        if (!hasInteractedOutsideRef.current) {
          var _props_context_triggerRef_current;
          (_props_context_triggerRef_current = props.context.triggerRef.current) === null || _props_context_triggerRef_current === void 0 || _props_context_triggerRef_current.focus();
        }
        event.preventDefault();
      }
      hasInteractedOutsideRef.current = false;
    },
    onInteractOutside: function(event) {
      var _props_onInteractOutside;
      (_props_onInteractOutside = props.onInteractOutside) === null || _props_onInteractOutside === void 0 || _props_onInteractOutside.call(props, event), event.defaultPrevented || (hasInteractedOutsideRef.current = true);
      var target = event.target, trigger = props.context.triggerRef.current;
      if (_instanceof(trigger, HTMLElement)) {
        var targetIsTrigger = trigger.contains(target);
        targetIsTrigger && event.preventDefault();
      }
    }
  }));
}), DialogContentImpl = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    trapFocus,
    onOpenAutoFocus,
    onCloseAutoFocus,
    disableOutsidePointerEvents,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onInteractOutside,
    context: context2
  } = _a, contentProps = __objRest(_a, [
    "trapFocus",
    "onOpenAutoFocus",
    "onCloseAutoFocus",
    "disableOutsidePointerEvents",
    "onEscapeKeyDown",
    "onPointerDownOutside",
    "onFocusOutside",
    "onInteractOutside",
    "context"
  ]), contentRef = React__namespace.useRef(
    // TODO react 19 type workaround
    void 0
  ), composedRefs = useComposedRefs(forwardedRef, contentRef), isAdapted = useAdaptIsActive(context2.adaptScope);
  if (isAdapted) return !context2.open ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(DialogPortalItem, {
    context: context2,
    children: contentProps.children
  });
  var contents = /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentFrame, __spreadValues({
    ref: composedRefs,
    id: context2.contentId,
    "aria-describedby": context2.descriptionId,
    "aria-labelledby": context2.titleId,
    "data-state": getState$2(context2.open)
  }, contentProps));
  return contents;
}), DialogTitleFrame = styled(H2, {
  name: "DialogTitle"
}), DialogTitle = DialogTitleFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, titleProps = __objRest(_a, [
    "scope"
  ]), context2 = useDialogContext(scope);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitleFrame, __spreadProps(__spreadValues({
    id: context2.titleId
  }, titleProps), {
    ref: forwardedRef
  }));
}), DialogDescriptionFrame = styled(Paragraph, {
  name: "DialogDescription"
}), DialogDescription = DialogDescriptionFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, descriptionProps = __objRest(_a, [
    "scope"
  ]), context2 = useDialogContext(scope);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogDescriptionFrame, __spreadProps(__spreadValues({
    id: context2.descriptionId
  }, descriptionProps), {
    ref: forwardedRef
  }));
}), CLOSE_NAME = "DialogClose", DialogCloseFrame = styled(View, {
  name: CLOSE_NAME,
  tag: "button"
}), DialogClose = DialogCloseFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    scope,
    displayWhenAdapted
  } = _a, closeProps = __objRest(_a, [
    "scope",
    "displayWhenAdapted"
  ]), context2 = useDialogContext(scope), isAdapted = useAdaptIsActive(context2.adaptScope), isInsideButton = React__namespace.useContext(ButtonNestingContext);
  return isAdapted && !displayWhenAdapted ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(DialogCloseFrame, __spreadProps(__spreadValues({
    accessibilityLabel: "Dialog Close",
    tag: isInsideButton ? "span" : "button"
  }, closeProps), {
    ref: forwardedRef,
    onPress: composeEventHandlers(props.onPress, function() {
      context2.onOpenChange(false);
    })
  }));
});
function getState$2(open2) {
  return open2 ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning", [DialogWarningProvider, useWarningContext] = createContext(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME$2,
  titleName: "DialogTitle",
  docsSlug: "dialog"
}), Dialog = withStaticProperties(/* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
  var {
    scope = "",
    children,
    open: openProp,
    defaultOpen = false,
    onOpenChange,
    modal = true,
    disableRemoveScroll = false
  } = props, baseId = React__namespace.useId(), dialogId = `Dialog-${scope}-${baseId}`, contentId = `${dialogId}-content`, titleId = `${dialogId}-title`, descriptionId = `${dialogId}-description`, triggerRef = React__namespace.useRef(null), contentRef = React__namespace.useRef(null), [open2, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  }), onOpenToggle = React__namespace.useCallback(function() {
    setOpen(function(prevOpen) {
      return !prevOpen;
    });
  }, [setOpen]), adaptScope = `DialogAdapt${scope}`, context2 = {
    dialogScope: scope,
    adaptScope,
    triggerRef,
    contentRef,
    contentId,
    titleId,
    descriptionId,
    open: open2,
    onOpenChange: setOpen,
    onOpenToggle,
    modal,
    disableRemoveScroll
  };
  return React__namespace.useImperativeHandle(ref, function() {
    return {
      open: setOpen
    };
  }, [setOpen]), /* @__PURE__ */ jsxRuntimeExports.jsx(AdaptParent, {
    scope: adaptScope,
    portal: {
      forwardProps: props
    },
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogProvider, __spreadProps(__spreadValues({
      scope
    }, context2), {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogSheetController, {
        onOpenChange: setOpen,
        scope,
        children
      })
    }))
  });
}), {
  Trigger: DialogTrigger,
  Portal: DialogPortal,
  Overlay: DialogOverlay,
  Content: DialogContent,
  Title: DialogTitle,
  Description: DialogDescription,
  Close: DialogClose,
  Sheet: Sheet.Controlled,
  FocusScope: FocusScopeControllerComponent,
  Adapt
});
var DialogSheetController = function(props) {
  var context2 = useDialogContext(props.scope), isAdapted = useAdaptIsActive(context2.adaptScope);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SheetController, {
    onOpenChange: function(val) {
      if (isAdapted) {
        var _props_onOpenChange;
        (_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 || _props_onOpenChange.call(props, val);
      }
    },
    open: context2.open,
    hidden: !isAdapted,
    children: props.children
  });
};
var getAlertDialogScope = function(scope) {
  return scope;
}, ROOT_NAME = "AlertDialog", TRIGGER_NAME$3 = "AlertDialogTrigger", NativeAlertDialogTriggerFrame = styled(View, {
  name: TRIGGER_NAME$3
}), AlertDialogTrigger = NativeAlertDialogTriggerFrame.styleable(function(props, forwardedRef) {
  if (props.__native) {
    var _a = props, {
      __native,
      onPress,
      __onPress
    } = _a, rest = __objRest(_a, [
      "__native",
      "onPress",
      "__onPress"
    ]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(NativeAlertDialogTriggerFrame, __spreadProps(__spreadValues({}, rest), {
      onPress: composeEventHandlers(onPress, __onPress)
    }));
  }
  var _b = props, {
    scope
  } = _b, triggerProps = __objRest(_b, [
    "scope"
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTrigger, __spreadProps(__spreadValues({
    scope: getAlertDialogScope(scope)
  }, triggerProps), {
    ref: forwardedRef
  }));
});
var AlertDialogPortal = function(props) {
  var _a = props, {
    scope
  } = _a, portalProps = __objRest(_a, [
    "scope"
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogPortal, __spreadValues({
    scope: getAlertDialogScope(scope)
  }, portalProps));
}, OVERLAY_NAME = "AlertDialogOverlay", AlertDialogOverlayFrame = styled(DialogOverlayFrame, {
  name: OVERLAY_NAME
}), AlertDialogOverlay = AlertDialogOverlayFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, overlayProps = __objRest(_a, [
    "scope"
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogOverlay, __spreadProps(__spreadValues({
    scope: getAlertDialogScope(scope)
  }, overlayProps), {
    ref: forwardedRef
  }));
}), CONTENT_NAME$1 = "AlertDialogContent", {
  Provider: AlertDialogContextProvider,
  useStyledContext: useAlertDialogContentContext
} = createStyledContext({}, "AlertDialogContext"), AlertDialogContent = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    scope,
    children
  } = _a, contentProps = __objRest(_a, [
    "scope",
    "children"
  ]), dialogScope = getAlertDialogScope(scope), contentRef = React__namespace.useRef(null), composedRefs = useComposedRefs(forwardedRef, contentRef), cancelRef = React__namespace.useRef(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogWarningProvider, {
    contentName: CONTENT_NAME$1,
    titleName: TITLE_NAME,
    docsSlug: "alert-dialog",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(AlertDialogContextProvider, {
      scope,
      cancelRef,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, __spreadProps(__spreadValues({
        // @ts-ignore
        role: "alertdialog",
        scope: dialogScope
      }, contentProps), {
        ref: composedRefs,
        onOpenAutoFocus: composeEventHandlers(contentProps.onOpenAutoFocus, function(event) {
          if (event.preventDefault(), isWeb) ;
        }),
        onPointerDownOutside: function(event) {
          return event.preventDefault();
        },
        onInteractOutside: function(event) {
          return event.preventDefault();
        },
        children: [
          /**
          * We have to use `Slottable` here as we cannot wrap the `AlertDialogContentProvider`
          * around everything, otherwise the `DescriptionWarning` would be rendered straight away.
          * This is because we want the accessibility checks to run only once the content is actually
          * open and that behaviour is already encapsulated in `DialogContent`.
          */
          /* @__PURE__ */ jsxRuntimeExports.jsx(Slottable, {
            children
          }),
          false
        ]
      }))
    })
  });
}), TITLE_NAME = "AlertDialogTitle", AlertDialogTitleFrame = styled(View, {
  name: TITLE_NAME
}), AlertDialogTitle = AlertDialogTitleFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, titleProps = __objRest(_a, [
    "scope"
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, __spreadProps(__spreadValues({
    scope: getAlertDialogScope(scope)
  }, titleProps), {
    ref: forwardedRef
  }));
}), DESCRIPTION_NAME = "AlertDialogDescription", AlertDialogDescriptionFrame = styled(View, {
  name: DESCRIPTION_NAME
}), AlertDialogDescription = AlertDialogDescriptionFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, descriptionProps = __objRest(_a, [
    "scope"
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogDescription, __spreadProps(__spreadValues({
    scope: getAlertDialogScope(scope)
  }, descriptionProps), {
    ref: forwardedRef
  }));
}), ACTION_NAME = "AlertDialogAction", AlertDialogActionFrame = styled(View, {
  name: ACTION_NAME
}), AlertDialogAction = AlertDialogActionFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, actionProps = __objRest(_a, [
    "scope"
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogClose, __spreadProps(__spreadValues({
    scope: getAlertDialogScope(scope)
  }, actionProps), {
    ref: forwardedRef
  }));
}), CANCEL_NAME = "AlertDialogCancel", AlertDialogCancelFrame = styled(View, {
  name: CANCEL_NAME
}), AlertDialogCancel = AlertDialogCancelFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, cancelProps = __objRest(_a, [
    "scope"
  ]), {
    cancelRef
  } = useAlertDialogContentContext(scope), ref = useComposedRefs(forwardedRef, cancelRef);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogClose, __spreadProps(__spreadValues({
    scope: getAlertDialogScope(scope)
  }, cancelProps), {
    ref
  }));
}), AlertDialogInner = function(props) {
  var _a = props, {
    scope,
    native
  } = _a, alertDialogProps = __objRest(_a, [
    "scope",
    "native"
  ]), dialogScope = getAlertDialogScope(scope), [open2, setOpen] = useControllableState({
    prop: props.open,
    defaultProp: props.defaultOpen || false,
    onChange: props.onOpenChange,
    transition: true
  }), triggerElement = null, title = "", description = "", buttons = [];
  return forEachChildDeep(React__namespace.Children.toArray(props.children), function(child) {
    if (!/* @__PURE__ */ React__namespace.isValidElement(child)) return false;
    var name = isTamaguiElement(child) ? child.type.staticConfig.componentName : child.type.displayName;
    switch (name) {
      case TRIGGER_NAME$3:
        return triggerElement = /* @__PURE__ */ React__namespace.cloneElement(child, {
          __native: true
        }), false;
      case TITLE_NAME:
        return title = getStringChildren(child), false;
      case DESCRIPTION_NAME:
        return description = getStringChildren(child), false;
      case ACTION_NAME:
      case CANCEL_NAME: {
        var style = name === ACTION_NAME ? "default" : "cancel", text = getStringChildren(child), onPress = function() {
          var _childProps_onPress, childProps = child.props;
          childProps == null || (_childProps_onPress = childProps.onPress) === null || _childProps_onPress === void 0 || _childProps_onPress.call(childProps, {
            native: true
          }), setOpen(false);
        };
        return buttons.push({
          style,
          text,
          // @ts-ignore
          onPress
        }), false;
      }
      default:
        return true;
    }
  }), useIsomorphicLayoutEffect(function() {
  }, [native, open2]), native ? /* @__PURE__ */ React__namespace.cloneElement(triggerElement, {
    __onPress: function() {
      setOpen(true);
    }
  }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, __spreadProps(__spreadValues({
    scope: dialogScope
  }, alertDialogProps), {
    modal: true
  }));
};
function forEachChildDeep(children, onChild) {
  var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
  try {
    for (var _iterator = children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var child = _step.value;
      if (/* @__PURE__ */ React__namespace.isValidElement(child) && onChild(child)) {
        var childProps = child.props;
        childProps.children && forEachChildDeep(React__namespace.Children.toArray(childProps.children), onChild);
      }
    }
  } catch (err) {
    _didIteratorError = true, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError) throw _iteratorError;
    }
  }
}
function getStringChildren(child) {
  var string = "";
  return forEachChildDeep(React__namespace.Children.toArray(child), function(child2) {
    return typeof child2.props.children == "string" ? (string = child2.props.children, false) : true;
  }), string;
}
var AlertDialog = withStaticProperties(AlertDialogInner, {
  Trigger: AlertDialogTrigger,
  Portal: AlertDialogPortal,
  Overlay: AlertDialogOverlay,
  Content: AlertDialogContent,
  Action: AlertDialogAction,
  Cancel: AlertDialogCancel,
  Title: AlertDialogTitle,
  Description: AlertDialogDescription
});
AlertDialog.displayName = ROOT_NAME;
function _type_of(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var StyledImage = styled(ImageWithStatics, {
  name: "Image"
}), Image = StyledImage.styleable(function(inProps, ref) {
  var [props, style] = usePropsAndStyle(inProps), _a = props, {
    src,
    source,
    objectFit
  } = _a, rest = __objRest(_a, [
    "src",
    "source",
    "objectFit"
  ]);
  var finalSource = typeof src == "string" ? __spreadValues({
    uri: src
  }, isWeb) : source != null ? source : src;
  if (finalSource && (typeof finalSource > "u" ? "undefined" : _type_of(finalSource)) === "object") {
    if (!Array.isArray(finalSource) && typeof finalSource.uri == "number" && (finalSource = finalSource.uri, source && (typeof source > "u" ? "undefined" : _type_of(source)) === "object" && !Array.isArray(source))) {
      var _style, _style1, _width;
      (_width = (_style = style).width) !== null && _width !== void 0 || (_style.width = source.width);
      var _height;
      (_height = (_style1 = style).height) !== null && _height !== void 0 || (_style1.height = source.height);
    }
    finalSource.default && (finalSource = finalSource.default);
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ImageWithStatics, __spreadValues({
    resizeMode: objectFit,
    ref,
    source: finalSource,
    style
  }, rest));
});
Image.getSize = ImageWithStatics.getSize;
Image.getSizeWithHeaders = ImageWithStatics.getSizeWithHeaders;
Image.prefetch = ImageWithStatics.prefetch;
Image.prefetchWithMetadata = ImageWithStatics.prefetchWithMetadata;
Image.abortPrefetch = ImageWithStatics.abortPrefetch;
Image.queryCache = ImageWithStatics.queryCache;
var getShapeSize = function(size, param) {
  var {
    tokens
  } = param, _tokens_size_size, width = (_tokens_size_size = tokens.size[size]) !== null && _tokens_size_size !== void 0 ? _tokens_size_size : size, _tokens_size_size1, height = (_tokens_size_size1 = tokens.size[size]) !== null && _tokens_size_size1 !== void 0 ? _tokens_size_size1 : size;
  return {
    width,
    height,
    minWidth: width,
    maxWidth: width,
    maxHeight: height,
    minHeight: height
  };
};
var Square = styled(ThemeableStack, {
  name: "Square",
  alignItems: "center",
  justifyContent: "center",
  variants: {
    size: {
      "...size": getShapeSize,
      ":number": getShapeSize
    }
  }
}, {
  memo: true
});
var Circle = styled(Square, {
  name: "Circle",
  circular: true
});
var AVATAR_NAME = "Avatar", [createAvatarContext, createAvatarScope] = createContextScope(AVATAR_NAME), [AvatarProvider, useAvatarContext] = createAvatarContext(AVATAR_NAME), IMAGE_NAME = "AvatarImage", AvatarImage = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _getShapeSize, _a = props, {
    __scopeAvatar,
    src,
    onLoadingStatusChange = function() {
    }
  } = _a, imageProps = __objRest(_a, [
    "__scopeAvatar",
    "src",
    "onLoadingStatusChange"
  ]), context2 = useAvatarContext(IMAGE_NAME, __scopeAvatar), [status, setStatus] = React__namespace.useState("idle"), shapeSize = getVariableValue((_getShapeSize = getShapeSize(
    context2.size,
    // @ts-expect-error
    {
      tokens: getTokens()
    }
  )) === null || _getShapeSize === void 0 ? void 0 : _getShapeSize.width);
  return React__namespace.useEffect(function() {
    setStatus("idle");
  }, [JSON.stringify(src)]), React__namespace.useEffect(function() {
    onLoadingStatusChange(status), context2.onImageLoadingStatusChange(status);
  }, [status]), /* @__PURE__ */ jsxRuntimeExports.jsx(YStack, {
    fullscreen: true,
    zIndex: 1,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Image, __spreadProps(__spreadValues(__spreadValues({
      fullscreen: true
    }, typeof shapeSize == "number" && !Number.isNaN(shapeSize) && {
      width: shapeSize,
      height: shapeSize
    }), imageProps), {
      // @ts-ignore
      ref: forwardedRef,
      // @ts-ignore
      src,
      // onLoadStart={() => {
      //   // setStatus('loading')
      // }}
      onError: function() {
        setStatus("error");
      },
      onLoad: function() {
        setStatus("loaded");
      }
    }))
  });
});
AvatarImage.displayName = IMAGE_NAME;
var FALLBACK_NAME = "AvatarFallback", AvatarFallbackFrame = styled(YStack, {
  name: FALLBACK_NAME,
  position: "absolute",
  fullscreen: true,
  zIndex: 0
}), AvatarFallback = AvatarFallbackFrame.extractable(/* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    __scopeAvatar,
    delayMs
  } = _a, fallbackProps = __objRest(_a, [
    "__scopeAvatar",
    "delayMs"
  ]), context2 = useAvatarContext(FALLBACK_NAME, __scopeAvatar), [canRender, setCanRender] = React__namespace.useState(delayMs === void 0);
  return React__namespace.useEffect(function() {
    if (delayMs !== void 0) {
      var timerId = setTimeout(function() {
        return setCanRender(true);
      }, delayMs);
      return function() {
        return clearTimeout(timerId);
      };
    }
  }, [delayMs]), canRender && context2.imageLoadingStatus !== "loaded" ? /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarFallbackFrame, __spreadProps(__spreadValues({}, fallbackProps), {
    ref: forwardedRef
  })) : null;
}));
AvatarFallback.displayName = FALLBACK_NAME;
var AvatarFrame = styled(Square, {
  name: AVATAR_NAME,
  position: "relative",
  overflow: "hidden"
}), Avatar = withStaticProperties(/* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    __scopeAvatar,
    size = "$true"
  } = _a, avatarProps = __objRest(_a, [
    "__scopeAvatar",
    "size"
  ]), [imageLoadingStatus, setImageLoadingStatus] = React__namespace.useState("idle");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarProvider, {
    size,
    scope: __scopeAvatar,
    imageLoadingStatus,
    onImageLoadingStatusChange: setImageLoadingStatus,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarFrame, __spreadProps(__spreadValues({
      size
    }, avatarProps), {
      ref: forwardedRef
    }))
  });
}), {
  Image: AvatarImage,
  Fallback: AvatarFallback
});
Avatar.displayName = AVATAR_NAME;
var getFontSize = function(inSize, opts) {
  var res = getFontSizeVariable(inSize, opts);
  return isVariable(res) ? +res.val : res ? +res : 16;
}, getFontSizeVariable = function(inSize, opts) {
  var token = getFontSizeToken(inSize, opts);
  if (!token) return inSize;
  var conf2 = getConfig(), font = conf2.fontsParsed[(opts == null ? void 0 : opts.font) || conf2.defaultFontToken];
  return font == null ? void 0 : font.size[token];
}, getFontSizeToken = function(inSize, opts) {
  if (typeof inSize == "number") return null;
  var relativeSize = (opts == null ? void 0 : opts.relativeSize) || 0, conf2 = getConfig(), font = conf2.fontsParsed[(opts == null ? void 0 : opts.font) || conf2.defaultFontToken], fontSize = (font == null ? void 0 : font.size) || // fallback to size tokens
  conf2.tokensParsed.size, _ref, size = (_ref = inSize === "$true" && !("$true" in fontSize) ? "$4" : inSize) !== null && _ref !== void 0 ? _ref : "$true" in fontSize ? "$true" : "$4", sizeTokens = Object.keys(fontSize), foundIndex = sizeTokens.indexOf(size);
  foundIndex === -1 && size.endsWith(".5") && (foundIndex = sizeTokens.indexOf(size.replace(".5", "")));
  var tokenIndex = Math.min(Math.max(0, foundIndex + relativeSize), sizeTokens.length - 1), _sizeTokens_tokenIndex;
  return (_sizeTokens_tokenIndex = sizeTokens[tokenIndex]) !== null && _sizeTokens_tokenIndex !== void 0 ? _sizeTokens_tokenIndex : size;
};
var prevent = function(e2) {
  return [e2.preventDefault(), e2.stopPropagation()];
};
var useCurrentColor = function(colorProp) {
  var _theme_colorProp, _theme_color, theme = useTheme(), out = colorProp ? getVariable(colorProp) : ((_theme_colorProp = theme[colorProp]) === null || _theme_colorProp === void 0 ? void 0 : _theme_colorProp.get()) || ((_theme_color = theme.color) === null || _theme_color === void 0 ? void 0 : _theme_color.get());
  return out;
};
var useGetThemedIcon = function(props) {
  var color = useCurrentColor(props.color);
  return function(el) {
    return el && (/* @__PURE__ */ React.isValidElement(el) ? /* @__PURE__ */ React.cloneElement(el, __spreadValues(__spreadProps(__spreadValues({}, props), {
      color
    }), el.props)) : /* @__PURE__ */ React.createElement(el, props));
  };
};
var ButtonContext = createStyledContext({
  // keeping these here means they work with styled() passing down color to text
  color: void 0,
  ellipse: void 0,
  fontFamily: void 0,
  fontSize: void 0,
  fontStyle: void 0,
  fontWeight: void 0,
  letterSpacing: void 0,
  maxFontSizeMultiplier: void 0,
  size: void 0,
  textAlign: void 0,
  variant: void 0
}), BUTTON_NAME = "Button", ButtonFrame = styled(ThemeableStack, {
  name: BUTTON_NAME,
  tag: "button",
  context: ButtonContext,
  role: "button",
  focusable: true,
  variants: {
    unstyled: {
      false: {
        size: "$true",
        justifyContent: "center",
        alignItems: "center",
        flexWrap: "nowrap",
        flexDirection: "row",
        cursor: "pointer",
        hoverTheme: true,
        pressTheme: true,
        backgrounded: true,
        borderWidth: 1,
        borderColor: "transparent",
        focusVisibleStyle: {
          outlineColor: "$outlineColor",
          outlineStyle: "solid",
          outlineWidth: 2
        }
      }
    },
    variant: {
      outlined: {
        backgroundColor: "transparent",
        borderWidth: 2,
        borderColor: "$borderColor",
        hoverStyle: {
          backgroundColor: "transparent",
          borderColor: "$borderColorHover"
        },
        pressStyle: {
          backgroundColor: "transparent",
          borderColor: "$borderColorPress"
        },
        focusVisibleStyle: {
          backgroundColor: "transparent",
          borderColor: "$borderColorFocus"
        }
      }
    },
    size: {
      "...size": getButtonSized,
      ":number": getButtonSized
    },
    disabled: {
      true: {
        pointerEvents: "none"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), ButtonText = styled(SizableText, {
  name: "Button",
  context: ButtonContext,
  variants: {
    unstyled: {
      false: {
        userSelect: "none",
        cursor: "pointer",
        // flexGrow 1 leads to inconsistent native style where text pushes to start of view
        flexGrow: 0,
        flexShrink: 1,
        ellipse: true,
        color: "$color"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), ButtonIcon = function(props) {
  var {
    children,
    scaleIcon = 1
  } = props, {
    size,
    color
  } = React.useContext(ButtonContext), iconSize = (typeof size == "number" ? size * 0.5 : getFontSize(size)) * scaleIcon, getThemedIcon = useGetThemedIcon({
    size: iconSize,
    color
  });
  return getThemedIcon(children);
}, ButtonComponent = ButtonFrame.styleable(function(props, ref) {
  var {
    props: buttonProps
  } = useButton(props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonFrame, __spreadProps(__spreadValues({
    "data-disable-theme": true
  }, buttonProps), {
    ref
  }));
}), Button2 = withStaticProperties(ButtonComponent, {
  Text: ButtonText,
  Icon: ButtonIcon
});
function useButton(param) {
  var _a = param, {
    textProps
  } = _a, propsIn = __objRest(_a, [
    "textProps"
  ]), {
    Text: Text2 = Button2.Text
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    Text: Button2.Text
  }, isNested = React.useContext(ButtonNestingContext), propsActive = useProps(propsIn, {
    noNormalize: true,
    noExpand: true
  }), _b = propsActive, {
    icon,
    iconAfter,
    space,
    spaceFlex,
    scaleIcon = 1,
    scaleSpace = 0.66,
    separator,
    noTextWrap,
    fontFamily,
    fontSize,
    fontWeight,
    fontStyle,
    letterSpacing,
    tag,
    ellipse,
    maxFontSizeMultiplier
  } = _b, restProps = __objRest(_b, [
    "icon",
    "iconAfter",
    "space",
    "spaceFlex",
    "scaleIcon",
    "scaleSpace",
    "separator",
    "noTextWrap",
    "fontFamily",
    "fontSize",
    "fontWeight",
    "fontStyle",
    "letterSpacing",
    "tag",
    "ellipse",
    "maxFontSizeMultiplier"
  ]), size = propsActive.size || (propsActive.unstyled ? void 0 : "$true"), color = propsActive.color, iconSize = (typeof size == "number" ? size * 0.5 : getFontSize(size, {
    font: (fontFamily == null ? void 0 : fontFamily[0]) === "$" ? fontFamily : void 0
  })) * scaleIcon, getThemedIcon = useGetThemedIcon({
    size: iconSize,
    color
  }), [themedIcon, themedIconAfter] = [icon, iconAfter].map(getThemedIcon), spaceSize = space != null ? space : getVariableValue(iconSize) * scaleSpace, contents = noTextWrap ? [propsIn.children] : wrapChildrenInText(Text2, {
    children: propsIn.children,
    color,
    fontFamily,
    fontSize,
    textProps,
    fontWeight,
    fontStyle,
    letterSpacing,
    maxFontSizeMultiplier
  }, Text2 === ButtonText && propsActive.unstyled !== true ? {
    unstyled: process.env.TAMAGUI_HEADLESS === "1",
    size
  } : void 0), inner = spacedChildren({
    // a bit arbitrary but scaling to font size is necessary so long as button does
    space: spaceSize === false ? 0 : spaceSize == true ? "$true" : spaceSize,
    spaceFlex,
    ensureKeys: true,
    separator,
    direction: propsActive.flexDirection === "column" || propsActive.flexDirection === "column-reverse" ? "vertical" : "horizontal",
    // for keys to stay the same we keep indices as similar a possible
    // so even if icons are undefined we still pass them
    children: [themedIcon, ...contents, themedIconAfter]
  }), props = __spreadProps(__spreadValues(__spreadProps(__spreadValues({
    size
  }, propsIn.disabled && {
    // in rnw - false still has keyboard tabIndex, undefined = not actually focusable
    focusable: void 0,
    // even with tabIndex unset, it will keep focusVisibleStyle on web so disable it here
    focusVisibleStyle: {
      borderColor: "$background"
    }
  }), {
    // fixes SSR issue + DOM nesting issue of not allowing button in button
    tag: tag != null ? tag : isNested ? "span" : (
      // defaults to <a /> when accessibilityRole = link
      // see https://github.com/tamagui/tamagui/issues/505
      propsActive.accessibilityRole === "link" || propsActive.role === "link" ? "a" : "button"
    )
  }), restProps), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonNestingContext.Provider, {
      value: true,
      children: inner
    }),
    // forces it to be a runtime pressStyle so it passes through context text colors
    disableClassName: true
  });
  return {
    spaceSize,
    isNested,
    props
  };
}
var CardContext = createStyledContext({
  size: "$true"
}), CardFrame = styled(ThemeableStack, {
  name: "Card",
  context: CardContext,
  variants: {
    unstyled: {
      false: {
        size: "$true",
        backgroundColor: "$background",
        position: "relative"
      }
    },
    size: {
      "...size": function(val, param) {
        var {
          tokens
        } = param, _tokens_radius_val;
        return {
          borderRadius: (_tokens_radius_val = tokens.radius[val]) !== null && _tokens_radius_val !== void 0 ? _tokens_radius_val : val
        };
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), CardHeader = styled(ThemeableStack, {
  name: "CardHeader",
  context: CardContext,
  variants: {
    unstyled: {
      false: {
        zIndex: 10,
        backgroundColor: "transparent",
        marginBottom: "auto"
      }
    },
    size: {
      "...size": function(val, param) {
        var {
          tokens
        } = param, _tokens_space_val;
        return {
          padding: (_tokens_space_val = tokens.space[val]) !== null && _tokens_space_val !== void 0 ? _tokens_space_val : val
        };
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), CardFooter = styled(CardHeader, {
  name: "CardFooter",
  variants: {
    unstyled: {
      false: {
        zIndex: 5,
        flexDirection: "row",
        marginTop: "auto",
        marginBottom: 0
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), CardBackground = styled(ThemeableStack, {
  name: "CardBackground",
  variants: {
    unstyled: {
      false: {
        zIndex: 0,
        fullscreen: true,
        overflow: "hidden",
        pointerEvents: "none",
        padding: 0
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), Card = withStaticProperties(CardFrame, {
  Header: CardHeader,
  Footer: CardFooter,
  Background: CardBackground
});
var CheckboxStyledContext = createStyledContext({
  size: "$true",
  scaleIcon: 1
});
var INDICATOR_NAME$1 = "CheckboxIndicator", CheckboxIndicatorFrame = styled(ThemeableStack, {
  // use Checkbox for easier themes
  name: INDICATOR_NAME$1,
  context: CheckboxStyledContext,
  variants: {
    unstyled: {
      false: {}
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), CHECKBOX_NAME = "Checkbox", CheckboxFrame = styled(ThemeableStack, {
  name: CHECKBOX_NAME,
  tag: "button",
  context: CheckboxStyledContext,
  variants: {
    unstyled: {
      false: {
        size: "$true",
        backgroundColor: "$background",
        alignItems: "center",
        justifyContent: "center",
        pressTheme: true,
        focusable: true,
        borderWidth: 1,
        borderColor: "$borderColor",
        hoverStyle: {
          borderColor: "$borderColorHover"
        },
        focusStyle: {
          borderColor: "$borderColorFocus"
        },
        focusVisibleStyle: {
          outlineStyle: "solid",
          outlineWidth: 2,
          outlineColor: "$outlineColor"
        }
      }
    },
    disabled: {
      true: {
        pointerEvents: "none",
        userSelect: "none",
        cursor: "not-allowed",
        hoverStyle: {
          borderColor: "$borderColor",
          backgroundColor: "$background"
        },
        pressStyle: {
          borderColor: "$borderColor",
          backgroundColor: "$background"
        },
        focusStyle: {
          outlineWidth: 0
        }
      }
    },
    size: {
      "...size": function(val) {
        var radiusToken = getVariableValue(getSize(val)) / 8;
        return {
          borderRadius: radiusToken
        };
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
});
var InputsMap = /* @__PURE__ */ new Map(), registerFocusable = function(id2, input) {
  return InputsMap.set(id2, input), function() {
    InputsMap.delete(id2);
  };
}, focusFocusable = function(id2) {
  var select = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, input = InputsMap.get(id2);
  if (!input) {
    return;
  }
  select || !input.focusAndSelect ? input.focus() : input.focusAndSelect();
};
function useFocusable(param) {
  var {
    isInput,
    props,
    ref
  } = param, {
    id: id2,
    onChangeText,
    value,
    defaultValue: defaultValue2
  } = props, inputValue = React.useRef(value || defaultValue2 || ""), unregisterFocusable = React.useRef(void 0), focusAndSelect = React.useCallback(function(input) {
    input.focus(), input.setSelection && typeof inputValue.current == "string" && input.setSelection(0, inputValue.current.length);
  }, []), registerFocusableHandler = React.useCallback(function(input) {
    var _unregisterFocusable_current;
    !id2 || !input || ((_unregisterFocusable_current = unregisterFocusable.current) === null || _unregisterFocusable_current === void 0 || _unregisterFocusable_current.call(unregisterFocusable), unregisterFocusable.current = registerFocusable(id2, __spreadValues({
      focus: input.focus
    }, isInput && {
      focusAndSelect: function() {
        return focusAndSelect(input);
      }
    })));
  }, [id2, isInput, focusAndSelect]), inputRef = React.useCallback(function(input) {
    input && registerFocusableHandler(input);
  }, [registerFocusableHandler]), handleChangeText = useEvent(function(value2) {
    inputValue.current = value2, onChangeText == null ? void 0 : onChangeText(value2);
  });
  return React.useEffect(function() {
    return function() {
      var _unregisterFocusable_current;
      (_unregisterFocusable_current = unregisterFocusable.current) === null || _unregisterFocusable_current === void 0 || _unregisterFocusable_current.call(unregisterFocusable);
    };
  }, []), {
    ref: React.useMemo(function() {
      return composeRefs(ref, inputRef);
    }, [ref, inputRef]),
    onChangeText: handleChangeText
  };
}
var NAME$2 = "Label", [LabelProvider, useLabelContextImpl] = createContext(NAME$2, {
  id: void 0,
  controlRef: {
    current: null
  }
}), LabelFrame = styled(SizableText, {
  name: "Label",
  tag: "label",
  variants: {
    unstyled: {
      false: {
        size: "$true",
        color: "$color",
        backgroundColor: "transparent",
        display: "flex",
        alignItems: "center",
        userSelect: "none",
        cursor: "default",
        pressStyle: {
          color: "$colorPress"
        }
      }
    },
    size: {
      "...size": function(val, extras) {
        var buttonStyle = getButtonSized(val, extras), buttonHeight = buttonStyle == null ? void 0 : buttonStyle.height, fontStyle = getFontSized(val, extras);
        return __spreadProps(__spreadValues({}, fontStyle), {
          lineHeight: buttonHeight ? extras.tokens.size[buttonHeight] : void 0
        });
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), LabelComponent = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    htmlFor,
    id: idProp
  } = _a, labelProps = __objRest(_a, [
    "htmlFor",
    "id"
  ]), controlRef = React__namespace.useRef(null), ref = React__namespace.useRef(null), composedRefs = useComposedRefs(forwardedRef, ref), backupId = React__namespace.useId(), id2 = idProp != null ? idProp : backupId;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(LabelProvider, {
    id: id2,
    controlRef,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(LabelFrame, __spreadProps(__spreadValues({
      id: id2,
      // @ts-ignore
      htmlFor
    }, labelProps), {
      ref: composedRefs,
      onMouseDown: function(event) {
        var _props_onMouseDown;
        (_props_onMouseDown = props.onMouseDown) === null || _props_onMouseDown === void 0 || _props_onMouseDown.call(props, event), !event.defaultPrevented && event.detail > 1 && event.preventDefault();
      },
      onPress: function(event) {
        var _props_onPress;
        if ((_props_onPress = props.onPress) === null || _props_onPress === void 0 || _props_onPress.call(props, event), isWeb) ;
        else props.htmlFor && focusFocusable(props.htmlFor);
      }
    }))
  });
});
LabelComponent.displayName = NAME$2;
var Label = LabelFrame.extractable(themeable(LabelComponent)), useLabelContext = function(element) {
  var context2 = useLabelContextImpl("LabelConsumer"), {
    controlRef
  } = context2;
  return React__namespace.useEffect(function() {
    element && (controlRef.current = element);
  }, [element, controlRef]), context2.id;
};
function usePrevious(value) {
  var ref = React__namespace.useRef({
    value,
    previous: value
  });
  return React__namespace.useMemo(function() {
    return ref.current.value !== value && (ref.current.previous = ref.current.value, ref.current.value = value), ref.current.previous;
  }, [value]);
}
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function useCheckbox(props, param, ref) {
  var [checked, setChecked] = param, _a = props, {
    labelledBy: ariaLabelledby,
    name,
    required,
    disabled,
    value = "on",
    onCheckedChange
  } = _a, checkboxProps = __objRest(_a, [
    "labelledBy",
    "name",
    "required",
    "disabled",
    "value",
    "onCheckedChange"
  ]), [button, setButton] = React.useState(null), composedRefs = useComposedRefs(ref, setButton);
  React.useRef(false);
  var isFormControl = false, labelId = useLabelContext(button), labelledBy = ariaLabelledby || labelId, parentKeyDown = props.onKeyDown;
  React.useMemo(function() {
    return composeEventHandlers(parentKeyDown, function(event) {
      event.key === "Enter" && event.preventDefault();
    });
  }, [parentKeyDown]);
  var handlePress = React.useMemo(function() {
    return composeEventHandlers(props.onPress, function(event) {
      setChecked(function(prevChecked) {
        return isIndeterminate(prevChecked) ? true : !prevChecked;
      });
    });
  }, [isFormControl]);
  return {
    bubbleInput: null,
    checkboxRef: composedRefs,
    checkboxProps: __spreadProps(__spreadValues(__spreadValues({
      role: "checkbox",
      "aria-labelledby": labelledBy,
      "aria-checked": isIndeterminate(checked) ? "mixed" : checked
    }, checkboxProps), isWeb), {
      onPress: disabled ? void 0 : handlePress
    })
  };
}
var CheckboxContext = /* @__PURE__ */ React.createContext({
  checked: false,
  disabled: false
}), ensureContext$1 = function(x) {
  x.context || (x.context = CheckboxContext);
};
function createCheckbox(createProps) {
  var {
    disableActiveTheme,
    Frame: Frame2 = CheckboxFrame,
    Indicator = CheckboxIndicatorFrame
  } = createProps;
  ensureContext$1(Frame2), ensureContext$1(Indicator);
  var FrameComponent = Frame2.styleable(function(_props, forwardedRef) {
    var _a = _props, {
      scaleSize = 0.45,
      sizeAdjust = 0,
      scaleIcon,
      checked: checkedProp,
      defaultChecked,
      onCheckedChange,
      native,
      unstyled = false
    } = _a, props = __objRest(_a, [
      "scaleSize",
      "sizeAdjust",
      "scaleIcon",
      "checked",
      "defaultChecked",
      "onCheckedChange",
      "native",
      "unstyled"
    ]), propsActive = useProps(props), styledContext = React.useContext(CheckboxStyledContext), adjustedSize = 0, size = 0;
    if (!unstyled) {
      var _propsActive_size, _ref;
      adjustedSize = getVariableValue(getSize((_ref = (_propsActive_size = propsActive.size) !== null && _propsActive_size !== void 0 ? _propsActive_size : styledContext == null ? void 0 : styledContext.size) !== null && _ref !== void 0 ? _ref : "$true", {
        shift: sizeAdjust
      })), size = scaleSize ? Math.round(adjustedSize * scaleSize) : adjustedSize;
    }
    var [checked = false, setChecked] = useControllableState({
      prop: checkedProp,
      defaultProp: defaultChecked,
      onChange: onCheckedChange
    }), {
      checkboxProps,
      checkboxRef,
      bubbleInput
    } = useCheckbox(
      // @ts-ignore
      propsActive,
      [checked, setChecked],
      forwardedRef
    );
    React.useEffect(function() {
      if (props.id && !props.disabled) return registerFocusable(props.id, {
        focusAndSelect: function() {
          setChecked == null ? void 0 : setChecked(function(value) {
            return !value;
          });
        },
        focus: function() {
        }
      });
    }, [props.id, props.disabled]);
    var renderNative = shouldRenderNativePlatform(native);
    if (renderNative === "web") return /* @__PURE__ */ jsxRuntimeExports.jsx("input", {
      type: "checkbox",
      defaultChecked: isIndeterminate(checked) ? false : checked,
      tabIndex: -1,
      ref: checkboxRef,
      disabled: checkboxProps.disabled,
      style: __spreadValues({
        appearance: "auto",
        accentColor: "var(--color6)"
      }, checkboxProps.style)
    });
    var memoizedContext = React.useMemo(function() {
      return {
        checked,
        disabled: checkboxProps.disabled
      };
    }, [checked, checkboxProps.disabled]), _propsActive_size1, _ref1, _ref2;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CheckboxContext.Provider, {
      value: memoizedContext,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CheckboxStyledContext.Provider, {
        size: (_ref1 = (_propsActive_size1 = propsActive.size) !== null && _propsActive_size1 !== void 0 ? _propsActive_size1 : styledContext == null ? void 0 : styledContext.size) !== null && _ref1 !== void 0 ? _ref1 : "$true",
        scaleIcon: (_ref2 = scaleIcon != null ? scaleIcon : styledContext == null ? void 0 : styledContext.scaleIcon) !== null && _ref2 !== void 0 ? _ref2 : 1,
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Frame2, __spreadProps(__spreadValues(__spreadProps(__spreadValues(__spreadProps(__spreadValues({}, !unstyled && {
          width: size,
          height: size
        }), {
          tag: "button",
          ref: checkboxRef,
          unstyled
        }), unstyled === false && {
          size,
          theme: checked ? "active" : null
        }), {
          // potential variant
          checked,
          disabled: checkboxProps.disabled
        }), checkboxProps), {
          // react 76 style prop mis-match, but should be fine
          style: checkboxProps.style,
          children: propsActive.children
        })), bubbleInput]
      })
    });
  }), IndicatorComponent = Indicator.styleable(function(props, forwardedRef) {
    var _a = props, {
      children: childrenProp,
      forceMount,
      disablePassStyles,
      unstyled = false
    } = _a, indicatorProps = __objRest(_a, [
      // __scopeCheckbox,
      "children",
      "forceMount",
      "disablePassStyles",
      "unstyled"
    ]), styledContext = React.useContext(CheckboxStyledContext), children = childrenProp;
    if (!unstyled) {
      var iconSize = (typeof styledContext.size == "number" ? styledContext.size * 0.65 : getFontSize(styledContext.size)) * styledContext.scaleIcon, theme = useTheme(), getThemedIcon = useGetThemedIcon({
        size: iconSize,
        color: theme.color
      }), childrens = React.Children.toArray(childrenProp);
      children = childrens.map(function(child) {
        return disablePassStyles || !/* @__PURE__ */ React.isValidElement(child) ? child : getThemedIcon(child);
      });
    }
    var context2 = React.useContext(CheckboxContext);
    return forceMount || isIndeterminate(context2.checked) || context2.checked === true ? /* @__PURE__ */ jsxRuntimeExports.jsx(Indicator, __spreadProps(__spreadValues({
      pointerEvents: "none"
    }, indicatorProps), {
      ref: forwardedRef,
      children
    })) : null;
  });
  return withStaticProperties(FrameComponent, {
    Indicator: IndicatorComponent
  });
}
var Checkbox = createCheckbox({
  Frame: CheckboxFrame,
  Indicator: CheckboxIndicatorFrame
});
var FORM_NAME = "Form", FormFrame = styled(Stack, {
  name: FORM_NAME,
  tag: "form"
}), [createFormContext] = createContextScope(FORM_NAME), [FormProvider, useFormContext] = createFormContext(FORM_NAME), TRIGGER_NAME$2 = "FormTrigger", FormTriggerFrame = styled(View, {
  name: TRIGGER_NAME$2
}), FormTrigger = FormTriggerFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    __scopeForm,
    children,
    onPress
  } = _a, triggerProps = __objRest(_a, [
    "__scopeForm",
    "children",
    "onPress"
  ]), context2 = useFormContext(TRIGGER_NAME$2, __scopeForm);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormTriggerFrame, __spreadProps(__spreadValues({
    tag: "button"
  }, triggerProps), {
    ref: forwardedRef,
    onPress: composeEventHandlers(onPress, context2.onSubmit),
    children
  }));
}), FormComponent = FormFrame.extractable(function(param) {
  var _a = param, {
    onSubmit
  } = _a, props = __objRest(_a, [
    "onSubmit"
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormProvider, {
    scope: props.__scopeForm,
    onSubmit,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormFrame, __spreadProps(__spreadValues({}, props), {
      onSubmit: function(e2) {
        return e2.preventDefault();
      }
    }))
  });
}), Form2 = withStaticProperties(FormComponent, {
  Trigger: FormTrigger
});
var MaxIndexContext = /* @__PURE__ */ React__namespace.createContext([]), IndexContext = /* @__PURE__ */ React__namespace.createContext(null);
function useIndex() {
  var maxIndexPath = React__namespace.useContext(MaxIndexContext), indexPathString = React__namespace.useContext(IndexContext);
  return React__namespace.useMemo(function() {
    if (indexPathString === null) return null;
    var indexPath = parseIndexPath(indexPathString), maxIndex = maxIndexPath[maxIndexPath.length - 1], index2 = indexPath[indexPath.length - 1];
    return {
      maxIndex,
      maxIndexPath,
      index: index2,
      indexPath,
      indexPathString,
      isFirst: index2 === 0,
      isLast: index2 === maxIndex,
      isEven: index2 % 2 === 0,
      isOdd: Math.abs(index2 % 2) === 1
    };
  }, [maxIndexPath, indexPathString]);
}
function useIndexedChildren(children) {
  var parentMaxIndexPath = React__namespace.useContext(MaxIndexContext), indexPathString = React__namespace.useContext(IndexContext), childrenCount = React__namespace.Children.count(children), maxIndexPath = React__namespace.useMemo(function() {
    return parentMaxIndexPath.concat(childrenCount - 1);
  }, [childrenCount]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MaxIndexContext.Provider, {
    value: maxIndexPath,
    children: React__namespace.Children.map(children, function(child, index2) {
      return /* @__PURE__ */ React__namespace.isValidElement(child) ? /* @__PURE__ */ jsxRuntimeExports.jsx(IndexContext.Provider, {
        value: indexPathString ? `${indexPathString}.${index2.toString()}` : index2.toString(),
        children: child
      }, child.key) : child;
    })
  });
}
function parseIndexPath(indexPathString) {
  return indexPathString.split(".").map(function(index2) {
    return Number.parseInt(index2, 10);
  });
}
var GROUP_NAME$2 = "Group", [createGroupContext, createGroupScope] = createContextScope(GROUP_NAME$2), [GroupProvider, useGroupContext] = createGroupContext(GROUP_NAME$2), GroupFrame = styled(ThemeableStack, {
  name: "GroupFrame",
  variants: {
    unstyled: {
      false: {
        size: "$true"
      }
    },
    size: function(val, param) {
      var {
        tokens
      } = param, _tokens_radius_val, _ref, borderRadius = (_ref = (_tokens_radius_val = tokens.radius[val]) !== null && _tokens_radius_val !== void 0 ? _tokens_radius_val : val) !== null && _ref !== void 0 ? _ref : tokens.radius.$true;
      return {
        borderRadius
      };
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
});
function createGroup(verticalDefault) {
  return withStaticProperties(GroupFrame.styleable(function(props, ref) {
    var activeProps = useProps(props), _a = activeProps, {
      __scopeGroup,
      children: childrenProp,
      space,
      size = "$true",
      spaceDirection,
      separator,
      scrollable,
      axis = verticalDefault ? "vertical" : "horizontal",
      orientation = axis,
      disabled: disabledProp,
      disablePassBorderRadius: disablePassBorderRadiusProp,
      borderRadius,
      forceUseItem
    } = _a, restProps = __objRest(_a, [
      "__scopeGroup",
      "children",
      "space",
      "size",
      "spaceDirection",
      "separator",
      "scrollable",
      "axis",
      "orientation",
      "disabled",
      "disablePassBorderRadius",
      "borderRadius",
      "forceUseItem"
    ]), vertical = orientation === "vertical", [itemChildrenCount, setItemChildrenCount] = useControllableState({
      defaultProp: forceUseItem ? 1 : 0
    }), isUsingItems = itemChildrenCount > 0, radius = borderRadius != null ? borderRadius : size ? getVariableValue(getTokens().radius[size]) - 1 : void 0, hasRadius = radius !== void 0, disablePassBorderRadius = disablePassBorderRadiusProp != null ? disablePassBorderRadiusProp : !hasRadius, childrenArray = React.Children.toArray(childrenProp), children = isUsingItems ? React.Children.toArray(childrenProp).filter(React.isValidElement) : childrenArray.map(function(child, i) {
      if (!/* @__PURE__ */ React.isValidElement(child) || child.type === React.Fragment) return child;
      var _child_props_disabled, disabled = (_child_props_disabled = child.props.disabled) !== null && _child_props_disabled !== void 0 ? _child_props_disabled : disabledProp, isFirst = i === 0, isLast = i === childrenArray.length - 1, radiusStyles = disablePassBorderRadius === true ? null : getBorderRadius({
        isFirst,
        isLast,
        radius,
        vertical,
        disable: disablePassBorderRadius
      }), _$props = __spreadValues({
        disabled
      }, radiusStyles);
      return cloneElementWithPropOrder(child, _$props);
    }), indexedChildren = useIndexedChildren(spacedChildren({
      direction: spaceDirection,
      separator,
      space,
      children
    })), onItemMount = React.useCallback(function() {
      return setItemChildrenCount(function(prev) {
        return prev + 1;
      });
    }, []), onItemUnmount = React.useCallback(function() {
      return setItemChildrenCount(function(prev) {
        return prev - 1;
      });
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GroupProvider, {
      disablePassBorderRadius,
      vertical: orientation === "vertical",
      // @ts-ignore this just popped up since new version expo 49
      radius,
      disabled: disabledProp,
      onItemMount,
      onItemUnmount,
      scope: __scopeGroup,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(GroupFrame, __spreadProps(__spreadValues({
        ref,
        size,
        flexDirection: orientation === "horizontal" ? "row" : "column",
        borderRadius
      }, restProps), {
        children: wrapScroll(__spreadProps(__spreadValues({}, activeProps), {
          orientation
        }), indexedChildren)
      }))
    });
  }), {
    Item: GroupItem
  });
}
var GroupItem = /* @__PURE__ */ React.forwardRef(function(props, _ref) {
  var {
    __scopeGroup,
    children,
    forcePlacement
  } = props, groupItemProps = useGroupItem({
    disabled: /* @__PURE__ */ React.isValidElement(children) ? children.props.disabled : false
  }, forcePlacement, __scopeGroup);
  return !/* @__PURE__ */ React.isValidElement(children) || children.type === React.Fragment ? children : /* @__PURE__ */ React.cloneElement(children, groupItemProps);
}), useGroupItem = function(childrenProps, forcePlacement, __scopeGroup) {
  var treeIndex = useIndex(), context2 = useGroupContext("GroupItem", __scopeGroup);
  if (React.useEffect(function() {
    return context2.onItemMount(), function() {
      context2.onItemUnmount();
    };
  }, []), !treeIndex) throw Error("<Group.Item/> should only be used within a <Group/>");
  var isFirst = forcePlacement === "first" || forcePlacement !== "last" && treeIndex.index === 0, isLast = forcePlacement === "last" || forcePlacement !== "first" && treeIndex.index === treeIndex.maxIndex, _childrenProps_disabled, disabled = (_childrenProps_disabled = childrenProps.disabled) !== null && _childrenProps_disabled !== void 0 ? _childrenProps_disabled : context2.disabled, propsToPass = {
    disabled
  };
  if (context2.disablePassBorderRadius !== true) {
    var borderRadius = getBorderRadius({
      radius: context2.radius,
      isFirst,
      isLast,
      vertical: context2.vertical,
      disable: context2.disablePassBorderRadius
    });
    return __spreadValues(__spreadValues({}, propsToPass), borderRadius);
  }
  return propsToPass;
}, Group = createGroup(true), YGroup = Group, XGroup = createGroup(false), wrapScroll = function(param, children) {
  var {
    scrollable,
    orientation,
    showScrollIndicator = false
  } = param;
  return scrollable ? /* @__PURE__ */ jsxRuntimeExports.jsx(ForwardedScrollView, __spreadProps(__spreadValues(__spreadValues({}, orientation === "vertical" && {
    showsVerticalScrollIndicator: showScrollIndicator
  }), orientation === "horizontal" && {
    horizontal: true,
    showsHorizontalScrollIndicator: showScrollIndicator
  }), {
    children
  })) : children;
}, getBorderRadius = function(param) {
  var {
    isFirst,
    isLast,
    radius,
    vertical,
    disable
  } = param;
  return {
    borderTopLeftRadius: isFirst && disable !== "top" && disable !== "start" ? radius : 0,
    borderTopRightRadius: disable !== "top" && disable !== "end" && (vertical && isFirst || !vertical && isLast) ? radius : 0,
    borderBottomLeftRadius: disable !== "bottom" && disable !== "start" && (vertical && isLast || !vertical && isFirst) ? radius : 0,
    borderBottomRightRadius: isLast && disable !== "bottom" && disable !== "end" ? radius : 0
  };
}, cloneElementWithPropOrder = function(child, props) {
  return /* @__PURE__ */ React.cloneElement(__spreadProps(__spreadValues({}, child), {
    props: null
  }), __spreadValues(__spreadValues({}, child.props), props));
};
var Section = styled(View, {
  name: "Section",
  tag: "section",
  flexDirection: "column",
  accessibilityRole: "summary"
}), Article = styled(View, {
  name: "Article",
  tag: "article",
  flexDirection: "column"
}), Main = styled(View, {
  name: "Main",
  tag: "main",
  flexDirection: "column"
}), Header = styled(View, {
  name: "Header",
  tag: "header",
  accessibilityRole: "header",
  flexDirection: "column"
}), Aside = styled(View, {
  name: "Aside",
  tag: "aside",
  flexDirection: "column"
}), Footer = styled(View, {
  name: "Footer",
  tag: "footer",
  flexDirection: "column"
}), Nav = styled(View, {
  name: "Nav",
  tag: "nav",
  flexDirection: "column"
});
var NAME$1 = "ListItem", ListItemFrame = styled(ThemeableStack, {
  name: NAME$1,
  tag: "li",
  variants: {
    unstyled: {
      false: {
        size: "$true",
        alignItems: "center",
        justifyContent: "space-between",
        flexWrap: "nowrap",
        width: "100%",
        borderColor: "$borderColor",
        maxWidth: "100%",
        overflow: "hidden",
        flexDirection: "row",
        backgroundColor: "$background",
        cursor: "default"
      }
    },
    size: {
      "...size": function(val, param) {
        var {
          tokens
        } = param;
        return {
          minHeight: tokens.size[val],
          paddingHorizontal: tokens.space[val],
          paddingVertical: getSpace(tokens.space[val], {
            shift: -4
          })
        };
      }
    },
    active: {
      true: {
        hoverStyle: {
          backgroundColor: "$background"
        }
      }
    },
    disabled: {
      true: {
        opacity: 0.5,
        // TODO breaking types
        pointerEvents: "none"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), ListItemText = styled(SizableText, {
  name: "ListItemText",
  variants: {
    unstyled: {
      false: {
        color: "$color",
        size: "$true",
        flexGrow: 1,
        flexShrink: 1,
        ellipse: true,
        cursor: "inherit"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), ListItemSubtitle = styled(ListItemText, {
  name: "ListItemSubtitle",
  variants: {
    unstyled: {
      false: {
        opacity: 0.6,
        maxWidth: "100%",
        color: "$color"
      }
    },
    size: {
      "...size": function(val, extras) {
        var oneSmaller = getSize(val, {
          shift: -1,
          excludeHalfSteps: true
        }), fontStyle = getFontSized(oneSmaller.key, extras);
        return fontStyle;
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), ListItemTitle = styled(ListItemText, {
  name: "ListItemTitle"
}), useListItem = function(propsIn) {
  var {
    Text: Text2 = ListItemText,
    Subtitle = ListItemSubtitle,
    Title = ListItemTitle
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    Text: ListItemText,
    Subtitle: ListItemSubtitle,
    Title: ListItemTitle
  }, props = useProps(propsIn, {
    resolveValues: "none"
  }), _a = props, {
    children,
    icon,
    iconAfter,
    noTextWrap,
    theme: themeName,
    space,
    spaceFlex,
    scaleIcon = 1,
    scaleSpace = 1,
    unstyled = false,
    subTitle,
    title,
    color: color,
    fontWeight,
    fontSize,
    fontFamily,
    letterSpacing,
    textAlign,
    ellipse
  } = _a, rest = __objRest(_a, [
    "children",
    "icon",
    "iconAfter",
    "noTextWrap",
    "theme",
    "space",
    "spaceFlex",
    "scaleIcon",
    "scaleSpace",
    "unstyled",
    "subTitle",
    "title",
    // text props
    "color",
    "fontWeight",
    "fontSize",
    "fontFamily",
    "letterSpacing",
    "textAlign",
    "ellipse"
  ]), textProps = {
    color,
    fontWeight,
    fontSize,
    fontFamily,
    letterSpacing,
    textAlign,
    children
  }, size = props.size || "$true", iconSize = getFontSize(size) * scaleIcon, getThemedIcon = useGetThemedIcon({
    size: iconSize,
    color
  }), [themedIcon, themedIconAfter] = [icon, iconAfter].map(getThemedIcon), _getTokens_space_props_space, sizeToken = (_getTokens_space_props_space = getTokens().space[props.space]) !== null && _getTokens_space_props_space !== void 0 ? _getTokens_space_props_space : iconSize, spaceSize = getVariableValue(sizeToken) * scaleSpace, contents = wrapChildrenInText(Text2, textProps);
  return {
    props: __spreadProps(__spreadValues({}, rest), {
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [
          themedIcon ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [themedIcon, /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {
              size: spaceSize
            })]
          }) : null,
          /* helper for common title/subtitle pttern */
          /* biome-ignore lint/complexity/noExtraBooleanCast: <explanation> */
          title || subTitle ? /* @__PURE__ */ jsxRuntimeExports.jsxs(YStack, {
            flex: 1,
            children: [noTextWrap === "all" ? title : /* @__PURE__ */ jsxRuntimeExports.jsx(Title, {
              size,
              children: title
            }), subTitle ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
              children: typeof subTitle == "string" && noTextWrap !== "all" ? (
                // TODO can use theme but we need to standardize to alt themes
                // or standardize on subtle colors in themes
                /* @__PURE__ */ jsxRuntimeExports.jsx(Subtitle, {
                  unstyled,
                  size,
                  children: subTitle
                })
              ) : subTitle
            }) : null, contents]
          }) : contents,
          themedIconAfter ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {
              size: spaceSize
            }), themedIconAfter]
          }) : null
        ]
      })
    })
  };
}, ListItemComponent = ListItemFrame.styleable(function(props, ref) {
  var {
    props: listItemProps
  } = useListItem(props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemFrame, __spreadValues({
    ref
  }, listItemProps));
}), ListItem2 = withStaticProperties(ListItemComponent, {
  Text: ListItemText,
  Subtitle: ListItemSubtitle,
  Title: ListItemTitle
});
function Animate(param) {
  var _a = param, {
    children,
    lazyMount,
    type,
    present,
    passThrough
  } = _a, props = __objRest(_a, [
    "children",
    "lazyMount",
    "type",
    "present",
    "passThrough"
  ]), [lazyMounted, setLazyMounted] = React.useState(lazyMount ? false : present);
  React.useEffect(function() {
    passThrough || lazyMount && present && React.startTransition(function() {
      setLazyMounted(present);
    });
  }, [lazyMount, present]);
  var mounted = present ? lazyMount ? lazyMounted : present : false;
  return type === "presence" ? props.keepChildrenMounted ? /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceChild, __spreadProps(__spreadValues({
    isPresent: true
  }, !passThrough && {
    initial: props.initial ? void 0 : false,
    onExitComplete: props.onExitComplete,
    enterVariant: props.enterVariant,
    exitVariant: props.exitVariant,
    enterExitVariant: props.enterExitVariant,
    // BUGFIX: this causes continous re-renders if keepChildrenMounted is true, see HeaderMenu
    // but since we always re-render this component on open changes this should be fine to leave off?
    presenceAffectsLayout: false,
    isPresent: present,
    custom: props.custom
  }), {
    children
  })) : /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, __spreadProps(__spreadValues({
    passThrough
  }, props), {
    children: mounted || passThrough ? children : null
  })) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children
  });
}
const min = Math.min;
const max = Math.max;
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return __spreadValues({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, padding);
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition = (reference, floating, config) => __async(null, null, function* () {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(floating);
  let rects = yield platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = yield fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = __spreadProps(__spreadValues({}, middlewareData), {
      [name]: __spreadValues(__spreadValues({}, middlewareData[name]), data)
    });
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? yield platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
});
function detectOverflow(state, options) {
  return __async(this, null, function* () {
    var _await$platform$isEle;
    if (options === void 0) {
      options = {};
    }
    const {
      x,
      y,
      platform: platform2,
      rects,
      elements,
      strategy
    } = state;
    const {
      boundary = "clippingAncestors",
      rootBoundary = "viewport",
      elementContext = "floating",
      altBoundary = false,
      padding = 0
    } = evaluate(options, state);
    const paddingObject = getPaddingObject(padding);
    const altContext = elementContext === "floating" ? "reference" : "floating";
    const element = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = rectToClientRect(yield platform2.getClippingRect({
      element: ((_await$platform$isEle = yield platform2.isElement == null ? void 0 : platform2.isElement(element)) != null ? _await$platform$isEle : true) ? element : element.contextElement || (yield platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
      boundary,
      rootBoundary,
      strategy
    }));
    const rect = elementContext === "floating" ? {
      x,
      y,
      width: rects.floating.width,
      height: rects.floating.height
    } : rects.reference;
    const offsetParent = yield platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating);
    const offsetScale = (yield platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? (yield platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    };
    const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? yield platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
      elements,
      rect,
      offsetParent,
      strategy
    }) : rect);
    return {
      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
    };
  });
}
const arrow$2 = (options) => ({
  name: "arrow",
  options,
  fn(state) {
    return __async(this, null, function* () {
      const {
        x,
        y,
        placement,
        rects,
        platform: platform2,
        elements,
        middlewareData
      } = state;
      const {
        element,
        padding = 0
      } = evaluate(options, state) || {};
      if (element == null) {
        return {};
      }
      const paddingObject = getPaddingObject(padding);
      const coords = {
        x,
        y
      };
      const axis = getAlignmentAxis(placement);
      const length = getAxisLength(axis);
      const arrowDimensions = yield platform2.getDimensions(element);
      const isYAxis = axis === "y";
      const minProp = isYAxis ? "top" : "left";
      const maxProp = isYAxis ? "bottom" : "right";
      const clientProp = isYAxis ? "clientHeight" : "clientWidth";
      const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
      const startDiff = coords[axis] - rects.reference[axis];
      const arrowOffsetParent = yield platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element);
      let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
      if (!clientSize || !(yield platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
        clientSize = elements.floating[clientProp] || rects.floating[length];
      }
      const centerToReference = endDiff / 2 - startDiff / 2;
      const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
      const minPadding = min(paddingObject[minProp], largestPossiblePadding);
      const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
      const min$1 = minPadding;
      const max2 = clientSize - arrowDimensions[length] - maxPadding;
      const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
      const offset2 = clamp(min$1, center, max2);
      const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
      const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
      return {
        [axis]: coords[axis] + alignmentOffset,
        data: __spreadValues({
          [axis]: offset2,
          centerOffset: center - offset2 - alignmentOffset
        }, shouldAddOffset && {
          alignmentOffset
        }),
        reset: shouldAddOffset
      };
    });
  }
});
const flip$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    fn(state) {
      return __async(this, null, function* () {
        var _middlewareData$arrow, _middlewareData$flip;
        const {
          placement,
          middlewareData,
          rects,
          initialPlacement,
          platform: platform2,
          elements
        } = state;
        const _a2 = evaluate(options, state), {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true,
          fallbackPlacements: specifiedFallbackPlacements,
          fallbackStrategy = "bestFit",
          fallbackAxisSideDirection = "none",
          flipAlignment = true
        } = _a2, detectOverflowOptions = __objRest(_a2, [
          "mainAxis",
          "crossAxis",
          "fallbackPlacements",
          "fallbackStrategy",
          "fallbackAxisSideDirection",
          "flipAlignment"
        ]);
        if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        const side = getSide(placement);
        const initialSideAxis = getSideAxis(initialPlacement);
        const isBasePlacement = getSide(initialPlacement) === initialPlacement;
        const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating);
        const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
        const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
        if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
          fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
        }
        const placements = [initialPlacement, ...fallbackPlacements];
        const overflow = yield detectOverflow(state, detectOverflowOptions);
        const overflows = [];
        let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
        if (checkMainAxis) {
          overflows.push(overflow[side]);
        }
        if (checkCrossAxis) {
          const sides = getAlignmentSides(placement, rects, rtl);
          overflows.push(overflow[sides[0]], overflow[sides[1]]);
        }
        overflowsData = [...overflowsData, {
          placement,
          overflows
        }];
        if (!overflows.every((side2) => side2 <= 0)) {
          var _middlewareData$flip2, _overflowsData$filter;
          const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
          const nextPlacement = placements[nextIndex];
          if (nextPlacement) {
            var _overflowsData$;
            const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
            const hasInitialMainAxisOverflow = ((_overflowsData$ = overflowsData[0]) == null ? void 0 : _overflowsData$.overflows[0]) > 0;
            if (!ignoreCrossAxisOverflow || hasInitialMainAxisOverflow) {
              return {
                data: {
                  index: nextIndex,
                  overflows: overflowsData
                },
                reset: {
                  placement: nextPlacement
                }
              };
            }
          }
          let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b2) => a.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
          if (!resetPlacement) {
            switch (fallbackStrategy) {
              case "bestFit": {
                var _overflowsData$filter2;
                const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                  if (hasFallbackAxisSideDirection) {
                    const currentSideAxis = getSideAxis(d.placement);
                    return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                    // reading directions favoring greater width.
                    currentSideAxis === "y";
                  }
                  return true;
                }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b2) => a[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                if (placement2) {
                  resetPlacement = placement2;
                }
                break;
              }
              case "initialPlacement":
                resetPlacement = initialPlacement;
                break;
            }
          }
          if (placement !== resetPlacement) {
            return {
              reset: {
                placement: resetPlacement
              }
            };
          }
        }
        return {};
      });
    }
  };
};
function convertValueToCoords(state, options) {
  return __async(this, null, function* () {
    const {
      placement,
      platform: platform2,
      elements
    } = state;
    const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating);
    const side = getSide(placement);
    const alignment = getAlignment(placement);
    const isVertical = getSideAxis(placement) === "y";
    const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
    const crossAxisMulti = rtl && isVertical ? -1 : 1;
    const rawValue = evaluate(options, state);
    let {
      mainAxis,
      crossAxis,
      alignmentAxis
    } = typeof rawValue === "number" ? {
      mainAxis: rawValue,
      crossAxis: 0,
      alignmentAxis: null
    } : {
      mainAxis: rawValue.mainAxis || 0,
      crossAxis: rawValue.crossAxis || 0,
      alignmentAxis: rawValue.alignmentAxis
    };
    if (alignment && typeof alignmentAxis === "number") {
      crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
    }
    return isVertical ? {
      x: crossAxis * crossAxisMulti,
      y: mainAxis * mainAxisMulti
    } : {
      x: mainAxis * mainAxisMulti,
      y: crossAxis * crossAxisMulti
    };
  });
}
const offset$1 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    fn(state) {
      return __async(this, null, function* () {
        var _middlewareData$offse, _middlewareData$arrow;
        const {
          x,
          y,
          placement,
          middlewareData
        } = state;
        const diffCoords = yield convertValueToCoords(state, options);
        if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        return {
          x: x + diffCoords.x,
          y: y + diffCoords.y,
          data: __spreadProps(__spreadValues({}, diffCoords), {
            placement
          })
        };
      });
    }
  };
};
const shift$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    fn(state) {
      return __async(this, null, function* () {
        const {
          x,
          y,
          placement
        } = state;
        const _a2 = evaluate(options, state), {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = false,
          limiter = {
            fn: (_ref) => {
              let {
                x: x2,
                y: y2
              } = _ref;
              return {
                x: x2,
                y: y2
              };
            }
          }
        } = _a2, detectOverflowOptions = __objRest(_a2, [
          "mainAxis",
          "crossAxis",
          "limiter"
        ]);
        const coords = {
          x,
          y
        };
        const overflow = yield detectOverflow(state, detectOverflowOptions);
        const crossAxis = getSideAxis(getSide(placement));
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        if (checkMainAxis) {
          const minSide = mainAxis === "y" ? "top" : "left";
          const maxSide = mainAxis === "y" ? "bottom" : "right";
          const min2 = mainAxisCoord + overflow[minSide];
          const max2 = mainAxisCoord - overflow[maxSide];
          mainAxisCoord = clamp(min2, mainAxisCoord, max2);
        }
        if (checkCrossAxis) {
          const minSide = crossAxis === "y" ? "top" : "left";
          const maxSide = crossAxis === "y" ? "bottom" : "right";
          const min2 = crossAxisCoord + overflow[minSide];
          const max2 = crossAxisCoord - overflow[maxSide];
          crossAxisCoord = clamp(min2, crossAxisCoord, max2);
        }
        const limitedCoords = limiter.fn(__spreadProps(__spreadValues({}, state), {
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        }));
        return __spreadProps(__spreadValues({}, limitedCoords), {
          data: {
            x: limitedCoords.x - x,
            y: limitedCoords.y - y,
            enabled: {
              [mainAxis]: checkMainAxis,
              [crossAxis]: checkCrossAxis
            }
          }
        });
      });
    }
  };
};
const ORIGIN$1 = {
  x: 0,
  y: 0
};
function isView(reference) {
  return "measure" in reference;
}
const createPlatform = (_ref) => {
  let {
    offsetParent,
    sameScrollView = true,
    scrollOffsets = ORIGIN$1
  } = _ref;
  return {
    getElementRects(_ref2) {
      let {
        reference,
        floating
      } = _ref2;
      return new Promise((resolve) => {
        const onMeasure = function(offsetX, offsetY) {
          if (offsetX === void 0) {
            offsetX = 0;
          }
          if (offsetY === void 0) {
            offsetY = 0;
          }
          floating.measure((x, y, width, height) => {
            const floatingRect = __spreadValues({
              width,
              height
            }, ORIGIN$1);
            const method = sameScrollView ? "measure" : "measureInWindow";
            if (isView(reference)) {
              reference[method]((x2, y2, width2, height2) => {
                y2 = y2;
                const referenceRect = {
                  width: width2,
                  height: height2,
                  x: x2 - offsetX,
                  y: y2 - offsetY
                };
                resolve({
                  reference: referenceRect,
                  floating: floatingRect
                });
              });
            } else {
              const boundingRect = reference.getBoundingClientRect();
              const referenceRect = {
                width: boundingRect.width,
                height: boundingRect.height,
                x: boundingRect.x - offsetX,
                y: boundingRect.y - offsetY
              };
              resolve({
                reference: referenceRect,
                floating: floatingRect
              });
            }
          });
        };
        if (offsetParent) {
          offsetParent.measure(onMeasure);
        } else {
          onMeasure();
        }
      });
    },
    getClippingRect() {
      const {
        width: windowWidth,
        height: windowHeight
      } = Dimensions.get("window");
      const {
        height: screenHeight
      } = Dimensions.get("screen");
      const navigationBarHeight = 0;
      return Promise.resolve(__spreadValues({
        width: windowWidth,
        height: screenHeight - navigationBarHeight
      }, sameScrollView ? scrollOffsets : ORIGIN$1));
    },
    convertOffsetParentRelativeRectToViewportRelativeRect(_ref3) {
      let {
        rect
      } = _ref3;
      return new Promise((resolve) => {
        const onMeasure = function(offsetX, offsetY) {
          if (offsetX === void 0) {
            offsetX = 0;
          }
          if (offsetY === void 0) {
            offsetY = 0;
          }
          resolve(__spreadProps(__spreadValues({}, rect), {
            x: rect.x + offsetX,
            y: rect.y + offsetY
          }));
        };
        if (offsetParent) {
          offsetParent.measure(onMeasure);
        } else {
          onMeasure();
        }
      });
    },
    getDimensions: (element) => new Promise((resolve) => element.measure((x, y, width, height) => resolve({
      width,
      height
    })))
  };
};
function deepEqual(a, b2) {
  if (a === b2) {
    return true;
  }
  if (typeof a !== typeof b2) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b2.toString()) {
    return true;
  }
  let length;
  let i;
  let keys;
  if (a && b2 && typeof a === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b2.length) return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b2[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b2).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b2, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b2[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b2 !== b2;
}
const ORIGIN = {
  x: 0,
  y: 0
};
function useFloating$1(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    middleware = [],
    sameScrollView = true,
    elements: {
      reference: externalReference,
      floating: externalFloating,
      offsetParent: externalOffsetParent
    } = {}
  } = options;
  const [_reference, _setReference] = React__namespace.useState(null);
  const [_floating, _setFloating] = React__namespace.useState(null);
  const [_offsetParent, _setOffsetParent] = React__namespace.useState(null);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const offsetParentEl = externalOffsetParent || _offsetParent;
  const setReference = React__namespace.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React__namespace.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const setOffsetParent = React__namespace.useCallback((node) => {
    if (node !== offsetParentRef.current) {
      offsetParentRef.current = node;
      _setOffsetParent(node);
    }
  }, []);
  const referenceRef = React__namespace.useRef(null);
  const floatingRef = React__namespace.useRef(null);
  const offsetParentRef = React__namespace.useRef(null);
  const [data, setData] = React__namespace.useState({
    x: 0,
    y: 0,
    placement,
    strategy: "absolute",
    middlewareData: {}
  });
  const [scrollOffsets, setScrollOffsets] = React__namespace.useState(ORIGIN);
  const [latestMiddleware, setLatestMiddleware] = React__namespace.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const platform2 = React__namespace.useMemo(() => createPlatform({
    offsetParent: offsetParentEl,
    scrollOffsets,
    sameScrollView
  }), [offsetParentEl, scrollOffsets, sameScrollView]);
  const update2 = React__namespace.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    computePosition(referenceRef.current, floatingRef.current, {
      middleware: latestMiddleware,
      platform: platform2,
      placement
    }).then((data2) => {
      if (isMountedRef.current) {
        setData(data2);
      }
    });
  }, [latestMiddleware, platform2, placement]);
  React__namespace.useLayoutEffect(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (offsetParentEl) offsetParentRef.current = offsetParentEl;
    const frame = requestAnimationFrame(update2);
    return () => {
      cancelAnimationFrame(frame);
    };
  }, [referenceEl, floatingEl, offsetParentEl, update2]);
  const isMountedRef = React__namespace.useRef(true);
  React__namespace.useLayoutEffect(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  const refs = React__namespace.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    offsetParent: offsetParentRef,
    setReference,
    setFloating,
    setOffsetParent
  }), [setReference, setFloating, setOffsetParent]);
  const elements = React__namespace.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl,
    offsetParent: offsetParentEl
  }), [referenceEl, floatingEl, offsetParentEl]);
  const floatingStyles = React__namespace.useMemo(() => {
    if (!elements.floating) {
      return {
        position: "absolute",
        left: 0,
        top: 0
      };
    }
    return {
      position: "absolute",
      left: data.x,
      top: data.y
    };
  }, [elements.floating, data.x, data.y]);
  return React__namespace.useMemo(() => __spreadProps(__spreadValues({}, data), {
    update: update2,
    refs,
    elements,
    floatingStyles,
    offsetParent: setOffsetParent,
    reference: setReference,
    floating: setFloating,
    scrollProps: {
      onScroll: (event) => setScrollOffsets(event.nativeEvent.contentOffset),
      scrollEventThrottle: 16
    }
  }), [data, refs, elements, floatingStyles, setReference, setFloating, setOffsetParent, update2]);
}
const arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow$2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow$2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
const offset = (options, deps) => __spreadProps(__spreadValues({}, offset$1(options)), {
  options: [options, deps]
});
const shift = (options, deps) => __spreadProps(__spreadValues({}, shift$1(options)), {
  options: [options, deps]
});
const flip = (options, deps) => __spreadProps(__spreadValues({}, flip$1(options)), {
  options: [options, deps]
});
const arrow = (options, deps) => __spreadProps(__spreadValues({}, arrow$1(options)), {
  options: [options, deps]
});
var autoUpdate = function() {
}, platform = null;
var FloatingOverrideContext = /* @__PURE__ */ React.createContext(null), useFloating = function(props) {
  var _this, context2 = React.useContext(FloatingOverrideContext);
  return (_this = context2 || useFloating$1) === null || _this === void 0 ? void 0 : _this(__spreadProps(__spreadValues({}, props), {
    middleware: [
      // @ts-ignore
      ...props.middleware,
      {
        name: "rounded",
        fn(param) {
          var {
            x,
            y
          } = param;
          return {
            x: Math.round(x),
            y: Math.round(y)
          };
        }
      }
    ]
  }));
};
var PopperContextFast = createStyledContext(
  // since we always provide this we can avoid setting here
  {},
  "Popper__"
), PopperPositionContext = createStyledContext, {
  useStyledContext: usePopperContext,
  Provider: PopperProviderFast
} = PopperContextFast, PopperContextSlow = createStyledContext(
  // since we always provide this we can avoid setting here
  {},
  "PopperSlow__"
), {
  useStyledContext: usePopperContextSlow,
  Provider: PopperProviderSlow
} = PopperContextSlow, PopperProvider = function(param) {
  var _a = param, {
    scope,
    children
  } = _a, context2 = __objRest(_a, [
    "scope",
    "children"
  ]), slowContext = getContextSlow(context2);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperProviderFast, __spreadProps(__spreadValues({
    scope
  }, context2), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopperProviderSlow, __spreadProps(__spreadValues({
      scope
    }, slowContext), {
      children
    }))
  }));
};
function getContextSlow(context2) {
  return {
    refs: context2.refs,
    size: context2.size,
    arrowRef: context2.arrowRef,
    arrowStyle: context2.arrowStyle,
    onArrowSize: context2.onArrowSize,
    hasFloating: context2.hasFloating,
    strategy: context2.strategy,
    update: context2.update,
    context: context2.context,
    getFloatingProps: context2.getFloatingProps,
    getReferenceProps: context2.getReferenceProps,
    open: context2.open
  };
}
var checkFloating = {
  name: "checkFloating",
  fn(data) {
    return {
      data: {
        hasFloating: !!data.rects.floating.width
      }
    };
  }
}, setupOptions = {};
function setupPopper(options) {
  Object.assign(setupOptions, options);
}
function Popper(props) {
  var {
    children,
    size,
    strategy = "absolute",
    placement = "bottom",
    stayInFrame,
    allowFlip,
    offset: offset$12,
    disableRTL,
    resize,
    passThrough,
    open: open2,
    scope
  } = props, [arrowEl, setArrow] = React__namespace.useState(null), [arrowSize, setArrowSize] = React__namespace.useState(0), offsetOptions = offset$12 != null ? offset$12 : arrowSize;
  React__namespace.useRef({});
  var isOpen = passThrough ? false : open2 || true, floating = useFloating({
    open: isOpen,
    strategy,
    placement,
    sameScrollView: false,
    // this only takes effect on native
    whileElementsMounted: isOpen ? autoUpdate : void 0,
    platform: (disableRTL != null ? disableRTL : setupOptions.disableRTL) ? __spreadProps(__spreadValues({}, platform), {
      isRTL(element) {
        return false;
      }
    }) : platform,
    middleware: [stayInFrame ? shift(typeof stayInFrame == "boolean" ? {} : stayInFrame) : null, allowFlip ? flip(typeof allowFlip == "boolean" ? {} : allowFlip) : null, arrowEl ? arrow({
      element: arrowEl
    }) : null, typeof offsetOptions < "u" ? offset(offsetOptions) : null, checkFloating, null].filter(Boolean)
  }), {
    middlewareData
  } = floating, dimensions2 = useWindowDimensions$1(), [keyboardOpen, setKeyboardOpen] = React__namespace.useState(false);
  React__namespace.useEffect(function() {
    var showSubscription = Keyboard.addListener("keyboardDidShow", function() {
      startTransition(function() {
        setKeyboardOpen(true);
      });
    }), hideSubscription = Keyboard.addListener("keyboardDidHide", function() {
      startTransition(function() {
        setKeyboardOpen(false);
      });
    });
    return function() {
      showSubscription.remove(), hideSubscription.remove();
    };
  }, []), useIsomorphicLayoutEffect(function() {
    passThrough || floating.update();
  }, [passThrough, dimensions2, keyboardOpen]);
  var popperContext = React__namespace.useMemo(function() {
    var _middlewareData_checkFloating;
    return __spreadValues({
      size,
      arrowRef: setArrow,
      arrowStyle: middlewareData.arrow,
      onArrowSize: setArrowSize,
      hasFloating: (_middlewareData_checkFloating = middlewareData.checkFloating) === null || _middlewareData_checkFloating === void 0 ? void 0 : _middlewareData_checkFloating.hasFloating,
      open: !!open2
    }, floating);
  }, [open2, size, floating.x, floating.y, floating.placement, JSON.stringify(middlewareData.arrow || null), floating.isPositioned]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(LayoutMeasurementController, {
    disable: !isOpen,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopperProvider, __spreadProps(__spreadValues({
      scope
    }, popperContext), {
      children
    }))
  });
}
var PopperAnchor = YStack.extractable(/* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    virtualRef,
    scope
  } = _a, anchorProps = __objRest(_a, [
    "virtualRef",
    "scope"
  ]), context2 = usePopperContextSlow(scope), {
    getReferenceProps,
    refs,
    update: update2
  } = context2, ref = React__namespace.useRef(null);
  React__namespace.useEffect(function() {
    virtualRef && refs.setReference(virtualRef.current);
  }, [virtualRef]);
  var stackProps = anchorProps, refProps = getReferenceProps ? getReferenceProps(stackProps) : null, shouldHandleInHover = isWeb, composedRefs = useComposedRefs(
    forwardedRef,
    ref,
    // web handles this onMouseEnter below so it can support multiple targets + hovering
    refs.setReference
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(View, __spreadValues(__spreadProps(__spreadValues(__spreadValues({}, stackProps), refProps), {
    ref: composedRefs
  }), shouldHandleInHover));
})), PopperContentFrame = styled(ThemeableStack, {
  name: "PopperContent",
  variants: {
    unstyled: {
      false: {
        size: "$true",
        backgroundColor: "$background",
        alignItems: "center",
        radiused: true
      }
    },
    size: {
      "...size": function(val, param) {
        var {
          tokens
        } = param;
        return {
          padding: tokens.space[val],
          borderRadius: tokens.radius[val]
        };
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), PopperContent = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    scope,
    enableAnimationForPositionChange,
    children,
    passThrough
  } = _a, rest = __objRest(_a, [
    "scope",
    "enableAnimationForPositionChange",
    "children",
    "passThrough"
  ]), context2 = usePopperContext(scope), {
    strategy,
    placement,
    refs,
    x,
    y,
    getFloatingProps,
    size,
    isPositioned
  } = context2, contentRefs = useComposedRefs(refs.setFloating, forwardedRef), [needsMeasure, setNeedsMeasure] = React__namespace.useState(enableAnimationForPositionChange);
  useIsomorphicLayoutEffect(function() {
    needsMeasure && x && y && setNeedsMeasure(false);
  }, [needsMeasure, enableAnimationForPositionChange, x, y]);
  var hide = x === 0 && y === 0, disableAnimationProp = (
    // if they want to animate also when re-positioning allow it
    enableAnimationForPositionChange === "even-when-repositioning" ? needsMeasure : !isPositioned || needsMeasure
  ), [disableAnimation, setDisableAnimation] = React__namespace.useState(disableAnimationProp);
  React__namespace.useEffect(function() {
    setDisableAnimation(disableAnimationProp);
  }, [disableAnimationProp]);
  var frameProps = __spreadValues(__spreadValues({
    ref: contentRefs,
    x: x || 0,
    y: y || 0,
    top: 0,
    left: 0,
    position: strategy,
    opacity: 1
  }, enableAnimationForPositionChange && {
    animation: rest.animation,
    animateOnly: disableAnimation ? [] : rest.animateOnly,
    // apply animation but disable it on initial render to avoid animating from 0 to the first position
    animatePresence: false
  }), hide && {
    opacity: 0,
    animateOnly: []
  }), _b = getFloatingProps ? getFloatingProps(frameProps) : frameProps, {
    style
  } = _b, floatingProps = __objRest(_b, [
    "style"
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(View, __spreadProps(__spreadValues({
    passThrough,
    ref: contentRefs,
    contain: "layout style"
  }, passThrough ? null : floatingProps), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopperContentFrame, __spreadProps(__spreadValues({
      passThrough
    }, !passThrough && __spreadValues(__spreadValues({
      "data-placement": placement,
      "data-strategy": strategy,
      size
    }, style), rest)), {
      children
    }), "popper-content-frame")
  }));
}), PopperArrowFrame = styled(YStack, {
  name: "PopperArrow",
  variants: {
    unstyled: {
      false: {
        borderColor: "$borderColor",
        backgroundColor: "$background",
        position: "relative"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), PopperArrowOuterFrame = styled(YStack, {
  name: "PopperArrowOuter",
  variants: {
    unstyled: {
      false: {
        position: "absolute",
        zIndex: 1e6,
        pointerEvents: "none",
        overflow: "hidden",
        alignItems: "center",
        justifyContent: "center"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), opposites = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, PopperArrow = /* @__PURE__ */ React__namespace.forwardRef(function(propsIn, forwardedRef) {
  var _context_arrowStyle, _context_arrowStyle1, _a = propsIn, {
    scope
  } = _a, rest = __objRest(_a, [
    "scope"
  ]), props = useProps(rest), _b = props, {
    offset: offset2,
    size: sizeProp,
    borderWidth = 0
  } = _b, arrowProps = __objRest(_b, [
    "offset",
    "size",
    "borderWidth"
  ]), context2 = usePopperContext(scope), sizeVal = typeof sizeProp == "number" ? sizeProp : getVariableValue(getSpace(sizeProp != null ? sizeProp : context2.size, {
    shift: -2,
    bounds: [2]
  })), size = Math.max(0, +sizeVal), {
    placement
  } = context2, refs = useComposedRefs(context2.arrowRef, forwardedRef), x = ((_context_arrowStyle = context2.arrowStyle) === null || _context_arrowStyle === void 0 ? void 0 : _context_arrowStyle.x) || 0, y = ((_context_arrowStyle1 = context2.arrowStyle) === null || _context_arrowStyle1 === void 0 ? void 0 : _context_arrowStyle1.y) || 0, primaryPlacement = placement ? placement.split("-")[0] : "top", arrowStyle = {
    x,
    y,
    width: size,
    height: size
  }, innerArrowStyle = {}, isVertical = primaryPlacement === "bottom" || primaryPlacement === "top";
  if (primaryPlacement) {
    arrowStyle[isVertical ? "width" : "height"] = size * 2;
    var oppSide = opposites[primaryPlacement];
    oppSide && (arrowStyle[oppSide] = -size, innerArrowStyle[oppSide] = size / 2), (oppSide === "top" || oppSide === "bottom") && (arrowStyle.left = 0), (oppSide === "left" || oppSide === "right") && (arrowStyle.top = 0), useIsomorphicLayoutEffect(function() {
      var _context_onArrowSize;
      (_context_onArrowSize = context2.onArrowSize) === null || _context_onArrowSize === void 0 || _context_onArrowSize.call(context2, size);
    }, [size, context2.onArrowSize]);
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperArrowOuterFrame, __spreadProps(__spreadValues({
    ref: refs
  }, arrowStyle), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopperArrowFrame, __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadProps(__spreadValues(__spreadValues({
      width: size,
      height: size
    }, arrowProps), innerArrowStyle), {
      rotate: "45deg"
    }), primaryPlacement === "bottom" && {
      borderLeftWidth: borderWidth,
      borderTopWidth: borderWidth
    }), primaryPlacement === "top" && {
      borderBottomWidth: borderWidth,
      borderRightWidth: borderWidth
    }), primaryPlacement === "right" && {
      borderLeftWidth: borderWidth,
      borderBottomWidth: borderWidth
    }), primaryPlacement === "left" && {
      borderTopWidth: borderWidth,
      borderRightWidth: borderWidth
    }))
  }));
});
var useFloatingContext = function() {
  return React.useCallback(function() {
  }, []);
};
var needsRepropagation = isAndroid || isIos && !USE_NATIVE_PORTAL, PopoverContext = createStyledContext(
  // since we always provide this we can avoid setting here
  {},
  "Popover__"
), usePopoverContext = PopoverContext.useStyledContext, PopoverAnchor = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, rest = __objRest(_a, [
    "scope"
  ]), context2 = usePopoverContext(scope), {
    onCustomAnchorAdd,
    onCustomAnchorRemove
  } = context2 || {};
  return React__namespace.useEffect(function() {
    return onCustomAnchorAdd(), function() {
      return onCustomAnchorRemove();
    };
  }, [onCustomAnchorAdd, onCustomAnchorRemove]), /* @__PURE__ */ jsxRuntimeExports.jsx(PopperAnchor, __spreadProps(__spreadValues({
    scope
  }, rest), {
    ref: forwardedRef
  }));
}), PopoverTrigger = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, rest = __objRest(_a, [
    "scope"
  ]), context2 = usePopoverContext(scope), anchorTo = context2.anchorTo, composedTriggerRef = useComposedRefs(forwardedRef, context2.triggerRef);
  if (!props.children) return null;
  var trigger = /* @__PURE__ */ jsxRuntimeExports.jsx(View, __spreadProps(__spreadValues({
    "aria-expanded": context2.open,
    // TODO not matching
    // aria-controls={context.contentId}
    "data-state": getState$1(context2.open)
  }, rest), {
    // @ts-ignore
    ref: composedTriggerRef,
    onPress: composeEventHandlers(props.onPress, context2.onOpenToggle)
  })), virtualRef = React__namespace.useMemo(function() {
    return anchorTo ? {
      current: __spreadValues({
        getBoundingClientRect: function() {
          return anchorTo;
        }
      }, {
        measure: function(c) {
          return c(anchorTo == null ? void 0 : anchorTo.x, anchorTo == null ? void 0 : anchorTo.y, anchorTo == null ? void 0 : anchorTo.width, anchorTo == null ? void 0 : anchorTo.height);
        },
        measureInWindow: function(c) {
          return c(anchorTo == null ? void 0 : anchorTo.x, anchorTo == null ? void 0 : anchorTo.y, anchorTo == null ? void 0 : anchorTo.width, anchorTo == null ? void 0 : anchorTo.height);
        }
      })
    } : null;
  }, [context2.anchorTo, anchorTo == null ? void 0 : anchorTo.x, anchorTo == null ? void 0 : anchorTo.y, anchorTo == null ? void 0 : anchorTo.x, anchorTo == null ? void 0 : anchorTo.height, anchorTo == null ? void 0 : anchorTo.width]);
  return context2.hasCustomAnchor ? trigger : /* @__PURE__ */ jsxRuntimeExports.jsx(PopperAnchor, __spreadProps(__spreadValues({}, virtualRef && {
    virtualRef
  }), {
    scope,
    asChild: rest.asChild,
    children: trigger
  }));
}), PopoverContentFrame = styled(PopperContentFrame, {
  name: "Popover"
}), PopoverContent = PopoverContentFrame.extractable(/* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    trapFocus,
    enableRemoveScroll = false,
    zIndex,
    scope
  } = _a, contentImplProps = __objRest(_a, [
    "trapFocus",
    "enableRemoveScroll",
    "zIndex",
    "scope"
  ]), context2 = usePopoverContext(scope), contentRef = React__namespace.useRef(null), composedRefs = useComposedRefs(forwardedRef, contentRef), isRightClickOutsideRef = React__namespace.useRef(false), [isFullyHidden, setIsFullyHidden] = React__namespace.useState(!context2.open);
  if (context2.open && isFullyHidden && setIsFullyHidden(false), !context2.keepChildrenMounted && isFullyHidden) return null;
  var _contentImplProps_pointerEvents;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverPortal, {
    passThrough: context2.breakpointActive,
    context: context2,
    zIndex,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, {
      passThrough: context2.breakpointActive,
      pointerEvents: context2.open ? (_contentImplProps_pointerEvents = contentImplProps.pointerEvents) !== null && _contentImplProps_pointerEvents !== void 0 ? _contentImplProps_pointerEvents : "auto" : "none",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContentImpl, __spreadProps(__spreadValues({}, contentImplProps), {
        context: context2,
        enableRemoveScroll,
        ref: composedRefs,
        setIsFullyHidden,
        scope,
        // we make sure we're not trapping once it's been closed
        // (closed !== unmounted when animating out)
        trapFocus: trapFocus != null ? trapFocus : context2.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: props.onCloseAutoFocus === false ? void 0 : composeEventHandlers(props.onCloseAutoFocus, function(event) {
          var _context_triggerRef_current;
          event.defaultPrevented || (event.preventDefault(), isRightClickOutsideRef.current || (_context_triggerRef_current = context2.triggerRef.current) === null || _context_triggerRef_current === void 0 || _context_triggerRef_current.focus());
        }),
        onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, function(event) {
          var originalEvent = event.detail.originalEvent, ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true, isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          isRightClickOutsideRef.current = isRightClick;
        }, {
          checkDefaultPrevented: false
        }),
        // When focus is trapped, a `focusout` event may still happen.
        // We make sure we don't trigger our `onDismiss` in such case.
        onFocusOutside: composeEventHandlers(props.onFocusOutside, function(event) {
          return event.preventDefault();
        }, {
          checkDefaultPrevented: false
        })
      }))
    })
  });
})), useParentContexts = function(scope) {
  var context2 = usePopoverContext(scope), popperContext = usePopperContext(scope), adaptContext = useAdaptContext(context2.adaptScope);
  return {
    popperContext,
    adaptContext,
    context: context2
  };
};
function RepropagateParentContexts(param) {
  var {
    adaptContext,
    children,
    context: context2,
    popperContext
  } = param;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperProvider, __spreadProps(__spreadValues({
    scope: context2.popoverScope
  }, popperContext), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContext.Provider, __spreadProps(__spreadValues({}, context2), {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ProvideAdaptContext, __spreadProps(__spreadValues({}, adaptContext), {
        children
      }))
    }))
  }));
}
var PortalAdaptSafe = function(param) {
  var {
    children,
    context: context2
  } = param;
  if (needsRepropagation) {
    var parentContexts = useParentContexts(context2.popoverScope);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(AdaptPortalContents, {
      scope: context2.adaptScope,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(RepropagateParentContexts, __spreadProps(__spreadValues({}, parentContexts), {
        children
      }))
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AdaptPortalContents, {
    scope: context2.adaptScope,
    children
  });
};
function PopoverPortal(param) {
  var {
    context: context2,
    zIndex,
    passThrough,
    children,
    onPress
  } = param, themeName = useThemeName(), content = children;
  if (needsRepropagation) {
    var parentContexts = useParentContexts(context2.popoverScope);
    content = /* @__PURE__ */ jsxRuntimeExports.jsx(RepropagateParentContexts, __spreadProps(__spreadValues({}, parentContexts), {
      children: content
    }));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
    passThrough,
    stackZIndex: true,
    zIndex,
    children: (
      /* forceClassName avoids forced re-mount renders for some reason... see the HeadMenu as you change tints a few times */
      /* without this you'll see the site menu re-rendering. It must be something in wrapping children in Theme */
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Theme, {
        passThrough,
        contain: true,
        forceClassName: true,
        name: themeName,
        children: [!!context2.open && !context2.breakpointActive && /* @__PURE__ */ jsxRuntimeExports.jsx(YStack, {
          fullscreen: true,
          onPress: composeEventHandlers(onPress, context2.onOpenToggle)
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(StackZIndexContext, {
          zIndex: resolveViewZIndex(zIndex),
          children: content
        })]
      })
    )
  });
}
var PopoverContentImpl = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    trapFocus,
    scope,
    onOpenAutoFocus,
    onCloseAutoFocus,
    disableOutsidePointerEvents,
    disableFocusScope,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onInteractOutside,
    children,
    enableRemoveScroll,
    freezeContentsWhenHidden,
    setIsFullyHidden,
    lazyMount,
    context: context2
  } = _a, contentProps = __objRest(_a, [
    "trapFocus",
    "scope",
    "onOpenAutoFocus",
    "onCloseAutoFocus",
    "disableOutsidePointerEvents",
    "disableFocusScope",
    "onEscapeKeyDown",
    "onPointerDownOutside",
    "onFocusOutside",
    "onInteractOutside",
    "children",
    "enableRemoveScroll",
    "freezeContentsWhenHidden",
    "setIsFullyHidden",
    "lazyMount",
    "context"
  ]), {
    open: open2,
    keepChildrenMounted
  } = context2, handleExitComplete = React__namespace.useCallback(function() {
    setIsFullyHidden == null ? void 0 : setIsFullyHidden(true);
  }, [setIsFullyHidden]), contents = /* @__PURE__ */ jsxRuntimeExports.jsx(ResetPresence, {
    disable: context2.breakpointActive,
    children
  });
  return context2.breakpointActive, /* @__PURE__ */ jsxRuntimeExports.jsx(Animate, {
    type: "presence",
    present: !!open2,
    keepChildrenMounted: !!keepChildrenMounted,
    onExitComplete: handleExitComplete,
    lazyMount,
    passThrough: context2.breakpointActive,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopperContent, __spreadProps(__spreadValues({
      scope,
      "data-state": getState$1(open2),
      id: context2.contentId,
      ref: forwardedRef,
      passThrough: context2.breakpointActive
    }, contentProps), {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PortalAdaptSafe, {
        context: context2,
        children: contents
      })
    }), context2.contentId)
  });
});
var PopoverClose = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, rest = __objRest(_a, [
    "scope"
  ]), context2 = usePopoverContext(scope);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(YStack, __spreadProps(__spreadValues({}, rest), {
    ref: forwardedRef,
    componentName: "PopoverClose",
    onPress: composeEventHandlers(props.onPress, function() {
      var _context_onOpenChange;
      return context2 == null || (_context_onOpenChange = context2.onOpenChange) === null || _context_onOpenChange === void 0 ? void 0 : _context_onOpenChange.call(context2, false, "press");
    })
  }));
}), PopoverArrow = PopperArrowFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, rest = __objRest(_a, [
    "scope"
  ]), context2 = usePopoverContext(scope), isAdapted = useAdaptIsActive(context2.adaptScope);
  return isAdapted ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(PopperArrow, __spreadProps(__spreadValues({
    scope,
    componentName: "PopoverArrow"
  }, rest), {
    ref: forwardedRef
  }));
}), PopoverScrollView = /* @__PURE__ */ React__namespace.forwardRef(function(param, ref) {
  var _a = param, {
    scope
  } = _a, props = __objRest(_a, [
    "scope"
  ]), context2 = usePopoverContext(scope);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollView2, __spreadValues({
    ref,
    // when adapted, no pointer events!
    pointerEvents: context2.breakpointActive ? "none" : void 0,
    scrollEnabled: !context2.breakpointActive,
    passThrough: context2.breakpointActive
  }, props));
}), DEFAULT_SCOPE = "", Popover = withStaticProperties(/* @__PURE__ */ React__namespace.forwardRef(function(param, ref) {
  var _a = param, {
    scope = DEFAULT_SCOPE
  } = _a, props = __objRest(_a, [
    "scope"
  ]), id2 = React__namespace.useId(), adaptScope = `PopoverAdapt${scope}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AdaptParent, {
    scope: adaptScope,
    portal: true,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverInner, __spreadValues({
      adaptScope,
      ref,
      id: id2,
      scope
    }, props))
  });
}), {
  Anchor: PopoverAnchor,
  Arrow: PopoverArrow,
  Trigger: PopoverTrigger,
  Content: PopoverContent,
  Close: PopoverClose,
  Adapt,
  ScrollView: PopoverScrollView,
  Sheet: Sheet.Controlled,
  FocusScope: FocusScopeControllerComponent
}), PopoverInner = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    scope = DEFAULT_SCOPE,
    keepChildrenMounted: keepChildrenMountedProp,
    hoverable,
    disableFocus,
    id: id2,
    adaptScope
  } = _a, restProps = __objRest(_a, [
    "children",
    "open",
    "defaultOpen",
    "onOpenChange",
    "scope",
    "keepChildrenMounted",
    "hoverable",
    "disableFocus",
    "id",
    "adaptScope"
  ]), triggerRef = React__namespace.useRef(null), [hasCustomAnchor, setHasCustomAnchor] = React__namespace.useState(false), viaRef = React__namespace.useRef(void 0), [keepChildrenMounted] = useControllableState({
    prop: keepChildrenMountedProp,
    defaultProp: false,
    transition: keepChildrenMountedProp === "lazy"
  }), [open2, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen || false,
    onChange: function(val) {
      onOpenChange == null ? void 0 : onOpenChange(val, viaRef.current);
    }
  }), handleOpenChange = useEvent(function(val, via) {
    viaRef.current = via, setOpen(val);
  }), isAdapted = useAdaptIsActive(adaptScope);
  useFloatingContext();
  var [anchorTo, setAnchorToRaw] = React__namespace.useState(), setAnchorTo = useCreateShallowSetState(setAnchorToRaw);
  React__namespace.useImperativeHandle(forwardedRef, function() {
    return {
      anchorTo: setAnchorTo,
      toggle: function() {
        return setOpen(function(prev) {
          return !prev;
        });
      },
      open: function() {
        return setOpen(true);
      },
      close: function() {
        return setOpen(false);
      },
      setOpen
    };
  });
  var popoverContext = {
    popoverScope: scope,
    adaptScope,
    id: id2,
    contentId: React__namespace.useId(),
    triggerRef,
    open: open2,
    breakpointActive: isAdapted,
    onOpenChange: handleOpenChange,
    onOpenToggle: useEvent(function() {
      open2 && isAdapted || setOpen(!open2);
    }),
    hasCustomAnchor,
    anchorTo,
    onCustomAnchorAdd: React__namespace.useCallback(function() {
      return setHasCustomAnchor(true);
    }, []),
    onCustomAnchorRemove: React__namespace.useCallback(function() {
      return setHasCustomAnchor(false);
    }, []),
    keepChildrenMounted
  }, memoizedChildren = React__namespace.useMemo(function() {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContext.Provider, __spreadProps(__spreadValues({
      scope
    }, popoverContext), {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverSheetController, {
        context: popoverContext,
        onOpenChange: setOpen,
        children
      })
    }));
  }, [scope, setOpen, children, ...Object.values(popoverContext)]), contents = /* @__PURE__ */ jsxRuntimeExports.jsx(Popper, __spreadProps(__spreadValues({
    open: open2,
    passThrough: isAdapted,
    scope,
    stayInFrame: true
  }, restProps), {
    children: memoizedChildren
  }));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children: contents
  });
});
function getState$1(open2) {
  return open2 ? "open" : "closed";
}
var PopoverSheetController = function(param) {
  var _a = param, {
    context: context2
  } = _a, props = __objRest(_a, [
    "context"
  ]), showSheet = useShowPopoverSheet(context2), breakpointActive = context2.breakpointActive, getShowSheet = useGet(showSheet);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SheetController, {
    onOpenChange: function(val) {
      if (getShowSheet()) {
        var _props_onOpenChange;
        (_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 || _props_onOpenChange.call(props, val);
      }
    },
    open: context2.open,
    hidden: !breakpointActive,
    children: props.children
  });
}, useShowPopoverSheet = function(context2) {
  var isAdapted = useAdaptIsActive(context2.adaptScope);
  return context2.open === false ? false : isAdapted;
};
var PROGRESS_NAME = "Progress", [createProgressContext, createProgressScope] = createContextScope(PROGRESS_NAME), [ProgressProvider, useProgressContext] = createProgressContext(PROGRESS_NAME), INDICATOR_NAME = "ProgressIndicator", ProgressIndicatorFrame = styled(ThemeableStack, {
  name: INDICATOR_NAME,
  variants: {
    unstyled: {
      false: {
        height: "100%",
        width: "100%",
        backgrounded: true
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), ProgressIndicator = ProgressIndicatorFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    __scopeProgress,
    animation
  } = _a, indicatorProps = __objRest(_a, [
    "__scopeProgress",
    "animation"
  ]), context2 = useProgressContext(INDICATOR_NAME, __scopeProgress), _context_value, pct = context2.max - ((_context_value = context2.value) !== null && _context_value !== void 0 ? _context_value : 0), x = -(context2.width === 0 ? 300 : context2.width) * (pct / 100), _context_value1;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ProgressIndicatorFrame, __spreadProps(__spreadValues(__spreadValues({
    "data-state": getProgressState(context2.value, context2.max),
    "data-value": (_context_value1 = context2.value) !== null && _context_value1 !== void 0 ? _context_value1 : void 0,
    "data-max": context2.max,
    x,
    width: context2.width
  }, !props.unstyled && {
    animateOnly: ["transform"],
    opacity: context2.width === 0 ? 0 : 1
  }), indicatorProps), {
    ref: forwardedRef,
    // avoid animation on first render so the progress doesn't bounce to initial location
    animation: context2.width ? animation : null
  }));
});
function defaultGetValueLabel(value, max2) {
  return `${Math.round(value / max2 * 100)}%`;
}
function getProgressState(value, maxValue) {
  return value == null ? "indeterminate" : value === maxValue ? "complete" : "loading";
}
function isNumber(value) {
  return typeof value == "number";
}
function isValidMaxNumber(max2) {
  return isNumber(max2) && !Number.isNaN(max2) && max2 > 0;
}
function isValidValueNumber(value, max2) {
  return isNumber(value) && !Number.isNaN(value) && value <= max2 && value >= 0;
}
var DEFAULT_MAX = 100, ProgressFrame = styled(ThemeableStack, {
  name: "Progress",
  variants: {
    unstyled: {
      false: {
        borderRadius: 1e5,
        overflow: "hidden",
        backgrounded: true
      }
    },
    size: {
      "...size": function(val) {
        var size = Math.round(getVariableValue(getSize(val)) * 0.25);
        return {
          height: size,
          minWidth: getVariableValue(size) * 20,
          width: "100%"
        };
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), Progress = withStaticProperties(ProgressFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    __scopeProgress: __scopeProgress,
    value: valueProp,
    max: maxProp,
    getValueLabel = defaultGetValueLabel,
    size = "$true"
  } = _a, progressProps = __objRest(_a, [
    // @ts-expect-error
    "__scopeProgress",
    "value",
    "max",
    "getValueLabel",
    "size"
  ]), max2 = isValidMaxNumber(maxProp) ? maxProp : DEFAULT_MAX, value = isValidValueNumber(valueProp, max2) ? valueProp : null, valueLabel = isNumber(value) ? getValueLabel(value, max2) : void 0, [width, setWidth] = React__namespace.useState(0);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ProgressProvider, {
    scope: __scopeProgress,
    value,
    max: max2,
    width,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ProgressFrame, __spreadProps(__spreadValues(__spreadValues({
      "aria-valuemax": max2,
      "aria-valuemin": 0,
      "aria-valuenow": isNumber(value) ? value : void 0,
      "aria-valuetext": valueLabel,
      // @ts-ignore
      role: "progressbar",
      "data-state": getProgressState(value, max2),
      "data-value": value != null ? value : void 0,
      "data-max": max2
    }, progressProps.unstyled !== true && {
      size
    }), progressProps), {
      onLayout: function(e2) {
        var _progressProps_onLayout;
        setWidth(e2.nativeEvent.layout.width), (_progressProps_onLayout = progressProps.onLayout) === null || _progressProps_onLayout === void 0 || _progressProps_onLayout.call(progressProps, e2);
      },
      ref: forwardedRef
    }))
  });
}), {
  Indicator: ProgressIndicator
});
var RADIO_GROUP_ITEM_NAME = "RadioGroupItem", RadioGroupItemFrame = styled(ThemeableStack, {
  name: RADIO_GROUP_ITEM_NAME,
  tag: "button",
  variants: {
    unstyled: {
      false: {
        size: "$true",
        borderRadius: 1e3,
        backgroundColor: "$background",
        alignItems: "center",
        justifyContent: "center",
        borderWidth: 1,
        borderColor: "$borderColor",
        padding: 0,
        hoverStyle: {
          borderColor: "$borderColorHover",
          backgroundColor: "$backgroundHover"
        },
        focusStyle: {
          borderColor: "$borderColorHover",
          backgroundColor: "$backgroundHover"
        },
        focusVisibleStyle: {
          outlineStyle: "solid",
          outlineWidth: 2,
          outlineColor: "$outlineColor"
        },
        pressStyle: {
          borderColor: "$borderColorFocus",
          backgroundColor: "$backgroundFocus"
        }
      }
    },
    disabled: {
      true: {
        pointerEvents: "none",
        userSelect: "none",
        cursor: "not-allowed",
        hoverStyle: {
          borderColor: "$borderColor",
          backgroundColor: "$background"
        },
        pressStyle: {
          borderColor: "$borderColor",
          backgroundColor: "$background"
        },
        focusVisibleStyle: {
          outlineWidth: 0
        }
      }
    },
    size: {
      "...size": function(value, param) {
        var {
          props
        } = param, _props_scaleSize, size = Math.floor(getVariableValue(getSize(value)) * ((_props_scaleSize = props.scaleSize) !== null && _props_scaleSize !== void 0 ? _props_scaleSize : 0.5));
        return {
          width: size,
          height: size
        };
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), RADIO_GROUP_INDICATOR_NAME = "RadioGroupIndicator", RadioGroupIndicatorFrame = styled(ThemeableStack, {
  name: RADIO_GROUP_INDICATOR_NAME,
  variants: {
    unstyled: {
      false: {
        width: "33%",
        height: "33%",
        borderRadius: 1e3,
        backgroundColor: "$color",
        pressTheme: true
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), RADIO_GROUP_NAME = "RadioGroup", RadioGroupFrame = styled(ThemeableStack, {
  name: RADIO_GROUP_NAME,
  variants: {
    orientation: {
      horizontal: {
        flexDirection: "row",
        spaceDirection: "horizontal"
      },
      vertical: {
        flexDirection: "column",
        spaceDirection: "vertical"
      }
    }
  }
});
var BubbleInput = function(props) {
  var _a = props, {
    checked,
    bubbles = true,
    control,
    isHidden,
    accentColor
  } = _a, inputProps = __objRest(_a, [
    "checked",
    "bubbles",
    "control",
    "isHidden",
    "accentColor"
  ]), ref = React.useRef(null), prevChecked = usePrevious(checked);
  return React.useEffect(function() {
    var input = ref.current, inputProto = window.HTMLInputElement.prototype, descriptor = Object.getOwnPropertyDescriptor(inputProto, "checked"), setChecked = descriptor.set;
    if (prevChecked !== checked && setChecked) {
      var event = new Event("click", {
        bubbles
      });
      setChecked.call(input, checked), input.dispatchEvent(event);
    }
  }, [prevChecked, checked, bubbles]), /* @__PURE__ */ jsxRuntimeExports.jsx("input", __spreadProps(__spreadValues({
    type: "radio",
    defaultChecked: checked
  }, inputProps), {
    tabIndex: -1,
    ref,
    "aria-hidden": isHidden,
    style: __spreadValues(__spreadValues({}, isHidden ? {
      // ...controlSize,
      position: "absolute",
      pointerEvents: "none",
      opacity: 0,
      margin: 0
    } : {
      appearance: "auto",
      accentColor
    }), props.style)
  }));
};
function getState(checked) {
  return checked ? "checked" : "unchecked";
}
function useRadioGroup(params) {
  var {
    value: valueProp,
    onValueChange,
    defaultValue: defaultValue2,
    required,
    disabled,
    name,
    native,
    accentColor,
    orientation
  } = params, [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue2,
    onChange: onValueChange
  });
  return {
    providerValue: {
      value,
      onChange: setValue,
      required,
      disabled,
      name,
      native,
      accentColor
    },
    frameAttrs: {
      role: "radiogroup",
      "aria-orientation": orientation,
      "data-disabled": disabled ? "" : void 0
    },
    rovingFocusGroupAttrs: {
      orientation,
      loop: true
    }
  };
}
var useRadioGroupItem = function(params) {
  var {
    radioGroupContext,
    value,
    labelledBy: ariaLabelledby,
    disabled: itemDisabled,
    ref: refProp,
    id: id2,
    onPress
  } = params, {
    value: groupValue,
    disabled,
    required,
    onChange,
    name,
    native,
    accentColor
  } = React.useContext(radioGroupContext), [button, setButton] = React.useState(null), hasConsumerStoppedPropagationRef = React.useRef(false), ref = React.useRef(null), composedRefs = useComposedRefs(refProp, function(node) {
    return setButton(node);
  }, ref);
  React.useRef(false);
  var isFormControl = false, checked = groupValue === value, labelId = useLabelContext(button), labelledBy = ariaLabelledby || labelId;
  React.useEffect(function() {
  }, []), React.useEffect(function() {
    if (id2 && !disabled) return registerFocusable(id2, {
      focusAndSelect: function() {
        onChange == null ? void 0 : onChange(value);
      },
      focus: function() {
      }
    });
  }, [id2, value, disabled]);
  var isDisabled2 = disabled || itemDisabled;
  return {
    providerValue: {
      checked
    },
    checked,
    isFormControl,
    bubbleInput: /* @__PURE__ */ jsxRuntimeExports.jsx(BubbleInput, __spreadValues({
      isHidden: !native,
      control: button,
      bubbles: !hasConsumerStoppedPropagationRef.current,
      name,
      value,
      checked,
      required,
      disabled: isDisabled2
    }, isWeb)),
    native,
    frameAttrs: __spreadValues(__spreadProps(__spreadValues({
      "data-state": getState(checked),
      "data-disabled": isDisabled2 ? "" : void 0,
      role: "radio",
      "aria-labelledby": labelledBy,
      "aria-checked": checked,
      "aria-required": required,
      disabled: isDisabled2,
      ref: composedRefs
    }, isWeb), {
      id: id2,
      onPress: composeEventHandlers(onPress, function(event) {
        checked || (onChange == null ? void 0 : onChange(value));
      })
    }), isWeb),
    rovingFocusGroupAttrs: {
      asChild: "expect-style",
      focusable: !isDisabled2,
      active: checked
    }
  };
};
function useRadioGroupItemIndicator(params) {
  var _a = params, {
    radioGroupItemContext,
    disabled
  } = _a, rest = __objRest(_a, [
    "radioGroupItemContext",
    "disabled"
  ]), {
    checked
  } = React.useContext(radioGroupItemContext);
  return __spreadValues({
    checked,
    "data-state": getState(checked),
    "data-disabled": disabled ? "" : void 0
  }, rest);
}
var ITEM_NAME$1 = "RovingFocusGroupItem", RovingFocusGroupItem = /* @__PURE__ */ React.forwardRef(function(param, _ref) {
  var _a = param, {
    children
  } = _a, props = __objRest(_a, [
    "children"
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, __spreadProps(__spreadValues({}, props), {
    children
  }));
});
RovingFocusGroupItem.displayName = ITEM_NAME$1;
var GROUP_NAME$1 = "RovingFocusGroup", RovingFocusGroup = withStaticProperties(/* @__PURE__ */ React.forwardRef(function(param, _ref) {
  var _a = param, {
    children
  } = _a, props = __objRest(_a, [
    "children"
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, __spreadProps(__spreadValues({}, props), {
    children
  }));
}), {
  Item: RovingFocusGroupItem
});
RovingFocusGroup.displayName = GROUP_NAME$1;
var ensureContext = function(x) {
  x.context || (x.context = RadioGroupContext);
}, RadioGroupContext = /* @__PURE__ */ React.createContext({}), RadioGroupItemContext = /* @__PURE__ */ React.createContext({
  checked: false,
  disabled: false
});
function createRadioGroup(createProps) {
  var {
    disableActiveTheme,
    Frame: Frame2 = RadioGroupFrame,
    Indicator = RadioGroupIndicatorFrame,
    Item = RadioGroupItemFrame
  } = createProps;
  ensureContext(Frame2), ensureContext(Indicator), ensureContext(Item);
  var RadioGroupImp = Frame2.styleable(function(props, ref) {
    var _a = props, {
      value,
      defaultValue: defaultValue2,
      onValueChange,
      required = false,
      disabled = false,
      name,
      native,
      accentColor,
      orientation = "vertical"
    } = _a, rest = __objRest(_a, [
      "value",
      "defaultValue",
      "onValueChange",
      "required",
      "disabled",
      "name",
      "native",
      "accentColor",
      "orientation"
    ]), {
      providerValue,
      frameAttrs,
      rovingFocusGroupAttrs
    } = useRadioGroup({
      orientation,
      name,
      defaultValue: defaultValue2,
      value,
      onValueChange,
      required,
      disabled,
      native,
      accentColor
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroupContext.Provider, {
      value: providerValue,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(RovingFocusGroup, __spreadProps(__spreadValues({}, rovingFocusGroupAttrs), {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroupFrame, __spreadValues(__spreadProps(__spreadValues({}, frameAttrs), {
          ref
        }), rest))
      }))
    });
  }), RadioGroupItemImp = Item.styleable(function(props, ref) {
    var _a = props, {
      value,
      labelledBy,
      onPress,
      onKeyDown: onKeyDown,
      disabled,
      id: id2
    } = _a, rest = __objRest(_a, [
      "value",
      "labelledBy",
      "onPress",
      //@ts-expect-error
      "onKeyDown",
      "disabled",
      "id"
    ]), {
      providerValue,
      rovingFocusGroupAttrs,
      frameAttrs,
      isFormControl
    } = useRadioGroupItem({
      radioGroupContext: RadioGroupContext,
      value,
      id: id2,
      labelledBy,
      disabled,
      onPress
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroupItemContext.Provider, {
      value: providerValue,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(RovingFocusGroup.Item, __spreadProps(__spreadValues({}, rovingFocusGroupAttrs), {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroupItemFrame, __spreadValues(__spreadProps(__spreadValues({}, frameAttrs), {
            ref
          }), rest))
        })), isFormControl]
      })
    });
  });
  RadioGroupItemImp.displayName = "RadioGroupItem";
  var RadioIndicator = Indicator.styleable(function(props, forwardedRef) {
    var _a = props, {
      forceMount,
      disabled
    } = _a, indicatorProps = __objRest(_a, [
      "forceMount",
      "disabled"
    ]), _b = useRadioGroupItemIndicator({
      radioGroupItemContext: RadioGroupItemContext,
      disabled
    }), {
      checked
    } = _b, useIndicatorRest = __objRest(_b, [
      "checked"
    ]);
    return forceMount || checked ? /* @__PURE__ */ jsxRuntimeExports.jsx(Indicator, __spreadValues(__spreadProps(__spreadValues({}, useIndicatorRest), {
      ref: forwardedRef
    }), indicatorProps)) : null;
  });
  RadioIndicator.displayName = "RadioIndicator";
  var RadioGroup2 = withStaticProperties(RadioGroupImp, {
    Item: RadioGroupItemImp,
    Indicator: RadioIndicator
  });
  return RadioGroup2.displayName = "RadioGroup", RadioGroup2;
}
var RadioGroupStyledContext = createStyledContext({
  size: "$true",
  scaleIcon: 1
}, "RadioGroup");
var RadioGroup = createRadioGroup({
  Frame: RadioGroupFrame,
  Indicator: RadioGroupIndicatorFrame,
  Item: RadioGroupItemFrame
});
var Separator = styled(Stack, {
  name: "Separator",
  borderColor: "$borderColor",
  flexShrink: 0,
  borderWidth: 0,
  flex: 1,
  height: 0,
  maxHeight: 0,
  borderBottomWidth: 1,
  y: -0.5,
  variants: {
    vertical: {
      true: {
        y: 0,
        x: -0.5,
        height: "auto",
        // maxHeight auto WILL BE passed to style attribute, but for some reason not used?
        // almost seems like a react or browser bug, but for now `initial` works
        // also, it doesn't happen for `height`, but for consistency using the same values
        maxHeight: "auto",
        width: 0,
        maxWidth: 0,
        borderBottomWidth: 0,
        borderRightWidth: 1
      }
    }
  }
});
function debounce(func, wait, leading) {
  var timeout, isCancelled = false;
  function debounced() {
    var _this = this;
    isCancelled = false;
    var args = arguments;
    leading && !timeout && func.apply(this, args), clearTimeout(timeout), timeout = setTimeout(function() {
      timeout = null, leading || isCancelled || func.apply(_this, args), isCancelled = false;
    }, wait);
  }
  return debounced.cancel = function() {
    isCancelled = true;
  }, debounced;
}
var defaultOpts = {
  leading: false
};
function useDebounce(fn, wait) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultOpts, mountArgs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [fn], dbEffect = React__namespace.useRef(null);
  return React__namespace.useEffect(function() {
    return function() {
      var _dbEffect_current;
      (_dbEffect_current = dbEffect.current) === null || _dbEffect_current === void 0 || _dbEffect_current.cancel();
    };
  }, []), React__namespace.useMemo(function() {
    return dbEffect.current = debounce(fn, wait, options.leading), dbEffect.current;
  }, [options.leading, ...mountArgs]);
}
function useDebounceValue(val) {
  var amt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, [state, setState] = React__namespace.useState(val);
  return React__namespace.useEffect(function() {
    var tm = setTimeout(function() {
      setState(function(prev) {
        return prev === val ? prev : val;
      });
    }, amt);
    return function() {
      clearTimeout(tm);
    };
  }, [val]), state;
}
var {
  Provider: SelectProvider,
  useStyledContext: useSelectContext
} = createStyledContext(null, "Select"), {
  Provider: SelectItemParentProvider,
  useStyledContext: useSelectItemParentContext
} = createStyledContext(null, "SelectItem"), ForwardSelectContext = function(param) {
  var {
    context: context2,
    itemContext,
    children
  } = param;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectProvider, __spreadProps(__spreadValues({
    isInSheet: true,
    scope: context2.scopeName
  }, context2), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItemParentProvider, __spreadProps(__spreadValues({
      scope: context2.scopeName
    }, itemContext), {
      children
    }))
  }));
};
var SelectContent = function(param) {
  var {
    children
  } = param;
  return children;
};
var ITEM_NAME = "SelectItem", {
  Provider: SelectItemContextProvider,
  useStyledContext: useSelectItemContext
} = createStyledContext(null, ITEM_NAME), SelectItem = ListItemFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    scope,
    value,
    disabled = false,
    textValue: textValueProp,
    index: index2
  } = _a, restProps = __objRest(_a, [
    "scope",
    "value",
    "disabled",
    "textValue",
    "index"
  ]), {
    props: listItemProps
  } = useListItem(__spreadValues(__spreadValues({}, !props.unstyled && {
    ellipse: true
  }), restProps)), context2 = useSelectItemParentContext(scope), {
    setSelectedIndex,
    listRef,
    setOpen,
    onChange,
    activeIndexSubscribe,
    valueSubscribe,
    allowMouseUpRef,
    allowSelectRef,
    setValueAtIndex,
    selectTimeoutRef,
    dataRef,
    interactions,
    shouldRenderWebNative,
    size,
    onActiveChange,
    initialValue: initialValue2
  } = context2, [isSelected, setSelected] = React__namespace.useState(initialValue2 === value);
  React__namespace.useEffect(function() {
    return activeIndexSubscribe(function(i) {
      var isActive = index2 === i;
      if (isActive) {
        var _listRef_current_index;
        onActiveChange(value, index2), listRef == null || (_listRef_current_index = listRef.current[index2]) === null || _listRef_current_index === void 0 || _listRef_current_index.focus();
      }
    });
  }, [index2]), React__namespace.useEffect(function() {
    return valueSubscribe(function(val) {
      setSelected(val === value);
    });
  }, [value]);
  var textId = React__namespace.useId(), refCallback = React__namespace.useCallback(function(node) {
  }, []), composedRefs = useComposedRefs(forwardedRef, refCallback);
  useIsomorphicLayoutEffect(function() {
    setValueAtIndex(index2, value);
  }, [index2, setValueAtIndex, value]);
  function handleSelect() {
    setSelectedIndex(index2), onChange(value), setOpen(false);
  }
  var selectItemProps = React__namespace.useMemo(function() {
    return interactions ? interactions.getItemProps({
      onTouchMove() {
        allowSelectRef.current = true, allowMouseUpRef.current = false;
      },
      onTouchEnd() {
        allowSelectRef.current = false, allowMouseUpRef.current = true;
      },
      onKeyDown(event) {
        event.key === "Enter" || event.key === " " && !(dataRef == null ? void 0 : dataRef.current.typing) ? (event.preventDefault(), handleSelect()) : allowSelectRef.current = true;
      },
      onClick() {
        allowSelectRef.current && handleSelect();
      },
      onMouseUp() {
        allowMouseUpRef.current && (allowSelectRef.current && handleSelect(), clearTimeout(selectTimeoutRef.current), selectTimeoutRef.current = setTimeout(function() {
          allowSelectRef.current = true;
        }));
      }
    }) : {
      onPress: handleSelect
    };
  }, [handleSelect]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItemContextProvider, {
    scope,
    value,
    textId: textId || "",
    isSelected,
    children: shouldRenderWebNative ? /* @__PURE__ */ jsxRuntimeExports.jsx("option", {
      value,
      children: props.children
    }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemFrame, __spreadValues(__spreadValues(__spreadValues({
      tag: "div",
      componentName: ITEM_NAME,
      ref: composedRefs,
      "aria-labelledby": textId,
      "aria-selected": isSelected,
      "data-state": isSelected ? "active" : "inactive",
      "aria-disabled": disabled || void 0,
      "data-disabled": disabled ? "" : void 0,
      tabIndex: disabled ? void 0 : -1
    }, !props.unstyled && {
      backgrounded: true,
      pressTheme: true,
      hoverTheme: true,
      focusTheme: true,
      cursor: "default",
      size,
      outlineOffset: -0.5,
      focusVisibleStyle: {
        outlineColor: "$outlineColor",
        outlineWidth: 1,
        outlineStyle: "solid"
      }
    }), listItemProps), selectItemProps))
  });
}, {
  disableTheme: true
});
var ITEM_TEXT_NAME = "SelectItemText", SelectItemTextFrame = styled(SizableText, {
  name: ITEM_TEXT_NAME,
  variants: {
    unstyled: {
      false: {
        userSelect: "none",
        color: "$color",
        ellipse: true
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), SelectItemText = SelectItemTextFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    scope,
    className
  } = _a, itemTextProps = __objRest(_a, [
    "scope",
    "className"
  ]), context2 = useSelectContext(scope), itemParentContext = useSelectItemParentContext(scope), ref = React__namespace.useRef(null), composedRefs = useComposedRefs(forwardedRef, ref), itemContext = useSelectItemContext(scope), contents = React__namespace.useRef(null);
  return contents.current = /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItemTextFrame, __spreadProps(__spreadValues({
    className,
    size: itemParentContext.size,
    id: itemContext.textId
  }, itemTextProps), {
    ref: composedRefs
  })), useIsomorphicLayoutEffect(function() {
    itemParentContext.initialValue === itemContext.value && !context2.selectedIndex && context2.setSelectedItem(contents.current);
  }, []), useIsomorphicLayoutEffect(function() {
    return itemParentContext.valueSubscribe(function(val) {
      val === itemContext.value && context2.setSelectedItem(contents.current);
    });
  }, [itemContext.value]), itemParentContext.shouldRenderWebNative ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children: props.children
  }) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children: contents.current
  });
});
var SelectScrollUpButton = function(_) {
  return null;
}, SelectScrollDownButton = function(_) {
  return null;
};
var TRIGGER_NAME$1 = "SelectTrigger", SelectTrigger = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _context_floatingContext, _a = props, {
    scope,
    disabled = false,
    unstyled = false
  } = _a, triggerProps = __objRest(_a, [
    "scope",
    "disabled",
    "unstyled"
  ]), context2 = useSelectContext(scope), itemParentContext = useSelectItemParentContext(scope), composedRefs = useComposedRefs(forwardedRef, (_context_floatingContext = context2.floatingContext) === null || _context_floatingContext === void 0 ? void 0 : _context_floatingContext.refs.setReference);
  return itemParentContext.shouldRenderWebNative ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem2, __spreadProps(__spreadValues(__spreadProps(__spreadValues({
    componentName: TRIGGER_NAME$1,
    unstyled,
    tag: "button",
    type: "button",
    id: itemParentContext.id
  }, !unstyled && {
    backgrounded: true,
    radiused: true,
    hoverTheme: true,
    pressTheme: true,
    focusable: true,
    focusVisibleStyle: {
      outlineStyle: "solid",
      outlineWidth: 2,
      outlineColor: "$outlineColor"
    },
    borderWidth: 1,
    size: itemParentContext.size
  }), {
    // aria-controls={context.contentId}
    "aria-expanded": context2.open,
    "aria-autocomplete": "none",
    dir: context2.dir,
    disabled,
    "data-disabled": disabled ? "" : void 0
  }), triggerProps), {
    ref: composedRefs,
    onPress() {
      itemParentContext.setOpen(!context2.open);
    }
  }));
});
var VIEWPORT_NAME = "SelectViewport";
var SelectViewport = function(props) {
  var {
    scope,
    children
  } = props, context2 = useSelectContext(scope), itemParentContext = useSelectItemParentContext(scope), themeName = useThemeName(), adaptContext = useAdaptContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AdaptPortalContents, {
    scope: context2.adaptScope,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Theme, {
      name: themeName,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ForwardSelectContext, {
        itemContext: itemParentContext,
        context: context2,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(AdaptContext.Provider, __spreadProps(__spreadValues({}, adaptContext), {
          children
        }))
      })
    })
  });
};
SelectViewport.displayName = VIEWPORT_NAME;
var useShowSelectSheet = function(context2) {
  var breakpointActive = useAdaptIsActive(context2.adaptScope);
  return context2.open === false ? false : breakpointActive;
};
var VALUE_NAME = "SelectValue", SelectValueFrame = styled(SizableText, {
  name: VALUE_NAME,
  userSelect: "none"
}), SelectValue = SelectValueFrame.styleable(function(param, forwardedRef) {
  var _a = param, {
    scope,
    children: childrenProp,
    placeholder
  } = _a, props = __objRest(_a, [
    "scope",
    "children",
    "placeholder"
  ]), context2 = useSelectContext(scope), itemParentContext = useSelectItemParentContext(scope), composedRefs = useComposedRefs(forwardedRef, context2.onValueNodeChange), children = childrenProp != null ? childrenProp : context2.selectedItem, isEmptyValue = context2.value == null || context2.value === "", selectValueChildren = isEmptyValue ? placeholder != null ? placeholder : children : children;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValueFrame, __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, !props.unstyled && {
    size: itemParentContext.size,
    ellipse: true,
    // we don't want events from the portalled `SelectValue` children to bubble
    // through the item they came from
    pointerEvents: "none"
  }), {
    ref: composedRefs
  }), props), {
    children: unwrapSelectItem(selectValueChildren)
  }));
});
function unwrapSelectItem(selectValueChildren) {
  return React__namespace.Children.map(selectValueChildren, function(child) {
    if (child) {
      var _child_type_staticConfig, _child_type, _child_props;
      if (((_child_type = child.type) === null || _child_type === void 0 || (_child_type_staticConfig = _child_type.staticConfig) === null || _child_type_staticConfig === void 0 ? void 0 : _child_type_staticConfig.componentName) === ITEM_TEXT_NAME) return child.props.children;
      if (!((_child_props = child.props) === null || _child_props === void 0) && _child_props.children) return unwrapSelectItem(child.props.children);
    }
    return child;
  });
}
var SelectIcon = styled(XStack, {
  name: "SelectIcon",
  // @ts-ignore
  "aria-hidden": true,
  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Paragraph, {
    children: ""
  })
}), SelectItemIndicatorFrame = styled(XStack, {
  name: "SelectItemIndicator"
}), SelectItemIndicator = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, itemIndicatorProps = __objRest(_a, [
    "scope"
  ]), context2 = useSelectItemParentContext(scope), itemContext = useSelectItemContext(scope);
  return context2.shouldRenderWebNative ? null : itemContext.isSelected ? /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItemIndicatorFrame, __spreadProps(__spreadValues({
    "aria-hidden": true
  }, itemIndicatorProps), {
    ref: forwardedRef
  })) : null;
}), GROUP_NAME = "SelectGroup", {
  Provider: SelectGroupContextProvider,
  useStyledContext: useSelectGroupContext
} = createStyledContext({
  id: ""
}, "SelectGroup"), SelectGroupFrame = styled(YStack, {
  name: GROUP_NAME,
  width: "100%"
}), NativeSelectTextFrame = styled(SizableText, {
  tag: "select",
  backgroundColor: "$background",
  borderColor: "$borderColor",
  hoverStyle: {
    backgroundColor: "$backgroundHover"
  }
}), NativeSelectFrame = styled(ThemeableStack, {
  name: "NativeSelect",
  bordered: true,
  userSelect: "none",
  outlineWidth: 0,
  paddingRight: 10,
  variants: {
    size: {
      "...size": function(val, extras) {
        var {
          tokens
        } = extras, paddingHorizontal = getVariableValue(tokens.space[val]), _tokens_radius_val;
        return {
          borderRadius: (_tokens_radius_val = tokens.radius[val]) !== null && _tokens_radius_val !== void 0 ? _tokens_radius_val : val,
          minHeight: tokens.size[val],
          paddingRight: paddingHorizontal + 20,
          paddingLeft: paddingHorizontal,
          paddingVertical: getSpace(val, {
            shift: -3
          })
        };
      }
    }
  },
  defaultVariants: {
    size: "$2"
  }
}), SelectGroup = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, groupProps = __objRest(_a, [
    "scope"
  ]), groupId = React__namespace.useId(), context2 = useSelectContext(scope), itemParentContext = useSelectItemParentContext(scope), _itemParentContext_size, size = (_itemParentContext_size = itemParentContext.size) !== null && _itemParentContext_size !== void 0 ? _itemParentContext_size : "$true", nativeSelectRef = React__namespace.useRef(null), content = (function() {
    return itemParentContext.shouldRenderWebNative ? /* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectFrame, {
      asChild: true,
      size,
      // @ts-expect-error until we support typing based on tag
      value: context2.value,
      id: itemParentContext.id,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectTextFrame, {
        // @ts-ignore it's ok since tag="select"
        onChange: function(event) {
          itemParentContext.onChange(event.currentTarget.value);
        },
        size,
        ref: nativeSelectRef,
        style: {
          color: "var(--color)",
          // @ts-ignore
          appearance: "none"
        },
        children: props.children
      })
    }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SelectGroupFrame, __spreadProps(__spreadValues({
      // @ts-ignore
      role: "group",
      "aria-labelledby": groupId
    }, groupProps), {
      ref: forwardedRef
    }));
  })();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectGroupContextProvider, {
    scope,
    id: groupId || "",
    children: content
  });
});
SelectGroup.displayName = GROUP_NAME;
var LABEL_NAME = "SelectLabel", SelectLabel = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, labelProps = __objRest(_a, [
    "scope"
  ]), context2 = useSelectItemParentContext(scope), groupContext = useSelectGroupContext(scope);
  return context2.shouldRenderWebNative ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem2, __spreadProps(__spreadValues({
    tag: "div",
    componentName: LABEL_NAME,
    fontWeight: "800",
    id: groupContext.id,
    size: context2.size
  }, labelProps), {
    ref: forwardedRef
  }));
});
SelectLabel.displayName = LABEL_NAME;
var SelectSeparator = styled(Separator, {
  name: "SelectSeparator"
}), SelectSheetController = function(props) {
  var context2 = useSelectContext(props.scope), showSheet = useShowSelectSheet(context2), isAdapted = useAdaptIsActive(context2.adaptScope), getShowSheet = useGet(showSheet);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SheetController, {
    onOpenChange: function(val) {
      getShowSheet() && props.onOpenChange(val);
    },
    open: context2.open,
    hidden: !isAdapted,
    children: props.children
  });
}, SelectSheetImpl = function(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children: props.children
  });
}, Select = withStaticProperties(function(props) {
  var adaptScope = `AdaptSelect${props.scope || ""}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AdaptParent, {
    scope: adaptScope,
    portal: true,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectInner, __spreadValues({
      scope: props.scope,
      adaptScope
    }, props))
  });
}, {
  Adapt,
  Content: SelectContent,
  Group: SelectGroup,
  Icon: SelectIcon,
  Item: SelectItem,
  ItemIndicator: SelectItemIndicator,
  ItemText: SelectItemText,
  Label: SelectLabel,
  ScrollDownButton: SelectScrollDownButton,
  ScrollUpButton: SelectScrollUpButton,
  Trigger: SelectTrigger,
  Value: SelectValue,
  Viewport: SelectViewport,
  Sheet: Sheet.Controlled,
  FocusScope: FocusScopeControllerComponent
});
function useEmitter() {
  var listeners2 = React__namespace.useRef(null);
  listeners2.current || (listeners2.current = /* @__PURE__ */ new Set());
  var emit = function(value) {
    listeners2.current.forEach(function(l) {
      return l(value);
    });
  }, subscribe2 = React__namespace.useCallback(function(listener) {
    return listeners2.current.add(listener), function() {
      listeners2.current.delete(listener);
    };
  }, []);
  return [emit, subscribe2];
}
function SelectInner(props) {
  var {
    scope = "",
    adaptScope,
    native,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    value: valueProp,
    defaultValue: defaultValue2,
    onValueChange,
    disablePreventBodyScroll,
    size: sizeProp = "$true",
    onActiveChange,
    dir,
    id: id2
  } = props;
  useAdaptIsActive(adaptScope);
  var SelectImpl = SelectSheetImpl, forceUpdate = React__namespace.useReducer(function() {
    return {};
  }, {})[1], [selectedItem, setSelectedItem] = React__namespace.useState(null), [open2, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen || false,
    onChange: onOpenChange
  }), [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue2 || "",
    onChange: onValueChange,
    transition: true
  });
  React__namespace.useEffect(function() {
    open2 && emitValue(value);
  }, [open2]), React__namespace.useEffect(function() {
    emitValue(value);
  }, [value]), React__namespace.useEffect(function() {
    if (props.id) return registerFocusable(props.id, {
      focusAndSelect: function() {
        setOpen == null ? void 0 : setOpen(function(value2) {
          return !value2;
        });
      },
      focus: function() {
      }
    });
  }, [props.id]);
  var [activeIndex, setActiveIndex] = React__namespace.useState(0), [emitValue, valueSubscribe] = useEmitter(), [emitActiveIndex, activeIndexSubscribe] = useEmitter(), selectedIndexRef = React__namespace.useRef(null), activeIndexRef = React__namespace.useRef(null), listContentRef = React__namespace.useRef([]), [selectedIndex, setSelectedIndex] = React__namespace.useState(0), [valueNode, setValueNode] = React__namespace.useState(null);
  useIsomorphicLayoutEffect(function() {
    selectedIndexRef.current = selectedIndex, activeIndexRef.current = activeIndex;
  });
  var shouldRenderWebNative = isWeb, setActiveIndexDebounced = useDebounce(function(index2) {
    setActiveIndex(function(prev) {
      return prev !== index2 ? (typeof index2 == "number" && emitActiveIndex(index2), index2) : prev;
    });
  }, 1, {}, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItemParentProvider, {
    scopeName: scope,
    scope,
    adaptScope,
    initialValue: React__namespace.useMemo(function() {
      return value;
    }, [open2]),
    size: sizeProp,
    activeIndexSubscribe,
    valueSubscribe,
    setOpen,
    id: id2,
    onChange: React__namespace.useCallback(function(val) {
      setValue(val), emitValue(val);
    }, []),
    onActiveChange: useEvent(function(value2, index2) {
      onActiveChange == null ? void 0 : onActiveChange(value2, index2);
    }),
    setSelectedIndex,
    setValueAtIndex: React__namespace.useCallback(function(index2, value2) {
      listContentRef.current[index2] = value2;
    }, []),
    shouldRenderWebNative,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectProvider, {
      scope,
      scopeName: scope,
      adaptScope,
      disablePreventBodyScroll,
      dir,
      blockSelection: false,
      fallback: false,
      selectedItem,
      setSelectedItem,
      forceUpdate,
      valueNode,
      onValueNodeChange: setValueNode,
      activeIndex,
      selectedIndex,
      setActiveIndex: setActiveIndexDebounced,
      value,
      open: open2,
      native,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectSheetController, {
        onOpenChange: setOpen,
        scope,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectImpl, __spreadProps(__spreadValues({
          activeIndexRef,
          listContentRef,
          selectedIndexRef
        }, props), {
          open: open2,
          value,
          children
        }))
      })
    })
  });
}
var SLIDER_NAME = "Slider", SliderContext = createStyledContext({
  size: "$true",
  min: 0,
  max: 100,
  orientation: "horizontal"
}), {
  Provider: SliderProvider,
  useStyledContext: useSliderContext
} = SliderContext, {
  Provider: SliderOrientationProvider,
  useStyledContext: useSliderOrientationContext
} = createStyledContext({
  startEdge: "left",
  endEdge: "right",
  sizeProp: "width",
  size: 0,
  direction: 1
}), PAGE_KEYS = ["PageUp", "PageDown"], ARROW_KEYS = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], BACK_KEYS = {
  ltr: ["ArrowDown", "Home", "ArrowLeft", "PageDown"],
  rtl: ["ArrowDown", "Home", "ArrowRight", "PageDown"]
};
function getNextSortedValues() {
  var prevValues = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], nextValue = arguments.length > 1 ? arguments[1] : void 0, atIndex = arguments.length > 2 ? arguments[2] : void 0, nextValues = [...prevValues];
  return nextValues[atIndex] = nextValue, nextValues.sort(function(a, b2) {
    return a - b2;
  });
}
function convertValueToPercentage(value, min2, max2) {
  var maxSteps = max2 - min2, percentPerStep = 100 / maxSteps;
  return percentPerStep * (value - min2);
}
function getLabel(index2, totalValues) {
  if (totalValues > 2) return `Value ${index2 + 1} of ${totalValues}`;
  if (totalValues === 2) return ["Minimum", "Maximum"][index2];
}
function getClosestValueIndex(values, nextValue) {
  if (values.length === 1) return 0;
  var distances = values.map(function(value) {
    return Math.abs(value - nextValue);
  }), closestDistance = Math.min(...distances);
  return distances.indexOf(closestDistance);
}
function getThumbInBoundsOffset(width, left, direction) {
  var quarterWidth = width / 4, halfPercent = 50, offset2 = linearScale([0, halfPercent], [0, quarterWidth]);
  return (quarterWidth - offset2(left) * direction) * direction;
}
function getStepsBetweenValues(values) {
  return values.slice(0, -1).map(function(value, index2) {
    return values[index2 + 1] - value;
  });
}
function hasMinStepsBetweenValues(values, minStepsBetweenValues) {
  if (minStepsBetweenValues > 0) {
    var stepsBetweenValues = getStepsBetweenValues(values), actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);
    return actualMinStepsBetweenValues >= minStepsBetweenValues;
  }
  return true;
}
function linearScale(input, output) {
  return function(value) {
    if (input[0] === input[1] || output[0] === output[1]) return output[0];
    var ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function getDecimalCount(value) {
  return (String(value).split(".")[1] || "").length;
}
function roundValue(value, decimalCount) {
  var rounder = Math.pow(10, decimalCount);
  return Math.round(value * rounder) / rounder;
}
var SliderFrame = styled(YStack, {
  position: "relative",
  variants: {
    orientation: {
      horizontal: {},
      vertical: {}
    },
    size: function(val, extras) {
      if (val) {
        var orientation = extras.props.orientation, size = Math.round(getVariableValue(getSize(val)) / 6);
        return orientation === "horizontal" ? {
          height: size,
          borderRadius: size,
          justifyContent: "center"
        } : {
          width: size,
          borderRadius: size,
          alignItems: "center"
        };
      }
    }
  }
}), SliderImpl = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    __scopeSlider,
    onSlideStart,
    onSlideMove,
    onSlideEnd,
    onHomeKeyDown,
    onEndKeyDown,
    onStepKeyDown
  } = _a, sliderProps = __objRest(_a, [
    "__scopeSlider",
    "onSlideStart",
    "onSlideMove",
    "onSlideEnd",
    "onHomeKeyDown",
    "onEndKeyDown",
    "onStepKeyDown"
  ]), context2 = useSliderContext(__scopeSlider);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SliderFrame, __spreadProps(__spreadValues(__spreadProps(__spreadValues({
    size: "$4"
  }, sliderProps), {
    "data-orientation": sliderProps.orientation,
    ref: forwardedRef
  }), isWeb), {
    onMoveShouldSetResponderCapture: function() {
      return true;
    },
    onScrollShouldSetResponder: function() {
      return true;
    },
    onScrollShouldSetResponderCapture: function() {
      return true;
    },
    onMoveShouldSetResponder: function() {
      return true;
    },
    onStartShouldSetResponder: function() {
      return true;
    },
    // onStartShouldSetResponderCapture={() => true}
    onResponderTerminationRequest: function() {
      return false;
    },
    onResponderGrant: composeEventHandlers(props.onResponderGrant, function(event) {
      var target = event.target, thumbIndex = context2.thumbs.get(target), isStartingOnThumb = thumbIndex !== void 0;
      isStartingOnThumb && (context2.valueIndexToChangeRef.current = thumbIndex), onSlideStart(event, isStartingOnThumb ? "thumb" : "track");
    }),
    onResponderMove: composeEventHandlers(props.onResponderMove, function(event) {
      event.stopPropagation(), onSlideMove(event);
    }),
    onResponderRelease: composeEventHandlers(props.onResponderRelease, function(event) {
      onSlideEnd(event);
    })
  }));
});
var SliderHorizontal = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    min: min2,
    max: max2,
    dir,
    onSlideStart,
    onSlideMove,
    onStepKeyDown,
    onSlideEnd
  } = _a, sliderProps = __objRest(_a, [
    "min",
    "max",
    "dir",
    "onSlideStart",
    "onSlideMove",
    "onStepKeyDown",
    "onSlideEnd"
  ]), direction = useDirection(dir), isDirectionLTR = direction === "ltr", sliderRef = React__namespace.useRef(null), [state, setState_] = React__namespace.useState(function() {
    return {
      size: 0,
      offset: 0
    };
  }), setState = useCreateShallowSetState(setState_);
  function getValueFromPointer(pointerPosition) {
    var input = [0, state.size], output = isDirectionLTR ? [min2, max2] : [max2, min2], value = linearScale(input, output);
    return value(pointerPosition);
  }
  var measure2 = function() {
    var _sliderRef_current;
    (_sliderRef_current = sliderRef.current) === null || _sliderRef_current === void 0 || _sliderRef_current.measure(function(_x, _y, width, _height, pageX, _pageY) {
      setState({
        size: width,
        offset: pageX
      });
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SliderOrientationProvider, {
    scope: props.__scopeSlider,
    startEdge: isDirectionLTR ? "left" : "right",
    endEdge: isDirectionLTR ? "right" : "left",
    direction: isDirectionLTR ? 1 : -1,
    sizeProp: "width",
    size: state.size,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(SliderImpl, __spreadProps(__spreadValues({
      ref: composeRefs(forwardedRef, sliderRef),
      dir: direction
    }, sliderProps), {
      orientation: "horizontal",
      onLayout: measure2,
      onSlideStart: function(event, target) {
        var value = getValueFromPointer(event.nativeEvent.locationX);
        value && (onSlideStart == null ? void 0 : onSlideStart(value, target, event));
      },
      onSlideMove: function(event) {
        var value = getValueFromPointer(event.nativeEvent.pageX - state.offset);
        value && (onSlideMove == null ? void 0 : onSlideMove(value, event));
      },
      onSlideEnd: function(event) {
        var value = getValueFromPointer(event.nativeEvent.pageX - state.offset);
        value && (onSlideEnd == null ? void 0 : onSlideEnd(event, value));
      },
      onStepKeyDown: function(event) {
        var isBackKey = BACK_KEYS[direction].includes(event.key);
        onStepKeyDown == null ? void 0 : onStepKeyDown({
          event,
          direction: isBackKey ? -1 : 1
        });
      }
    }))
  });
});
var SliderVertical = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    min: min2,
    max: max2,
    onSlideStart,
    onSlideMove,
    onStepKeyDown,
    onSlideEnd
  } = _a, sliderProps = __objRest(_a, [
    "min",
    "max",
    "onSlideStart",
    "onSlideMove",
    "onStepKeyDown",
    "onSlideEnd"
  ]), [state, setState_] = React__namespace.useState(function() {
    return {
      size: 0,
      offset: 0
    };
  }), setState = useCreateShallowSetState(setState_), sliderRef = React__namespace.useRef(null);
  function getValueFromPointer(pointerPosition) {
    var input = [0, state.size], output = [max2, min2], value = linearScale(input, output);
    return value(pointerPosition);
  }
  var measure2 = function() {
    var _sliderRef_current;
    (_sliderRef_current = sliderRef.current) === null || _sliderRef_current === void 0 || _sliderRef_current.measure(function(_x, _y, _width, height, _pageX, pageY) {
      setState({
        size: height,
        offset: pageY
      });
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SliderOrientationProvider, {
    scope: props.__scopeSlider,
    startEdge: "bottom",
    endEdge: "top",
    sizeProp: "height",
    size: state.size,
    direction: 1,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(SliderImpl, __spreadProps(__spreadValues({
      ref: composeRefs(forwardedRef, sliderRef)
    }, sliderProps), {
      orientation: "vertical",
      onLayout: measure2,
      onSlideStart: function(event, target) {
        var value = getValueFromPointer(event.nativeEvent.locationY);
        value && (onSlideStart == null ? void 0 : onSlideStart(value, target, event));
      },
      onSlideMove: function(event) {
        var value = getValueFromPointer(event.nativeEvent.pageY - state.offset);
        value && (onSlideMove == null ? void 0 : onSlideMove(value, event));
      },
      onSlideEnd: function(event) {
        var value = getValueFromPointer(event.nativeEvent.pageY - state.offset);
        onSlideEnd == null ? void 0 : onSlideEnd(event, value);
      },
      onStepKeyDown: function(event) {
        var isBackKey = BACK_KEYS.ltr.includes(event.key);
        onStepKeyDown == null ? void 0 : onStepKeyDown({
          event,
          direction: isBackKey ? -1 : 1
        });
      }
    }))
  });
}), TRACK_NAME = "SliderTrack", SliderTrackFrame = styled(SliderFrame, {
  name: "SliderTrack",
  variants: {
    unstyled: {
      false: {
        height: "100%",
        width: "100%",
        backgroundColor: "$background",
        position: "relative",
        borderRadius: 1e5,
        overflow: "hidden"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), SliderTrack = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    __scopeSlider
  } = _a, trackProps = __objRest(_a, [
    "__scopeSlider"
  ]), context2 = useSliderContext(__scopeSlider);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SliderTrackFrame, __spreadProps(__spreadValues({
    "data-disabled": context2.disabled ? "" : void 0,
    "data-orientation": context2.orientation,
    orientation: context2.orientation,
    size: context2.size
  }, trackProps), {
    ref: forwardedRef
  }));
});
SliderTrack.displayName = TRACK_NAME;
var RANGE_NAME = "SliderTrackActive", SliderTrackActiveFrame = styled(SliderFrame, {
  name: "SliderTrackActive",
  backgroundColor: "$background",
  position: "absolute",
  pointerEvents: "box-none"
}), SliderTrackActive = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    __scopeSlider
  } = _a, rangeProps = __objRest(_a, [
    "__scopeSlider"
  ]), context2 = useSliderContext(__scopeSlider), orientation = useSliderOrientationContext(__scopeSlider), ref = React__namespace.useRef(null), composedRefs = useComposedRefs(forwardedRef, ref), valuesCount = context2.values.length, percentages = context2.values.map(function(value) {
    return convertValueToPercentage(value, context2.min, context2.max);
  }), offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0, offsetEnd = 100 - Math.max(...percentages);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SliderTrackActiveFrame, __spreadValues(__spreadProps(__spreadValues({
    orientation: context2.orientation,
    "data-orientation": context2.orientation,
    "data-disabled": context2.disabled ? "" : void 0,
    size: context2.size,
    animateOnly: ["left", "top", "right", "bottom"]
  }, rangeProps), {
    ref: composedRefs,
    [orientation.startEdge]: `${offsetStart}%`,
    [orientation.endEdge]: `${offsetEnd}%`
  }), orientation.sizeProp === "width" ? {
    height: "100%"
  } : {
    left: 0,
    right: 0
  }));
});
SliderTrackActive.displayName = RANGE_NAME;
var getThumbSize = function(val) {
  var tokens = getTokens(), size = typeof val == "number" ? val : getSize(tokens.size[val], {
    shift: -1
  });
  return {
    width: size,
    height: size,
    minWidth: size,
    minHeight: size
  };
}, SliderThumbFrame = styled(ThemeableStack, {
  name: "SliderThumb",
  variants: {
    size: {
      "...size": getThumbSize
    },
    unstyled: {
      false: {
        position: "absolute",
        bordered: 2,
        borderWidth: 2,
        backgrounded: true,
        pressTheme: isWeb,
        focusTheme: isWeb,
        hoverTheme: isWeb
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), SliderThumb = SliderThumbFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    __scopeSlider,
    index: index2,
    circular: circular2,
    size: sizeProp
  } = _a, thumbProps = __objRest(_a, [
    "__scopeSlider",
    "index",
    "circular",
    "size"
  ]), context2 = useSliderContext(__scopeSlider), orientation = useSliderOrientationContext(__scopeSlider), [thumb, setThumb] = React__namespace.useState(null), composedRefs = useComposedRefs(forwardedRef, setThumb), value = context2.values[index2], percent = value === void 0 ? 0 : convertValueToPercentage(value, context2.min, context2.max), label = getLabel(index2, context2.values.length), _ref, sizeIn = (_ref = sizeProp != null ? sizeProp : context2.size) !== null && _ref !== void 0 ? _ref : "$true", [size, setSize] = React__namespace.useState(function() {
    var estimatedSize = getVariableValue(getThumbSize(sizeIn).width);
    return estimatedSize;
  }), thumbInBoundsOffset = size ? getThumbInBoundsOffset(size, percent, orientation.direction) : 0;
  React__namespace.useEffect(function() {
    if (thumb) return context2.thumbs.set(thumb, index2), function() {
      context2.thumbs.delete(thumb);
    };
  }, [thumb, context2.thumbs, index2]);
  var positionalStyles = context2.orientation === "horizontal" ? __spreadValues({
    x: thumbInBoundsOffset - size / 2,
    y: -size / 2,
    top: "50%"
  }, size === 0 && {
    top: "auto",
    bottom: "auto"
  }) : __spreadValues({
    x: -size / 2,
    y: size / 2,
    left: "50%"
  }, size === 0 && {
    left: "auto",
    right: "auto"
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SliderThumbFrame, __spreadProps(__spreadValues(__spreadProps(__spreadValues({
    ref: composedRefs,
    role: "slider",
    "aria-label": props["aria-label"] || label,
    "aria-valuemin": context2.min,
    "aria-valuenow": value,
    "aria-valuemax": context2.max,
    "aria-orientation": context2.orientation,
    "data-orientation": context2.orientation,
    "data-disabled": context2.disabled ? "" : void 0,
    tabIndex: context2.disabled ? void 0 : 0,
    animateOnly: ["transform", "left", "top", "right", "bottom"]
  }, positionalStyles), {
    [orientation.startEdge]: `${percent}%`,
    size: sizeIn,
    circular: circular2
  }), thumbProps), {
    onLayout: function(e2) {
      setSize(e2.nativeEvent.layout[orientation.sizeProp]);
    },
    /**
     * There will be no value on initial render while we work out the index so we hide thumbs
     * without a value, otherwise SSR will render them in the wrong position before they
     * snap into the correct position during hydration which would be visually jarring for
     * slower connections.
     */
    // style={value === undefined ? { display: 'none' } : props.style}
    onFocus: composeEventHandlers(props.onFocus, function() {
      context2.valueIndexToChangeRef.current = index2;
    })
  }));
}, {
  staticConfig: {
    memo: true
  }
}), SliderComponent = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    name,
    min: min2 = 0,
    max: max2 = 100,
    step = 1,
    orientation = "horizontal",
    disabled = false,
    minStepsBetweenThumbs = 0,
    defaultValue: defaultValue2 = [min2],
    value,
    onValueChange = function() {
    },
    size: sizeProp,
    onSlideEnd,
    onSlideMove,
    onSlideStart
  } = _a, sliderProps = __objRest(_a, [
    "name",
    "min",
    "max",
    "step",
    "orientation",
    "disabled",
    "minStepsBetweenThumbs",
    "defaultValue",
    "value",
    "onValueChange",
    "size",
    "onSlideEnd",
    "onSlideMove",
    "onSlideStart"
  ]), sliderRef = React__namespace.useRef(null), composedRefs = useComposedRefs(sliderRef, forwardedRef), thumbRefs = React__namespace.useRef(/* @__PURE__ */ new Map()), valueIndexToChangeRef = React__namespace.useRef(0), isHorizontal = orientation === "horizontal", [values = [], setValues] = useControllableState({
    prop: value,
    defaultProp: defaultValue2,
    transition: true,
    onChange: function(value2) {
      updateThumbFocus(valueIndexToChangeRef.current), onValueChange(value2);
    }
  });
  function updateThumbFocus(focusIndex) {
  }
  function handleSlideMove(value2, event) {
    updateValues(value2, valueIndexToChangeRef.current), onSlideMove == null ? void 0 : onSlideMove(event, value2);
  }
  function updateValues(value2, atIndex) {
    var decimalCount = getDecimalCount(step), snapToStep = roundValue(Math.round((value2 - min2) / step) * step + min2, decimalCount), nextValue = clamp$1(snapToStep, [min2, max2]);
    setValues(function() {
      var prevValues = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], nextValues = getNextSortedValues(prevValues, nextValue, atIndex);
      return hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step) ? (valueIndexToChangeRef.current = nextValues.indexOf(nextValue), String(nextValues) === String(prevValues) ? prevValues : nextValues) : prevValues;
    });
  }
  var SliderOriented = isHorizontal ? SliderHorizontal : SliderVertical;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SliderProvider, {
    scope: props.__scopeSlider,
    disabled,
    min: min2,
    max: max2,
    valueIndexToChangeRef,
    thumbs: thumbRefs.current,
    values,
    orientation,
    size: sizeProp,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(SliderOriented, __spreadProps(__spreadValues({
      "aria-disabled": disabled,
      "data-disabled": disabled ? "" : void 0
    }, sliderProps), {
      ref: composedRefs,
      min: min2,
      max: max2,
      onSlideEnd,
      onSlideStart: disabled ? void 0 : function(value2, target, event) {
        if (target !== "thumb") {
          var closestIndex = getClosestValueIndex(values, value2);
          updateValues(value2, closestIndex);
        }
        onSlideStart == null ? void 0 : onSlideStart(event, value2, target);
      },
      onSlideMove: disabled ? void 0 : handleSlideMove,
      onHomeKeyDown: function() {
        return !disabled && updateValues(min2, 0);
      },
      onEndKeyDown: function() {
        return !disabled && updateValues(max2, values.length - 1);
      },
      onStepKeyDown: function(param) {
        var {
          event,
          direction: stepDirection
        } = param;
        if (!disabled) {
          var isPageKey = PAGE_KEYS.includes(event.key), isSkipKey = isPageKey || event.shiftKey && ARROW_KEYS.includes(event.key), multiplier = isSkipKey ? 10 : 1, atIndex = valueIndexToChangeRef.current, value2 = values[atIndex], stepInDirection = step * multiplier * stepDirection;
          updateValues(value2 + stepInDirection, atIndex);
        }
      }
    }))
  });
}), Slider = withStaticProperties(SliderComponent, {
  Track: SliderTrack,
  TrackActive: SliderTrackActive,
  Thumb: SliderThumb
});
Slider.displayName = SLIDER_NAME;
var Track = SliderTrack, Range = SliderTrackActive, Thumb = SliderThumb;
function useSwitch(props, param, ref) {
  var [checked, setChecked] = param;
  return {
    switchProps: {
      onPress() {
        setChecked(function(prevChecked) {
          return !prevChecked;
        });
      }
    },
    switchRef: ref,
    bubbleInput: null
  };
}
var SwitchStyledContext = createStyledContext({
  size: void 0,
  unstyled: process.env.TAMAGUI_HEADLESS === "1"
});
var SwitchThumb = styled(ThemeableStack, {
  name: "SwitchThumb",
  variants: {
    unstyled: {
      false: {
        size: "$true",
        backgroundColor: "$background",
        borderRadius: 1e3
      }
    },
    checked: {
      true: {}
    },
    size: {
      "...size": function(val) {
        var size = getSwitchHeight(val);
        return {
          height: size,
          width: size
        };
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), getSwitchHeight = function(val) {
  return Math.round(getVariableValue(getSize(val)) * 0.65);
}, getSwitchWidth = function(val) {
  return getSwitchHeight(val) * 2;
}, SwitchFrame = styled(YStack, {
  name: "Switch",
  tag: "button",
  tabIndex: 0,
  variants: {
    unstyled: {
      false: {
        borderRadius: 1e3,
        backgroundColor: "$background",
        borderWidth: 2,
        borderColor: "$background",
        focusVisibleStyle: {
          outlineColor: "$outlineColor",
          outlineStyle: "solid",
          outlineWidth: 2
        }
      }
    },
    checked: {
      true: {}
    },
    size: {
      "...size": function(val) {
        var height = getSwitchHeight(val) + 4, width = getSwitchWidth(val) + 4;
        return {
          height,
          minHeight: height,
          width
        };
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
});
var SwitchContext = /* @__PURE__ */ React__namespace.createContext({
  checked: false,
  disabled: false,
  frameWidth: 0
});
function createSwitch(createProps) {
  var {
    disableActiveTheme,
    Frame: Frame2 = SwitchFrame,
    Thumb: Thumb2 = SwitchThumb
  } = createProps;
  Frame2.staticConfig.context = SwitchStyledContext, Thumb2.staticConfig.context = SwitchStyledContext;
  var SwitchThumbComponent = Thumb2.styleable(function(props, forwardedRef) {
    var _a = props, {
      size: sizeProp,
      unstyled: unstyledProp,
      nativeID
    } = _a, thumbProps = __objRest(_a, [
      "size",
      "unstyled",
      "nativeID"
    ]), context2 = React__namespace.useContext(SwitchContext), {
      checked,
      disabled,
      frameWidth
    } = context2, styledContext = SwitchStyledContext.useStyledContext(), {
      unstyled: unstyledContext,
      size: sizeContext
    } = styledContext, _ref, unstyled = process.env.TAMAGUI_HEADLESS === "1" ? true : (_ref = unstyledProp != null ? unstyledProp : unstyledContext) !== null && _ref !== void 0 ? _ref : false, _ref1, size = (_ref1 = sizeProp != null ? sizeProp : sizeContext) !== null && _ref1 !== void 0 ? _ref1 : "$true", initialChecked = React__namespace.useRef(checked).current, initialWidth = getVariableValue(props.width, "size"), [thumbWidth, setThumbWidth] = React__namespace.useState(typeof initialWidth == "number" ? initialWidth : 0), distance = frameWidth - thumbWidth, x = initialChecked ? checked ? 0 : -distance : checked ? distance : 0;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Thumb2, __spreadValues(__spreadProps(__spreadValues({
      ref: forwardedRef,
      unstyled
    }, unstyled === false && __spreadValues({
      size
    }, !disableActiveTheme && !unstyled && {
      theme: checked ? "active" : null
    })), {
      alignSelf: initialChecked ? "flex-end" : "flex-start",
      x,
      onLayout: composeEventHandlers(props.onLayout, function(e2) {
        var next = e2.nativeEvent.layout.width;
        next !== thumbWidth && setThumbWidth(next);
      }),
      // expected variants
      checked,
      disabled
    }), thumbProps));
  }), SwitchComponent = Frame2.styleable(function(_props, forwardedRef) {
    var _a = _props, {
      native,
      nativeProps,
      checked: checkedProp,
      defaultChecked,
      onCheckedChange
    } = _a, props = __objRest(_a, [
      "native",
      "nativeProps",
      "checked",
      "defaultChecked",
      "onCheckedChange"
    ]), [checked, setChecked] = useControllableState({
      prop: checkedProp,
      defaultProp: defaultChecked || false,
      onChange: onCheckedChange,
      transition: true
    }), styledContext = React__namespace.useContext(SwitchStyledContext.context), estimatedInitialWidth = 0, estWidth = getVariableValue(getShorthandValue(props, "width"), "size");
    if (estWidth) {
      var _getShorthandValue, _ref, estPad = (_ref = (_getShorthandValue = getShorthandValue(props, "paddingHorizontal")) !== null && _getShorthandValue !== void 0 ? _getShorthandValue : getShorthandValue(props, "padding")) !== null && _ref !== void 0 ? _ref : 0, _getShorthandValue1, _ref1, estLeftPad = (_ref1 = (_getShorthandValue1 = getShorthandValue(props, "paddingLeft")) !== null && _getShorthandValue1 !== void 0 ? _getShorthandValue1 : estPad) !== null && _ref1 !== void 0 ? _ref1 : 0, _getShorthandValue2, _ref2, estRightPad = (_ref2 = (_getShorthandValue2 = getShorthandValue(props, "paddingRight")) !== null && _getShorthandValue2 !== void 0 ? _getShorthandValue2 : estPad) !== null && _ref2 !== void 0 ? _ref2 : 0;
      estimatedInitialWidth = estWidth - (estLeftPad ? getVariableValue(estLeftPad, "size") : 0) - (estRightPad ? getVariableValue(estRightPad, "size") : 0);
    }
    var [frameWidth, setFrameInnerWidth] = React__namespace.useState(estimatedInitialWidth), {
      switchProps,
      bubbleInput,
      switchRef
    } = useSwitch(
      // @ts-ignore
      props,
      [checked, setChecked],
      // @ts-ignore TODO tamagui react 19 type error
      forwardedRef
    );
    React__namespace.useEffect(function() {
      if (props.id && !props.disabled) return registerFocusable(props.id, {
        focusAndSelect: function() {
          setChecked == null ? void 0 : setChecked(function(value2) {
            return !value2;
          });
        },
        focus: function() {
        }
      });
    }, [props.id, props.disabled]);
    var renderNative = shouldRenderNativePlatform(native);
    if (renderNative === "android" || renderNative === "ios") return /* @__PURE__ */ jsxRuntimeExports.jsx(UnimplementedView, __spreadValues({
      value: checked,
      onValueChange: setChecked
    }, nativeProps));
    var disabled = props.disabled, value = React__namespace.useMemo(function() {
      return {
        checked,
        disabled,
        frameWidth
      };
    }, [checked, disabled, frameWidth]), handleLayout = function(e2) {
      var next = e2.nativeEvent.layout.width;
      next !== frameWidth && setFrameInnerWidth(next);
    }, _styledContext_unstyled, _ref3, unstyled = (_ref3 = (_styledContext_unstyled = styledContext.unstyled) !== null && _styledContext_unstyled !== void 0 ? _styledContext_unstyled : props.unstyled) !== null && _ref3 !== void 0 ? _ref3 : false, _styledContext_size, _ref4;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(SwitchContext.Provider, {
      value,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Frame2, __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadProps(__spreadValues(__spreadValues({
        ref: switchRef,
        tag: "button"
      }, isWeb), !unstyled && {
        size: (_ref4 = (_styledContext_size = styledContext.size) !== null && _styledContext_size !== void 0 ? _styledContext_size : props.size) !== null && _ref4 !== void 0 ? _ref4 : "$true"
      }), {
        unstyled
      }), props), switchProps), !disableActiveTheme && !props.unstyled && {
        theme: checked ? "active" : null
      }), {
        // expected variants
        checked,
        disabled,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(View$1, {
          style: measureContainerStyle,
          onLayout: handleLayout,
          children: frameWidth ? props.children : null
        })
      })), bubbleInput]
    });
  }, {
    disableTheme: true
  });
  return withStaticProperties(SwitchComponent, {
    Thumb: SwitchThumbComponent
  });
}
var measureContainerStyle = {
  alignSelf: "stretch",
  flex: 1
};
var Switch = createSwitch({
  Frame: SwitchFrame,
  Thumb: SwitchThumb
});
var TABS_NAME = "Tabs", DefaultTabsFrame = styled(SizableStack, {
  name: TABS_NAME
}), TRIGGER_NAME = "TabsTrigger", DefaultTabsTabFrame = styled(ThemeableStack, {
  name: TRIGGER_NAME,
  tag: "button",
  variants: {
    size: {
      "...size": getButtonSized
    },
    disabled: {
      true: {
        pointerEvents: "none"
      }
    },
    active: {
      true: {
        hoverStyle: {
          backgroundColor: "$background"
        },
        focusStyle: {
          backgroundColor: "$background"
        }
      }
    },
    unstyled: {
      false: {
        borderWidth: 0,
        backgroundColor: "$background",
        userSelect: "none",
        justifyContent: "center",
        alignItems: "center",
        flexWrap: "nowrap",
        flexDirection: "row",
        cursor: "pointer",
        pressStyle: {
          backgroundColor: "$backgroundPress"
        },
        hoverStyle: {
          backgroundColor: "$backgroundHover"
        },
        focusStyle: {
          backgroundColor: "$backgroundFocus"
        }
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), CONTENT_NAME = "TabsContent", DefaultTabsContentFrame = styled(ThemeableStack, {
  name: CONTENT_NAME
});
var {
  Provider: TabsProvider,
  useStyledContext: useTabsContext
} = createStyledContext();
function createTabs(createProps) {
  var {
    ContentFrame = DefaultTabsContentFrame,
    TabFrame = DefaultTabsTabFrame,
    TabsFrame = DefaultTabsFrame
  } = createProps, TABS_CONTEXT = "TabsContext", TAB_LIST_NAME = "TabsList", TabsList = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
    var _a = props, {
      __scopeTabs,
      loop = true,
      children
    } = _a, listProps = __objRest(_a, [
      "__scopeTabs",
      "loop",
      "children"
    ]), context2 = useTabsContext(__scopeTabs);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(RovingFocusGroup, {
      __scopeRovingFocusGroup: __scopeTabs || TABS_CONTEXT,
      orientation: context2.orientation,
      dir: context2.dir,
      loop,
      asChild: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Group, __spreadProps(__spreadValues({
        role: "tablist",
        componentName: TAB_LIST_NAME,
        "aria-orientation": context2.orientation,
        ref: forwardedRef,
        orientation: context2.orientation
      }, listProps), {
        children
      }))
    });
  });
  TabsList.displayName = TAB_LIST_NAME;
  var TRIGGER_NAME2 = "TabsTrigger", TabsTrigger = TabFrame.styleable(function(props, forwardedRef) {
    var _a = props, {
      __scopeTabs,
      value,
      disabled = false,
      onInteraction,
      disableActiveTheme
    } = _a, triggerProps = __objRest(_a, [
      "__scopeTabs",
      "value",
      "disabled",
      "onInteraction",
      "disableActiveTheme"
    ]), context2 = useTabsContext(__scopeTabs), triggerId = makeTriggerId(context2.baseId, value), contentId = makeContentId(context2.baseId, value), isSelected = value === context2.value, [layout, setLayout] = React__namespace.useState(null), triggerRef = React__namespace.useRef(null), groupItemProps = useGroupItem({
      disabled: !!disabled
    });
    React__namespace.useEffect(function() {
      return context2.registerTrigger(), function() {
        return context2.unregisterTrigger();
      };
    }, []), React__namespace.useEffect(function() {
      if (!triggerRef.current || !isWeb) return;
    }, [context2.triggersCount]), React__namespace.useEffect(function() {
      isSelected && layout && (onInteraction == null ? void 0 : onInteraction("select", layout));
    }, [isSelected, value, layout]);
    var _props_onPress;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Theme, {
      name: isSelected && !disableActiveTheme ? "active" : null,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(RovingFocusGroup.Item, {
        __scopeRovingFocusGroup: __scopeTabs || TABS_CONTEXT,
        asChild: true,
        focusable: !disabled,
        active: isSelected,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TabFrame, __spreadValues(__spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
          onLayout: function(event) {
            setLayout(event.nativeEvent.layout);
          },
          onHoverIn: composeEventHandlers(props.onHoverIn, function() {
            layout && (onInteraction == null ? void 0 : onInteraction("hover", layout));
          }),
          onHoverOut: composeEventHandlers(props.onHoverOut, function() {
            onInteraction == null ? void 0 : onInteraction("hover", null);
          }),
          role: "tab",
          "aria-selected": isSelected,
          "aria-controls": contentId,
          "data-state": isSelected ? "active" : "inactive",
          "data-disabled": disabled ? "" : void 0,
          disabled,
          id: triggerId
        }, !props.unstyled && {
          size: context2.size
        }), isSelected && {
          forceStyle: "focus"
        }), groupItemProps), triggerProps), {
          ref: composeRefs(forwardedRef, triggerRef),
          onPress: composeEventHandlers((_props_onPress = props.onPress) !== null && _props_onPress !== void 0 ? _props_onPress : void 0, function(event) {
            var webChecks = !isWeb;
            !disabled && !isSelected && webChecks ? context2.onChange(value) : event.preventDefault();
          })
        }), isWeb))
      })
    });
  });
  TabsTrigger.displayName = TRIGGER_NAME2;
  var TabsContent = ContentFrame.styleable(function(props, forwardedRef) {
    var _a = props, {
      __scopeTabs,
      value,
      forceMount,
      children
    } = _a, contentProps = __objRest(_a, [
      "__scopeTabs",
      "value",
      "forceMount",
      "children"
    ]), context2 = useTabsContext(__scopeTabs), isSelected = value === context2.value, show = forceMount || isSelected, triggerId = makeTriggerId(context2.baseId, value), contentId = makeContentId(context2.baseId, value);
    return show ? /* @__PURE__ */ jsxRuntimeExports.jsx(ContentFrame, __spreadProps(__spreadValues({
      "data-state": isSelected ? "active" : "inactive",
      "data-orientation": context2.orientation,
      role: "tabpanel",
      "aria-labelledby": triggerId,
      // @ts-ignore
      hidden: !show,
      id: contentId,
      tabIndex: 0
    }, contentProps), {
      ref: forwardedRef,
      children
    }), value) : null;
  }), TabsComponent = TabsFrame.styleable(function(props, forwardedRef) {
    var _a = props, {
      __scopeTabs,
      value: valueProp,
      onValueChange,
      defaultValue: defaultValue2,
      orientation = "horizontal",
      dir,
      activationMode = "automatic",
      size = "$true"
    } = _a, tabsProps = __objRest(_a, [
      "__scopeTabs",
      "value",
      "onValueChange",
      "defaultValue",
      "orientation",
      "dir",
      "activationMode",
      "size"
    ]), direction = useDirection(dir), [value, setValue] = useControllableState({
      prop: valueProp,
      onChange: onValueChange,
      defaultProp: defaultValue2 != null ? defaultValue2 : ""
    }), [triggersCount, setTriggersCount] = React__namespace.useState(0), registerTrigger = useEvent(function() {
      return setTriggersCount(function(v) {
        return v + 1;
      });
    }), unregisterTrigger = useEvent(function() {
      return setTriggersCount(function(v) {
        return v - 1;
      });
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TabsProvider, {
      scope: __scopeTabs,
      baseId: React__namespace.useId(),
      value,
      onChange: setValue,
      orientation,
      dir: direction,
      activationMode,
      size,
      registerTrigger,
      triggersCount,
      unregisterTrigger,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(TabsFrame, __spreadProps(__spreadValues({
        direction,
        //   dir={direction}
        "data-orientation": orientation
      }, tabsProps), {
        ref: forwardedRef
      }))
    });
  });
  return withStaticProperties(TabsComponent, {
    List: TabsList,
    /**
    * @deprecated Use Tabs.Tab instead
    */
    Trigger: TabsTrigger,
    Tab: TabsTrigger,
    Content: TabsContent
  });
}
function makeTriggerId(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function makeContentId(baseId, value) {
  return `${baseId}-content-${value}`;
}
var Tabs = createTabs({
  ContentFrame: DefaultTabsContentFrame,
  TabFrame: DefaultTabsTabFrame,
  TabsFrame: DefaultTabsFrame
});
function mutateThemes(param) {
  var _a = param, {
    themes: themes2,
    batch,
    insertCSS = true
  } = _a, props = __objRest(_a, [
    "themes",
    "batch",
    "insertCSS"
  ]), allThemesProxied = {}, allThemesRaw = {}, _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
  try {
    for (var _iterator = themes2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var {
        name,
        theme
      } = _step.value, res = _mutateTheme(__spreadProps(__spreadValues({}, props), {
        name,
        theme,
        // we'll do one update at the end
        avoidUpdate: true,
        // always add which also replaces but doesnt fail first time
        mutationType: "add"
      }));
      res && (allThemesProxied[name] = res.theme, allThemesRaw[name] = res.themeRaw);
    }
  } catch (err) {
    _didIteratorError = true, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError) throw _iteratorError;
    }
  }
  var cssRules = insertCSS ? insertThemeCSS() : [];
  return startTransition(function() {
    for (var themeName in allThemesProxied) {
      var theme2 = allThemesProxied[themeName];
      updateThemeConfig(themeName, theme2);
    }
    updateThemeStates();
  }), {
    themes: allThemesProxied,
    themesRaw: allThemesRaw,
    cssRules
  };
}
function _mutateTheme(props) {
  var config = getConfig(), {
    name: themeName,
    theme: themeIn,
    insertCSS,
    mutationType
  } = props;
  var _config_themes_themeName, theme1 = __spreadValues(__spreadValues({}, mutationType === "update" ? (_config_themes_themeName = config.themes[themeName]) !== null && _config_themes_themeName !== void 0 ? _config_themes_themeName : {} : {}), themeIn);
  for (var key in theme1) ensureThemeVariable(theme1, key);
  var themeProxied = proxyThemeToParents(themeName, theme1), response = {
    themeRaw: theme1,
    theme: themeProxied,
    cssRules: []
  };
  return props.avoidUpdate || (insertCSS && (response.cssRules = insertThemeCSS()), updateThemeConfig(themeName, themeProxied), updateThemeStates()), response;
}
function updateThemeConfig(themeName, theme) {
  var config = getConfig();
  config.themes[themeName] = theme, updateConfig("themes", config.themes);
}
function updateThemeStates() {
  forceUpdateThemes();
}
function insertThemeCSS(themes2) {
  return [];
}
function addTheme(props) {
  return _mutateTheme(__spreadProps(__spreadValues({}, props), {
    insertCSS: true,
    mutationType: "add"
  }));
}
function updateTheme(param) {
  var {
    name,
    theme
  } = param;
  return _mutateTheme({
    name,
    theme,
    insertCSS: true,
    mutationType: "update"
  });
}
function replaceTheme(param) {
  var {
    name,
    theme
  } = param, next = _mutateTheme({
    name,
    theme,
    insertCSS: true,
    mutationType: "replace"
  });
  return next;
}
var context = createStyledContext({
  color: ""
}), NAME = "Toggle", ToggleFrame = styled(ThemeableStack, {
  name: NAME,
  tag: "button",
  context,
  variants: {
    unstyled: {
      false: {
        pressTheme: true,
        backgroundColor: "$background",
        alignItems: "center",
        justifyContent: "center",
        display: "flex",
        borderColor: "$borderColor",
        borderWidth: 1,
        margin: -1,
        hoverStyle: {
          backgroundColor: "$backgroundHover"
        },
        pressStyle: {
          backgroundColor: "$backgroundPress"
        },
        focusStyle: {
          borderColor: "$borderColorFocus"
        },
        focusVisibleStyle: {
          outlineColor: "$outlineColor",
          outlineWidth: 2,
          outlineStyle: "solid"
        }
      }
    },
    color: {
      "...color": function() {
        return {};
      }
    },
    active: {
      true: {
        zIndex: 1,
        hoverStyle: {
          backgroundColor: "$background"
        },
        focusStyle: {
          borderColor: "$borderColor",
          backgroundColor: "$background"
        }
      }
    },
    orientation: {
      horizontal: {
        flexDirection: "row",
        spaceDirection: "horizontal"
      },
      vertical: {
        flexDirection: "column",
        spaceDirection: "vertical"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), Toggle = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    pressed: pressedProp,
    defaultPressed = false,
    onPressedChange
  } = _a, buttonProps = __objRest(_a, [
    "pressed",
    "defaultPressed",
    "onPressedChange"
  ]), [pressed = false, setPressed] = useControllableState({
    prop: pressedProp,
    onChange: onPressedChange,
    defaultProp: defaultPressed
  }), _props_onPress;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleFrame, __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, !props.unstyled && {
    theme: pressed ? "active" : null,
    themeShallow: true
  }), {
    active: props.unstyled ? void 0 : pressed,
    "aria-pressed": pressed,
    "data-state": pressed ? "on" : "off",
    "data-disabled": props.disabled ? "" : void 0
  }), buttonProps), {
    ref: forwardedRef,
    onPress: composeEventHandlers((_props_onPress = props.onPress) !== null && _props_onPress !== void 0 ? _props_onPress : void 0, function() {
      props.disabled || setPressed(!pressed);
    })
  }));
});
var TOGGLE_GROUP_NAME = "ToggleGroup", TOGGLE_GROUP_ITEM_NAME = "ToggleGroupItem", TOGGLE_GROUP_CONTEXT = "ToggleGroup", {
  Provider: ToggleGroupItemProvider,
  useStyledContext: useToggleGroupItemContext
} = createStyledContext(), {
  Provider: ToggleGroupContext,
  useStyledContext: useToggleGroupContext
} = createStyledContext(), ToggleGroupItem = ToggleFrame.extractable(/* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var [_, {
    color
  }] = usePropsAndStyle(props), _a = props, {
    disablePassStyles
  } = _a, rest = __objRest(_a, [
    "disablePassStyles"
  ]), valueContext = useToggleGroupValueContext(props.__scopeToggleGroup), context2 = useToggleGroupContext(props.__scopeToggleGroup), pressed = valueContext == null ? void 0 : valueContext.value.includes(props.value), disabled = context2.disabled || props.disabled || false, groupItemProps = useGroupItem({
    disabled
  }), _props_size, size = (_props_size = props.size) !== null && _props_size !== void 0 ? _props_size : context2.size, sizeProps = props.unstyled ? {} : {
    width: void 0,
    height: void 0,
    padding: getVariableValue(size) * 0.6
  }, iconSize = (typeof size == "number" ? size * 0.7 : getFontSize(size)) * 1.2, theme = useTheme(), getThemedIcon = useGetThemedIcon({
    size: iconSize,
    color: color != null ? color : theme.color
  }), childrens = React.Children.toArray(props.children), children = childrens.map(function(child) {
    return props.disablePassStyles || !/* @__PURE__ */ React.isValidElement(child) ? child : getThemedIcon(child);
  }), commonProps = __spreadProps(__spreadValues(__spreadValues({
    pressed,
    disabled
  }, sizeProps), rest), {
    children
  }), inner = /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupItemImpl, __spreadValues(__spreadProps(__spreadValues({}, commonProps), {
    ref: forwardedRef,
    // focusable={!disabled}
    tabIndex: disabled ? -1 : 0,
    disabled
  }), groupItemProps));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupItemProvider, {
    scope: props.__scopeToggleGroup,
    children: context2.rovingFocus ? /* @__PURE__ */ jsxRuntimeExports.jsx(RovingFocusGroup.Item, {
      asChild: "except-style",
      __scopeRovingFocusGroup: props.__scopeToggleGroup || TOGGLE_GROUP_CONTEXT,
      focusable: !disabled,
      active: pressed,
      children: inner
    }) : inner
  });
}));
ToggleGroupItem.displayName = TOGGLE_GROUP_ITEM_NAME;
var ToggleGroupItemImpl = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    __scopeToggleGroup,
    value
  } = _a, itemProps = __objRest(_a, [
    "__scopeToggleGroup",
    "value"
  ]), valueContext = useToggleGroupValueContext(__scopeToggleGroup), singleProps = {
    "aria-pressed": void 0
  }, typeProps = valueContext.type === "single" ? singleProps : void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Toggle, __spreadProps(__spreadValues(__spreadValues({}, typeProps), itemProps), {
    ref: forwardedRef,
    onPressedChange: function(pressed) {
      pressed ? valueContext.onItemActivate(value) : valueContext.onItemDeactivate(value);
    }
  }));
}), ToggleGroup = withStaticProperties(/* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    type
  } = _a, toggleGroupProps = __objRest(_a, [
    "type"
  ]);
  if (React.useEffect(function() {
    if (props.id) return registerFocusable(props.id, {
      // TODO: would be nice to focus on the first child later - could be done with reforest
      // for now leaving it empty
      focus: function() {
      }
    });
  }, [props.id]), type === "single") {
    var singleProps = toggleGroupProps;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupImplSingle, __spreadProps(__spreadValues({}, singleProps), {
      ref: forwardedRef
    }));
  }
  if (type === "multiple") {
    var multipleProps = toggleGroupProps;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupImplMultiple, __spreadProps(__spreadValues({}, multipleProps), {
      ref: forwardedRef
    }));
  }
  throw new Error(`Missing prop \`type\` expected on \`${TOGGLE_GROUP_NAME}\``);
}), {
  Item: ToggleGroupItem
});
ToggleGroup.displayName = TOGGLE_GROUP_NAME;
var {
  Provider: ToggleGroupValueProvider,
  useStyledContext: useToggleGroupValueContext
} = createStyledContext(), ToggleGroupImplSingle = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    value: valueProp,
    defaultValue: defaultValue2,
    onValueChange = function() {
    },
    disableDeactivation = false
  } = _a, toggleGroupSingleProps = __objRest(_a, [
    "value",
    "defaultValue",
    "onValueChange",
    "disableDeactivation"
  ]), [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue2,
    onChange: onValueChange
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupValueProvider, {
    scope: props.__scopeToggleGroup,
    type: "single",
    value: value ? [value] : [],
    defaultValue: value,
    onItemActivate: setValue,
    onItemDeactivate: React.useCallback(function() {
      return disableDeactivation ? null : setValue("");
    }, [setValue, disableDeactivation]),
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupImpl, __spreadProps(__spreadValues({}, toggleGroupSingleProps), {
      ref: forwardedRef
    }))
  });
}), ToggleGroupImplMultiple = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    value: valueProp,
    defaultValue: defaultValue2,
    onValueChange = function() {
    },
    disableDeactivation
  } = _a, toggleGroupMultipleProps = __objRest(_a, [
    "value",
    "defaultValue",
    "onValueChange",
    "disableDeactivation"
  ]), [value = [], setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue2,
    onChange: onValueChange
  }), handleButtonActivate = React.useCallback(function(itemValue) {
    return setValue(function() {
      var prevValue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      return [...prevValue, itemValue];
    });
  }, [setValue]), handleButtonDeactivate = React.useCallback(function(itemValue) {
    return setValue(function() {
      var prevValue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      return prevValue.filter(function(value2) {
        return value2 !== itemValue;
      });
    });
  }, [setValue]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupValueProvider, {
    scope: props.__scopeToggleGroup,
    type: "multiple",
    value,
    defaultValue: value,
    onItemActivate: handleButtonActivate,
    onItemDeactivate: handleButtonDeactivate,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupImpl, __spreadProps(__spreadValues({}, toggleGroupMultipleProps), {
      ref: forwardedRef
    }))
  });
});
ToggleGroup.displayName = TOGGLE_GROUP_NAME;
var ToggleGroupImplElementFrame = styled(Group, {
  name: TOGGLE_GROUP_NAME,
  variants: {
    unstyled: {
      false: {
        backgroundColor: "$background"
      }
    },
    orientation: {
      vertical: {
        flexDirection: "column",
        spaceDirection: "vertical"
      },
      horizontal: {
        flexDirection: "row",
        spaceDirection: "horizontal"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), ToggleGroupImpl = ToggleGroupImplElementFrame.extractable(/* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    __scopeToggleGroup,
    disabled = false,
    orientation = "horizontal",
    dir,
    rovingFocus = true,
    loop = true,
    unstyled = false,
    size: sizeProp = "$true",
    sizeAdjust = 0
  } = _a, toggleGroupProps = __objRest(_a, [
    "__scopeToggleGroup",
    "disabled",
    "orientation",
    "dir",
    "rovingFocus",
    "loop",
    "unstyled",
    "size",
    "sizeAdjust"
  ]), direction = useDirection(dir), commonProps = __spreadValues({
    role: "group",
    dir: direction
  }, toggleGroupProps), adjustedSize = getVariableValue(getSize(sizeProp, {
    shift: sizeAdjust
  })), size = Math.round(adjustedSize * 0.45);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupContext, {
    scope: __scopeToggleGroup,
    rovingFocus,
    disabled,
    size,
    children: rovingFocus ? /* @__PURE__ */ jsxRuntimeExports.jsx(RovingFocusGroup, {
      asChild: "except-style",
      __scopeRovingFocusGroup: __scopeToggleGroup || TOGGLE_GROUP_CONTEXT,
      orientation,
      dir: direction,
      loop,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupImplElementFrame, __spreadValues({
        "aria-orientation": orientation,
        orientation,
        axis: orientation,
        ref: forwardedRef,
        "data-disabled": disabled ? "" : void 0,
        unstyled
      }, commonProps))
    }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupImplElementFrame, __spreadValues({
      "aria-orientation": orientation,
      ref: forwardedRef,
      orientation,
      "data-disabled": disabled ? "" : void 0,
      unstyled
    }, commonProps))
  });
}));
var RenderChildren$1 = function(props) {
  return props.children;
}, RenderNull = function(props) {
  return null;
}, TooltipGroup = function() {
  return null;
}, closeOpenTooltips = function() {
}, Tooltip = withStaticProperties(RenderChildren$1, {
  Anchor: RenderChildren$1,
  Arrow: RenderNull,
  Close: RenderNull,
  Content: RenderNull,
  Trigger: RenderChildren$1
});
var RenderChildren = function(props) {
  return props.children;
}, TooltipSimple = RenderChildren;
function getWindowSize() {
  return Dimensions.get("window");
}
var cbs = /* @__PURE__ */ new Set();
Dimensions.addEventListener("change", function(param) {
  var {
    window: window2
  } = param;
  cbs.forEach(function(cb) {
    return cb(window2);
  });
});
function subscribe(cb) {
  return cbs.add(cb), function() {
    return cbs.delete(cb);
  };
}
var initialValue = {
  width: 800,
  height: 600,
  scale: 1,
  fontScale: 1
};
function configureInitialWindowDimensions(next) {
  Object.assign(initialValue, next);
}
function useWindowDimensions() {
  var {
    serverValue = initialValue
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return React.useSyncExternalStore(subscribe, getWindowSize, function() {
    return getWindowSize();
  });
}
var VisuallyHidden = styled(Text$2, {
  position: "absolute",
  width: 1,
  height: 1,
  margin: -1,
  zIndex: -1e4,
  overflow: "hidden",
  opacity: 1e-8,
  pointerEvents: "none",
  variants: {
    preserveDimensions: {
      true: {
        position: "relative",
        width: "auto",
        height: "auto"
      }
    },
    visible: {
      true: {
        position: "relative",
        width: "auto",
        height: "auto",
        margin: 0,
        zIndex: 1,
        overflow: "visible",
        opacity: 1,
        pointerEvents: "auto"
      }
    }
  }
});
VisuallyHidden.isVisuallyHidden = true;
const createTamagui = createTamagui$1;
const TamaguiProvider = (_c) => {
  var _d = _c, { children } = _d, props = __objRest(_d, ["children"]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TamaguiProvider$1, __spreadProps(__spreadValues({}, props), { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ZIndexStackContext.Provider, { value: 1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider, { shouldAddRootHost: true, children }) }) }));
};
const AnchorFrame = styled(SizableText, {
  name: "Anchor",
  tag: "a",
  accessibilityRole: "link"
});
const Anchor = AnchorFrame.styleable(
  (_e, ref) => {
    var _f = _e, { href, target } = _f, props = __objRest(_f, ["href", "target"]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      AnchorFrame,
      __spreadProps(__spreadValues(__spreadValues({}, props), {
        onPress: (event) => {
          var _a;
          (_a = props.onPress) == null ? void 0 : _a.call(props, event);
          if (href !== void 0) {
            LinkingInstance.openURL(href);
          }
        }
      }), {
        ref
      })
    );
  }
);
const EnsureFlexed = styled(Text$1, {
  opacity: 0,
  lineHeight: 0,
  height: 0,
  display: "flex",
  fontSize: 200,
  children: "wwwwwwwwwwwwwwwwwww",
  pointerEvents: "none"
});
EnsureFlexed["isVisuallyHidden"] = true;
const Fieldset = styled(YStack, {
  name: "Fieldset",
  tag: "fieldset",
  // remove browser default styling
  borderWidth: 0,
  variants: {
    horizontal: {
      true: {
        flexDirection: "row",
        alignItems: "center"
      }
    }
  }
});
const inputSizeVariant = (val = "$true", extras) => {
  if (extras.props.multiline || extras.props.numberOfLines > 1) {
    return textAreaSizeVariant(val, extras);
  }
  const buttonStyles = getButtonSized(val, extras);
  const paddingHorizontal = getSpace(val, {
    shift: -1,
    bounds: [2]
  });
  const fontStyle = getFontSized(val, extras);
  if (fontStyle) {
    delete fontStyle["lineHeight"];
  }
  return __spreadProps(__spreadValues(__spreadValues({}, fontStyle), buttonStyles), {
    paddingHorizontal
  });
};
const textAreaSizeVariant = (val = "$true", extras) => {
  var _a;
  const { props } = extras;
  const buttonStyles = getButtonSized(val, extras);
  const fontStyle = getFontSized(val, extras);
  const lines = (_a = props.rows) != null ? _a : props.numberOfLines;
  const height = typeof lines === "number" ? lines * getVariableValue(fontStyle.lineHeight) : "auto";
  const paddingVertical = getSpace(val, {
    shift: -2,
    bounds: [2]
  });
  const paddingHorizontal = getSpace(val, {
    shift: -1,
    bounds: [2]
  });
  return __spreadProps(__spreadValues(__spreadValues({}, buttonStyles), fontStyle), {
    paddingVertical,
    paddingHorizontal,
    height
  });
};
const defaultStyles = __spreadProps(__spreadValues({
  size: "$true",
  fontFamily: "$body",
  borderWidth: 1,
  outlineWidth: 0,
  color: "$color"
}, {
  focusable: true
}), {
  borderColor: "$borderColor",
  backgroundColor: "$background",
  // this fixes a flex bug where it overflows container
  minWidth: 0,
  hoverStyle: {
    borderColor: "$borderColorHover"
  },
  focusStyle: {
    borderColor: "$borderColorFocus"
  },
  focusVisibleStyle: {
    outlineColor: "$outlineColor",
    outlineWidth: 2,
    outlineStyle: "solid"
  }
});
const InputFrame = styled(
  TextInput,
  {
    name: "Input",
    variants: {
      unstyled: {
        false: defaultStyles
      },
      size: {
        "...size": inputSizeVariant
      },
      disabled: {
        true: {}
      }
    },
    defaultVariants: {
      unstyled: process.env.TAMAGUI_HEADLESS === "1"
    }
  },
  {
    isInput: true,
    accept: {
      placeholderTextColor: "color",
      selectionColor: "color"
    }
  }
);
const Input = InputFrame.styleable((propsIn, forwardedRef) => {
  const ref = React.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const props = useInputProps(propsIn, composedRefs);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputFrame, __spreadValues({}, props));
});
function useInputProps(props, ref) {
  const theme = useTheme();
  const focusableProps = useFocusable({
    props,
    ref,
    isInput: true
  });
  const placeholderTextColor = React.useMemo(() => {
    var _a, _b, _c, _d;
    const placeholderColorProp = props.placeholderTextColor;
    return (_d = (_b = (_a = theme[placeholderColorProp]) == null ? void 0 : _a.get()) != null ? _b : placeholderColorProp) != null ? _d : (_c = theme.placeholderColor) == null ? void 0 : _c.get();
  }, [props.placeholderTextColor, theme]);
  return React.useMemo(
    () => __spreadProps(__spreadValues({
      ref: focusableProps.ref,
      readOnly: props.disabled
    }, props), {
      placeholderTextColor,
      onChangeText: focusableProps.onChangeText
    }),
    [
      focusableProps.ref,
      focusableProps.onChangeText,
      props.disabled,
      props,
      placeholderTextColor
    ]
  );
}
const Spinner = YStack.extractable(
  themeable(
    React__namespace.forwardRef((props, ref) => {
      const _a = props, { size, color: colorProp } = _a, stackProps = __objRest(_a, ["size", "color"]);
      const theme = useTheme();
      let color = colorProp;
      if (color && color[0] === "$") {
        color = variableToString(theme[color]);
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(YStack, __spreadProps(__spreadValues({ ref }, stackProps), { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ActivityIndicator, { size, color }) }));
    }),
    {
      componentName: "Spinner"
    }
  )
);
const TextAreaFrame = styled(InputFrame, {
  name: "TextArea",
  multiline: true,
  // this attribute fixes firefox newline issue
  whiteSpace: "pre-wrap",
  variants: {
    unstyled: {
      false: __spreadValues({
        height: "auto"
      }, defaultStyles)
    },
    size: {
      "...size": textAreaSizeVariant
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
});
const TextArea = TextAreaFrame.styleable(
  (propsIn, forwardedRef) => {
    const ref = React.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const props = useInputProps(propsIn, composedRefs);
    const linesProp = {
      // web uses rows now, but native not caught up :/
      ["numberOfLines"]: propsIn.unstyled ? void 0 : 4
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TextAreaFrame, __spreadValues(__spreadValues({}, linesProp), props));
  }
);
const Text = styled(Text$1, {
  variants: {
    unstyled: {
      false: {
        color: "$color"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
});
exports.ACTIONS = ACTIONS;
exports.Accordion = Accordion;
exports.Adapt = Adapt;
exports.AdaptContents = AdaptContents;
exports.AdaptContext = AdaptContext;
exports.AdaptParent = AdaptParent;
exports.AdaptPortalContents = AdaptPortalContents;
exports.AlertDialog = AlertDialog;
exports.AlertDialogAction = AlertDialogAction;
exports.AlertDialogCancel = AlertDialogCancel;
exports.AlertDialogContent = AlertDialogContent;
exports.AlertDialogDescription = AlertDialogDescription;
exports.AlertDialogOverlay = AlertDialogOverlay;
exports.AlertDialogPortal = AlertDialogPortal;
exports.AlertDialogTitle = AlertDialogTitle;
exports.AlertDialogTrigger = AlertDialogTrigger;
exports.Anchor = Anchor;
exports.AnimatePresence = AnimatePresence;
exports.Article = Article;
exports.Aside = Aside;
exports.Avatar = Avatar;
exports.AvatarFallback = AvatarFallback;
exports.AvatarFallbackFrame = AvatarFallbackFrame;
exports.AvatarFrame = AvatarFrame;
exports.AvatarImage = AvatarImage;
exports.Button = Button2;
exports.ButtonContext = ButtonContext;
exports.ButtonFrame = ButtonFrame;
exports.ButtonIcon = ButtonIcon;
exports.ButtonNestingContext = ButtonNestingContext;
exports.ButtonText = ButtonText;
exports.Card = Card;
exports.CardBackground = CardBackground;
exports.CardFooter = CardFooter;
exports.CardFrame = CardFrame;
exports.CardHeader = CardHeader;
exports.Checkbox = Checkbox;
exports.CheckboxContext = CheckboxContext;
exports.CheckboxFrame = CheckboxFrame;
exports.CheckboxIndicatorFrame = CheckboxIndicatorFrame;
exports.CheckboxStyledContext = CheckboxStyledContext;
exports.Circle = Circle;
exports.ComponentContext = ComponentContext;
exports.Configuration = Configuration;
exports.Dialog = Dialog;
exports.DialogClose = DialogClose;
exports.DialogContent = DialogContent;
exports.DialogContext = DialogContext;
exports.DialogDescription = DialogDescription;
exports.DialogOverlay = DialogOverlay;
exports.DialogOverlayFrame = DialogOverlayFrame;
exports.DialogPortal = DialogPortal;
exports.DialogPortalFrame = DialogPortalFrame;
exports.DialogProvider = DialogProvider;
exports.DialogTitle = DialogTitle;
exports.DialogTrigger = DialogTrigger;
exports.DialogWarningProvider = DialogWarningProvider;
exports.EnsureFlexed = EnsureFlexed;
exports.Fieldset = Fieldset;
exports.FontLanguage = FontLanguage;
exports.Footer = Footer;
exports.Form = Form2;
exports.FormFrame = FormFrame;
exports.FormProvider = FormProvider;
exports.FormTrigger = FormTrigger;
exports.ForwardSelectContext = ForwardSelectContext;
exports.Frame = Frame;
exports.Group = Group;
exports.GroupContext = GroupContext;
exports.GroupFrame = GroupFrame;
exports.H1 = H1;
exports.H2 = H2;
exports.H3 = H3;
exports.H4 = H4;
exports.H5 = H5;
exports.H6 = H6;
exports.Handle = Handle;
exports.Header = Header;
exports.Heading = Heading;
exports.INITIAL_STATE = INITIAL_STATE;
exports.IS_FABRIC = IS_FABRIC;
exports.Image = Image;
exports.Input = Input;
exports.InputFrame = InputFrame;
exports.Label = Label;
exports.LabelFrame = LabelFrame;
exports.ListItem = ListItem2;
exports.ListItemFrame = ListItemFrame;
exports.ListItemSubtitle = ListItemSubtitle;
exports.ListItemText = ListItemText;
exports.ListItemTitle = ListItemTitle;
exports.Main = Main;
exports.Nav = Nav;
exports.Overlay = Overlay;
exports.Paragraph = Paragraph;
exports.ParentSheetContext = ParentSheetContext;
exports.Popover = Popover;
exports.PopoverAnchor = PopoverAnchor;
exports.PopoverArrow = PopoverArrow;
exports.PopoverClose = PopoverClose;
exports.PopoverContent = PopoverContent;
exports.PopoverContext = PopoverContext;
exports.PopoverTrigger = PopoverTrigger;
exports.Popper = Popper;
exports.PopperAnchor = PopperAnchor;
exports.PopperArrow = PopperArrow;
exports.PopperArrowFrame = PopperArrowFrame;
exports.PopperContent = PopperContent;
exports.PopperContentFrame = PopperContentFrame;
exports.PopperContextFast = PopperContextFast;
exports.PopperContextSlow = PopperContextSlow;
exports.PopperPositionContext = PopperPositionContext;
exports.PopperProvider = PopperProvider;
exports.PopperProviderFast = PopperProviderFast;
exports.PopperProviderSlow = PopperProviderSlow;
exports.Portal = Portal;
exports.PortalHost = PortalHost;
exports.PortalItem = GorhomPortalItem;
exports.PortalProvider = PortalProvider;
exports.PresenceChild = PresenceChild;
exports.PresenceContext = PresenceContext;
exports.Progress = Progress;
exports.ProgressFrame = ProgressFrame;
exports.ProgressIndicator = ProgressIndicator;
exports.ProgressIndicatorFrame = ProgressIndicatorFrame;
exports.ProvideAdaptContext = ProvideAdaptContext;
exports.RadioGroup = RadioGroup;
exports.RadioGroupFrame = RadioGroupFrame;
exports.RadioGroupIndicatorFrame = RadioGroupIndicatorFrame;
exports.RadioGroupItemFrame = RadioGroupItemFrame;
exports.RadioGroupStyledContext = RadioGroupStyledContext;
exports.Range = Range;
exports.ResetPresence = ResetPresence;
exports.ScrollView = ScrollView2;
exports.Section = Section;
exports.Select = Select;
exports.SelectGroupFrame = SelectGroupFrame;
exports.SelectIcon = SelectIcon;
exports.SelectItemParentProvider = SelectItemParentProvider;
exports.SelectProvider = SelectProvider;
exports.SelectSeparator = SelectSeparator;
exports.Separator = Separator;
exports.Sheet = Sheet;
exports.SheetController = SheetController;
exports.SheetControllerContext = SheetControllerContext;
exports.SheetHandleFrame = SheetHandleFrame;
exports.SheetInsideSheetContext = SheetInsideSheetContext;
exports.SheetOverlayFrame = SheetOverlayFrame;
exports.SheetScrollView = SheetScrollView;
exports.SizableStack = SizableStack;
exports.SizableText = SizableText;
exports.Slider = Slider;
exports.SliderContext = SliderContext;
exports.SliderFrame = SliderFrame;
exports.SliderThumb = SliderThumb;
exports.SliderThumbFrame = SliderThumbFrame;
exports.SliderTrack = SliderTrack;
exports.SliderTrackActive = SliderTrackActive;
exports.SliderTrackActiveFrame = SliderTrackActiveFrame;
exports.SliderTrackFrame = SliderTrackFrame;
exports.Spacer = Spacer;
exports.Spinner = Spinner;
exports.Square = Square;
exports.Stack = Stack;
exports.StyleObjectIdentifier = StyleObjectIdentifier;
exports.StyleObjectProperty = StyleObjectProperty;
exports.StyleObjectPseudo = StyleObjectPseudo;
exports.StyleObjectRules = StyleObjectRules;
exports.StyleObjectValue = StyleObjectValue;
exports.Switch = Switch;
exports.SwitchContext = SwitchContext;
exports.SwitchFrame = SwitchFrame;
exports.SwitchStyledContext = SwitchStyledContext;
exports.SwitchThumb = SwitchThumb;
exports.Tabs = Tabs;
exports.TabsProvider = TabsProvider;
exports.TamaguiProvider = TamaguiProvider;
exports.Text = Text;
exports.TextArea = TextArea;
exports.TextAreaFrame = TextAreaFrame;
exports.Theme = Theme;
exports.ThemeableStack = ThemeableStack;
exports.Thumb = Thumb;
exports.ToggleGroup = ToggleGroup;
exports.Tooltip = Tooltip;
exports.TooltipGroup = TooltipGroup;
exports.TooltipSimple = TooltipSimple;
exports.Track = Track;
exports.USE_NATIVE_PORTAL = USE_NATIVE_PORTAL;
exports.Unspaced = Unspaced;
exports.View = View;
exports.VisuallyHidden = VisuallyHidden;
exports.XGroup = XGroup;
exports.XStack = XStack;
exports.YGroup = YGroup;
exports.YStack = YStack;
exports.ZStack = ZStack;
exports.addTheme = addTheme;
exports.allPortalHosts = allPortalHosts;
exports.clamp = clamp$1;
exports.closeOpenTooltips = closeOpenTooltips;
exports.composeEventHandlers = composeEventHandlers;
exports.composeRefs = composeRefs;
exports.configureInitialWindowDimensions = configureInitialWindowDimensions;
exports.createAvatarScope = createAvatarScope;
exports.createCheckbox = createCheckbox;
exports.createComponent = createComponent;
exports.createContext = createContext;
exports.createContextScope = createContextScope;
exports.createFont = createFont;
exports.createMedia = createMedia;
exports.createProgressScope = createProgressScope;
exports.createRadioGroup = createRadioGroup;
exports.createSheet = createSheet;
exports.createSheetScope = createSheetScope;
exports.createShorthands = createShorthands;
exports.createStyledContext = createStyledContext;
exports.createSwitch = createSwitch;
exports.createTabs = createTabs;
exports.createTamagui = createTamagui;
exports.createTheme = createTheme;
exports.createTokens = createTokens;
exports.createVariable = createVariable;
exports.debounce = debounce;
exports.defaultStyles = defaultStyles;
exports.fullscreenStyle = fullscreenStyle;
exports.getCSSStylesAtomic = getCSSStylesAtomic;
exports.getConfig = getConfig;
exports.getFontSize = getFontSize;
exports.getFontSizeToken = getFontSizeToken;
exports.getFontSizeVariable = getFontSizeVariable;
exports.getMedia = getMedia;
exports.getNativeSheet = getNativeSheet;
exports.getShapeSize = getShapeSize;
exports.getThemes = getThemes;
exports.getToken = getToken;
exports.getTokenValue = getTokenValue;
exports.getTokens = getTokens;
exports.getVariable = getVariable;
exports.getVariableName = getVariableName;
exports.getVariableValue = getVariableValue;
exports.insertFont = insertFont;
exports.isChrome = isChrome;
exports.isClient = isClient;
exports.isPresent = isPresent;
exports.isServer = isServer;
exports.isServerSide = isServerSide;
exports.isTamaguiComponent = isTamaguiComponent;
exports.isTamaguiElement = isTamaguiElement;
exports.isTouchable = isTouchable;
exports.isVariable = isVariable;
exports.isWeb = isWeb;
exports.isWebTouchable = isWebTouchable;
exports.matchMedia = matchMedia$1;
exports.mediaObjectToString = mediaObjectToString;
exports.mediaQueryConfig = mediaQueryConfig;
exports.mutateThemes = mutateThemes;
exports.portalListeners = portalListeners;
exports.prevent = prevent;
exports.replaceTheme = replaceTheme;
exports.resolveViewZIndex = resolveViewZIndex;
exports.setConfig = setConfig;
exports.setOnLayoutStrategy = setOnLayoutStrategy;
exports.setRef = setRef;
exports.setupDev = setupDev;
exports.setupNativeSheet = setupNativeSheet;
exports.setupPopper = setupPopper;
exports.setupReactNative = setupReactNative;
exports.shouldRenderNativePlatform = shouldRenderNativePlatform;
exports.simpleHash = simpleHash;
exports.spacedChildren = spacedChildren;
exports.stylePropsAll = stylePropsAll;
exports.stylePropsText = stylePropsText;
exports.stylePropsTextOnly = stylePropsTextOnly;
exports.stylePropsTransform = stylePropsTransform;
exports.stylePropsUnitless = stylePropsUnitless;
exports.stylePropsView = stylePropsView;
exports.styled = styled;
exports.themeable = themeable;
exports.themeableVariants = themeableVariants;
exports.tokenCategories = tokenCategories;
exports.updateTheme = updateTheme;
exports.useAdaptContext = useAdaptContext;
exports.useAdaptIsActive = useAdaptIsActive;
exports.useButton = useButton;
exports.useComposedRefs = useComposedRefs;
exports.useConfiguration = useConfiguration;
exports.useControllableState = useControllableState;
exports.useCurrentColor = useCurrentColor;
exports.useDebounce = useDebounce;
exports.useDebounceValue = useDebounceValue;
exports.useDialogContext = useDialogContext;
exports.useDidFinishSSR = useDidFinishSSR;
exports.useEvent = useEvent;
exports.useFloatingContext = useFloatingContext;
exports.useForceUpdate = useForceUpdate;
exports.useFormContext = useFormContext;
exports.useGet = useGet;
exports.useGetThemedIcon = useGetThemedIcon;
exports.useGroupItem = useGroupItem;
exports.useInputProps = useInputProps;
exports.useIsPresent = useIsPresent;
exports.useIsTouchDevice = useIsTouchDevice;
exports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;
exports.useLabelContext = useLabelContext;
exports.useListItem = useListItem;
exports.useMedia = useMedia;
exports.usePopoverContext = usePopoverContext;
exports.usePopperContext = usePopperContext;
exports.usePopperContextSlow = usePopperContextSlow;
exports.usePortal = usePortal;
exports.usePresence = usePresence;
exports.useProps = useProps;
exports.usePropsAndStyle = usePropsAndStyle;
exports.useSelectContext = useSelectContext;
exports.useSelectItemParentContext = useSelectItemParentContext;
exports.useSheet = useSheet;
exports.useSheetController = useSheetController;
exports.useSheetOffscreenSize = useSheetOffscreenSize;
exports.useSheetOpenState = useSheetOpenState;
exports.useStyle = useStyle;
exports.useTabsContext = useTabsContext;
exports.useTheme = useTheme;
exports.useThemeName = useThemeName;
exports.useWindowDimensions = useWindowDimensions;
exports.validPseudoKeys = validPseudoKeys;
exports.validStyles = validStyles;
exports.variableToString = variableToString;
exports.withStaticProperties = withStaticProperties;
exports.wrapChildrenInText = wrapChildrenInText;
